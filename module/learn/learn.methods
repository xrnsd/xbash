#!/bin/bash
##################################################
##                                              ##
##             学习工具实现                      ##
##                                              ##
##################################################
complete -W "-h --help" ftEnglishRepetionDrillEveryDay
ftEnglishRepetionDrillEveryDay()
{
    local ftEffect=英语例句每天练习
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPathTempEng=$(ftIniGetValue  $rFilePathXbashDBUser learnCourseInfo  dirPathRoot)
    [[ -z $dirPathTempEng ]] && ftEcho -e "数据存放路径为空" && return
    local filePathEnglishBasic=${dirPathTempEng}/english.basic
    local filePathChineseBasic=${dirPathTempEng}/chinese.basic
    local isRest=true

    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    ftEnglishRepetionDrillEveryDay -h
#========================================================="; return ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #环境校验
    if [[ -d $dirPathTempEng ]] && [[ -f $filePathEnglishBasic ]]; then
        ftEcho -y "存在旧练习本，是否删除(回车默认y)"
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y ) rm -rf $dirPathTempEng
                        break ;;
                n | q ) isRest=false
                        break ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
        esac;done
        echo
    fi
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftEnglishRepetionDrillEveryDay -h && return $resultFail

    #实现主体
    if $isRest; then
        if ! mkdir -p $dirPathTempEng; then
            ftEcho -e "无法创建文件夹:${dirPathTempEng}"
            return
        fi
        if touch $filePathEnglishBasic $filePathChineseBasic; then
            XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathEnglishBasic $filePathChineseBasic
        else
            ftEcho -ex "创建信息文件失败"
            return;
        fi
    fi
    local fileSizeEnglishBasic=$(sed -n '$=' $filePathEnglishBasic)
    local fileSizeChineseBasic=$(sed -n '$=' $filePathChineseBasic)
    if (($fileSizeEnglishBasic==0)) \
        || (($fileSizeChineseBasic==0)) \
        || (($fileSizeChineseBasic!=$fileSizeEnglishBasic)) ; then
        ftEcho -ex "信息文件内容为空或数量不一致"
        return;
    fi

    clear
    local arrayIndexSort=$(seq 1 $fileSizeEnglishBasic | sed 's/ /\n/g' | shuf)
    local englishItem
    for i in ${arrayIndexSort[@]}; do
        englishItem=$(awk 'NR=="'$i'"' $filePathEnglishBasic)
        ftEcho -frame $(awk 'NR=="'$i'"' $filePathChineseBasic)
        echo && ftEcho -s "按T显示翻译，其他任意键继续" && read -n 1 sel

        if [[ $sel == "t" ]]; then 
            clear
            ftEcho -frame  $englishItem
            echo && ftEcho -s "按任意键继续" && read -n 1 sel2
        fi
        englishItem=
        clear
    done
}

complete -W "-h --help --rely_install -p -l" -A file ftOcrRepetionDrill 
ftOcrRepetionDrill()
{
    local ftEffect=英语图片文本语音合成
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local flag="."
    local sentence sentenceContent filePath sentenceHeaderFlag=0
    local valCount=4 errorContent arg arg2 # arg3 # arg4
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    #eval arg3=\${$((i+2))} #; eval arg4=\${$((i+3))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftOcrRepetionDrill --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install xxxx
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftOcrRepetionDrill -p 图片路径 -l 句子截取长度
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -p ) filePath="${arg2}"
            ;;
        -l ) sentenceHeaderFlag="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
    [[ -z $(which tesseract) ]] && ftOcrRepetionDrill --rely "tesseract-ocr-eng" && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -f "${filePath}" ] && errorContent="${errorContent}\\n[文件不存在]$filePath"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftOcrRepetionDrill -h && return $resultFail

    #实现主体
    local fileType=${filePath##*.}
    if [[ $fileType != "txt" ]]; then
        ftEcho -s "图片OCR处理中..."
        local filePathTemp=/tmp/ocrTemp
        if tesseract "${filePath}" "${filePathTemp}"; then
            filePath="${filePathTemp}.txt"
        else
            ftEcho -e "OCR处理失败"
            return
        fi
    fi

    ftEcho -s "句子切分中..."
    while read -u 3 -d "$flag" -a sentence;do
      if (( $sentenceHeaderFlag>0 )) && (( ${#sentence[@]}>$sentenceHeaderFlag )); then
          for (( i = 0; i < ${sentenceHeaderFlag}; i++ )); do
            eval word=\${sentence[$i]}
            sentenceContent="${sentenceContent} ${word}"
          done
      else
        sentenceContent=${sentence[@]}
      fi
      ftEcho -sn "开始合成下面句子语音： "
      echo "${sentenceContent}"
      ftEdgeTTs --speed 10 --playContent "${sentenceContent}" > /dev/null
      #重置缓存
      sentenceContent=

      ftEcho -s "是否继续下一句(回车继续/其他任意键取消)"
      read -n 1 sel
      [ -n "${sel}" ] && return
    done 3< $filePath
}


complete -W "-h --help -acg --ac" ftLearnCourseManage
ftLearnCourseManage()
{
    local ftEffect=学习课程配置
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local isAddCourseGroup=false isAddCourse=false
    local learnCourseGroupList=($(ftIniGetValue  $rFilePathXbashDBUser learnCourseInfo  courseGroupList))
    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftLearnCourseManage xxxx
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -acg) isAddCourseGroup=true
                     ;;
        -ac) isAddCourse=true
                     ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftLearnCourseManage -h && return $resultFail

    #实现主体
    if $isAddCourseGroup; then
        local dirPathTempEng=$(ftIniGetValue  $rFilePathXbashDBUser learnConfigInfo  dirPathRoot)
        [[ -z $dirPathTempEng ]] && ftEcho -e "数据存放路径为空" && return
        ftEcho -r  "请输入课程集名称："
        read courseGroupName
        courseGroupName=$(echo $courseGroupName |sed s/[[:space:]]//g)
        learnCourseGroupList=(${learnCourseGroupList[@]} $courseGroupName)
        ftIniSetValue $rFilePathXbashDBUser learnCourseInfo  courseGroupList ${learnCourseGroupList[@]}
        ftIniAddItem -p $rFilePathXbashDBUser -t learnCourseInfo -i $courseGroupName -l "none"
        #创建课程文件夹
        mkdir -p ${dirPathTempEng}/$courseGroupName
        return
    fi
    if $isAddCourse; then
        local dirPathTempEng=$(ftIniGetValue  $rFilePathXbashDBUser learnConfigInfo  dirPathRoot)
        [[ -z $dirPathTempEng ]] && ftEcho -e "数据存放路径为空" && return
        
        local courseGroupNameSel index=0
        for dev in ${learnCourseGroupList[*]} ; do
            echo "[${index}] ${dev}"
            ((index+=1))
        done
        if ((  $index == 1 ));then
            courseGroupNameSel=$learnCourseGroupList
        else
            while true; do
                ftEcho -r  "请选择课程集[0~$(expr $index - 1),q](回车默认0):"
                if (( $index > 9 ));then
                    read dir
                else
                    read -n 1 dir
                fi
                #设定默认值
                 [ ${#dir} == 0 ] && dir=0
                 if [ ${dir} == "q" ]; then
                    exit
                 elif [ -n "$(echo $dir| sed -n "/^[0-$index]\+$/p")" ];then
                    courseGroupNameSel=${learnCourseGroupList[$dir]}
                    echo
                    break;
                 fi
                 ftEcho -e 错误的选择：$dir
            done
        fi

        ftEcho -r  "请输入课程名称："
        read courseName
        courseName=$(echo $courseName |sed s/[[:space:]]//g)

        local dirPathCourseGroup="${dirPathTempEng}/${courseGroupNameSel}"
        local filePathEnglishBasic="${dirPathCourseGroup}/${courseName}.english"
        local filePathChineseBasic="${dirPathCourseGroup}/${courseName}.chinese"
        if touch $filePathEnglishBasic $filePathChineseBasic; then
            XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathEnglishBasic $filePathChineseBasic
        else
            ftEcho -ex "创建信息文件失败"
            return;
        fi

        local learnCourseList=($(ls $dirPathCourseGroup|grep chinese |  awk -F. '{print $1}'))
        if [[ -n $learnCourseList ]]; then
            echo ${learnCourseList[@]}
            ftIniSetValue $rFilePathXbashDBUser learnCourseInfo  $courseGroupNameSel -l "${learnCourseList[*]}"
        fi
    fi
}
