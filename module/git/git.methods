#!/bin/bash
#  git常用功能的封装
ftSetBashPs1ByGitBranch()
{
    local ftEffect=根据git分支名,设定bash的PS1
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    [[ "$isUseCustomPS1" != "true" ]] && return

    local editType=$1 defaultPrefix=${rUserName:-'xbash'} defaultColorConfig=44
    [[ "$(whoami)" = "root" ]] && defaultPrefix="root" && defaultColorConfig=42
    export PS1="$defaultPrefix[\[\033[${defaultColorConfig}m\]\w\[\033[0m\]]: "

    [[ -z $(which git) ]] && return

    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local branchNameAll
    if [ -n "$branchName" ] && [ "$editType" != "-b" ];then
        local ps1=$(pwd)${branchName}
        branchNameAll="branchName→ ${branchName}: "
        [[ -n "${COLUMNS}" ]] && (( ${#ps1}>$COLUMNS/2-11 )) && branchNameAll="\nbranchName→ ${branchName}: "
        export PS1="$defaultPrefix[\[\033[${defaultColorConfig}m\]\w\[\033[0m\]]\[\033[33m\]${branchNameAll}\[\033[0m\]"
    fi
}

ftGitLogShell()
{
    local ftEffect=git的log特定格式显示
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isAllBranchLog isTagBranchLog branchLogFormat isCustomBranchLog branchLogItemCount branchLogItemCountDef=20 pathTarget
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
     --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包
#    请尝试使用 sudo apt-get install git git-core git-gui git-doc 补全依赖
#=========================================================" ;return ;;
     --env) ftEcho -rc "${ftEffect}" "的环境说明" "\
#=========================================================
#    当前目录没有有效的GIT仓库
#=========================================================" ;return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    全部分支log
#    ftGitLogShell -a
#    ftGitLogShell -a 目录/文件
#
#    ftGitLogShell -at  # 查看分支树
#    ftGitLogShell -a  路径 # 指定路径下的全部分支log
#    ftGitLogShell -n 数量
#    ftGitLogShell -nn 数量 # 不高亮显示
#    ftGitLogShell -t Tag名  #只输出包含tag的git log
#    ftGitLogShell -c \"格式字串\" #自定义格式输出
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a )  isAllBranchLog=true
                pathTarget="${arg2}"
                branchLogItemCount=0
                ;;
        -at )  gitk --simplify-by-decoration --all && return
                ;;
        -t )   branchLogFormat=${arg2:-'%s'}
                isTagBranchLog=true
                ;;
        -c )   branchLogFormat=${arg2}
                isCustomBranchLog=true
                ;;
        -n )  branchLogItemCount=${arg2:-'$branchLogItemCountDef'}
                (( $#==3 ))&&(echo -n $3 | grep -q -e "^[0-9][0-9]*$")&&(($3>$branchLogItemCount)) && branchLogItemCount=$3
                ;;
        -nn )  branchLogItemCount=${arg2:-'$branchLogItemCountDef'}
                (( $#==3 ))&&(echo -n $3 | grep -q -e "^[0-9][0-9]*$")&&(($3>$branchLogItemCount)) && branchLogItemCount=$3
                branchLogFormat="%<(21 ,trunc)%ai  %<(10,trunc)%an %h %s  %d"
                ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [[ -z $(which git) ]] && ftGitLogShell --rely && return
    [[ -n "$isAllBranchLog" ]] && [ -z $(which gitk) ] && ftGitLogShell --rely && return
    [[ -z $(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/') ]] && ftGitLogShell --env && return
    [ -z "$branchLogItemCount" ]||(($branchLogItemCount<0)) && errorContent="${errorContent}\\n[示例2]branchLogItemCount=$branchLogItemCount"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitLogShell -h && return

    #实现主体
    local gitVersionMin="2.6.0" gitVersionNow=$(git --version)
    gitVersionNow=${gitVersionNow//git version/}
    gitVersionNow=$(echo $gitVersionNow |sed s/[[:space:]]//g)

    [[ -n "$isAllBranchLog" ]] && gitk --all "${pathTarget}" && return
    [[ -n "$isTagBranchLog" ]] && git log --date=short --pretty=format:"$branchLogFormat" -$branchLogItemCount && return

    if [[ $(ftVersionComparison $gitVersionMin $gitVersionNow) = "<" ]] && [ "$isCustomBranchLog" != "true" ];then
        branchLogFormat=${branchLogFormat:-'%C(green)%<(9,trunc)%ad %Cred%<(8,trunc)%an%Creset %Cblue%<(9,trunc)%h%Creset %s %C(yellow) %d'}
        #git log --date=format-local:'%y%m%d-%H:%M:%S' --pretty=format:"$branchLogFormat" -$branchLogItemCount
        git log --date=format-local:'%y-%m-%d' --pretty=format:"$branchLogFormat" -$branchLogItemCount 
        return
    fi
    if [ "${branchLogFormat}" = "%h" ];then
        hashVal=($(git log --pretty=format:"$branchLogFormat" -$branchLogItemCount))
        echo "${hashVal[@]} "
        return
    fi
    branchLogFormat=${branchLogFormat:-'%C(green)%<(21,trunc)%ai%x08%x08%Creset %Cred%<(13,trunc)%an%Creset %Cblue%<(9,trunc)%h%Creset %s %C(yellow) %d'}
    git log --pretty=format:"$branchLogFormat" -$branchLogItemCount
}

ftGitPatchAdd2Branches()
{
    local ftEffect=添加gitPatch[多分支]
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftGitPatchAdd2Branches 无参
#    ftGitPatchAdd2Branches 分支TAG   #只操作名称中有TAG的分支
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    [ -z "$branchNameNow" ] && ftGitPatch --env && return
    local branchTag=$1 filePathBranchList=待打补丁的分支列表 filePathCommitList=patch的hash值列表
    local filePathAddPatchTool=$rFilePathXbashModuleGitAddPatchToolExample
    local filePathFailInfo="/home/wgx/.cache/ftGitPatchAdd2Branches.log" ; [ -f "$filePathFailInfo" ] && rm $filePathFailInfo
    [[ ! -f $filePathAddPatchTool  ]] && ftEcho -e "诶，帮忙看看[${filePathAddPatchTool}]在不在" && return
    [ ! -f "$filePathAddPatchTool" ] && [ -f "${filePathAddPatchTool}.example" ] &&\
        ftEcho -e "请参考${filePathAddPatchTool}.example在同目录下新建multiBranch.module" && return

    #实现主体
    git pull
    local branchList=($(git branch | sed -e "s:*::g" | grep -v "${branchNameNow}"))
    local branchListLocal=${branchList}

    local key="remotes/origin/"
    local branchListServer=($(git branch -a|grep -i "$branchNameTag" \
                                                                     | grep -v "remotes/origin/HEAD -> origin/master" \
                                                                     | grep "$key" \
                                                                     | sed -e "s:*::g" \
                                                                     | grep -v "${branchNameNow}"))
    for (( i = 0; i < ${#branchListServer[@]}; i++ )); do branchListServer[$i]=${branchListServer[$i]##*$key} ; done
    branchList=(${branchList[@]} ${branchListServer[@]}) #合并本地和仓库分支
    branchList=($(echo ${branchList[@]} | sed 's/ /\n/g'|sort |uniq)) #去重

    if [ -n "${branchTag}" ];then echo ${branchList[@]} |grep ${branchTag} | sed 's/ /\n/g' > $filePathBranchList
    else echo ${branchList[@]} | sed 's/ /\n/g' > $filePathBranchList ;fi
    XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathBranchList $filePathCommitList
    branchList=($(cat $filePathBranchList)) hashList=($(cat $filePathCommitList)) 
    rm -f $filePathBranchList $filePathCommitList
     [ -z "$branchList" ] && ftEcho -e "${filePathBranchList} 为空" && return
     [ -z "$hashList" ] && ftEcho -e "${filePathCommitList} 为空" && return

    for branchName in ${branchList[@]} ; do
        ftEcho -s "================  切换到分支: ${branchName}  添加补丁====================="

        [[ ! "${branchListLocal[@]}" =~ "${branchName}" ]] && ftEcho -y "此分支为远程分支，是否继续(回车默认y)" && read -n 1 sel && echo
        [ -z "${sel}" ] && sel=y; [[ "$sel" != "y" ]] && continue

        git checkout "$branchName"||return
        git pull

        #添加多个commit
        i=${#hashList[@]}
        local isApplyFail patchId
        while (( $i>0 ));do
            (( i-=1 ))
            patchId=${hashList[$i]}
            if ! git cherry-pick $patchId ;then
                ftEcho -e "补丁：${patchId}，添加失败"
                isApplyFail=true
                banchFailList=(${banchFailList[@]} ${branchName})
                git reset --hard
                break
            fi
        done
        [ -z "$isApplyFail" ] && if ! git push ;then
            ftEcho -s "分支${branchName} : 同步失败"
        fi
    done
    [ -n "${banchFailList}" ] && ftEcho -e "下面分支添加补丁没有成功：" &&
    for branchName in ${branchList[@]} ; do
        echo ${branchName}
    done

    ftEcho -s "开始切换初始分支：${branchNameNow}"
    git checkout "${branchNameNow}"
}

ftGitCheckoutBtanch()
{
    local ftEffect=快速切换分支
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local delayLong isAllBranchs branchNameTag
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#==========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    在本地仓库中查切分支
#    ftGitCheckoutBtanch
#
#    在本地仓库中查切含 xxxx 的分支
#    ftGitCheckoutBtanch -t xxxx
#
#    在本地+远程仓库中查切含 xxxx 的分支
#    ftGitCheckoutBtanch -a -t xxxx
#
#    在本地仓库中查切含 xxxx 的分支,延时yyyy秒后切换
#    ftGitCheckoutBtanch -t xxxx -d yyyy
#=========================================================" ;return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a ) isAllBranchs=true ;;
        -t ) branchNameTag="${arg2}" ;;
        -d ) delayLong="${arg2}" ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    if [[ -z "$branchNameTag" ]]; then
        git branch
        return
    fi
    #依赖校验
    [[ -z $(which git) ]] && ftGitCheckoutBtanch --rely "git" && return
    #参数校验
    [ -z "$branchNameTag" ] && errorContent="${errorContent}\\n[分支TAg为空]branchNameTag=$branchNameTag"
    [ -n "$delayLong" ] && ( ! echo -n $delayLong | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[延时设定错误]delayLong=$delayLong"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitCheckoutBtanch -h && return

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local branchList=($(git branch|grep -i "$branchNameTag" | sed -e "s:*::g"))
    for (( i = 0; i < ${#branchList[*]}; i++ )); do [[ "${branchList[$i]}" = "${branchNameNow}" ]] && unset branchList[$i] && break ;done

    if [[ -n "$isAllBranchs" ]];then
        local key="remotes/origin/"
        local branchListServer=($(git branch -a|grep -i "$branchNameTag" \
                                                                         |grep -v "remotes/origin/HEAD -> origin/master" \
                                                                         |grep "$key" \
                                                                         | sed -e "s:*::g"))
        for (( i = 0; i < ${#branchListServer[*]}; i++ )); do [[ "${branchListServer[$i]}" = "${branchNameNow}" ]] && \
        unset branchListServer[$i] && break ;done

        for (( i = 0; i < ${#branchListServer[@]}; i++ )); do branchListServer[$i]=${branchListServer[$i]##*$key} ; done
        branchList=(${branchList[@]} ${branchListServer[@]}) #合并本地和仓库分支
        branchList=($(echo ${branchList[@]} | sed 's/ /\n/g'|sort |uniq)) #去重
    fi

    if [[ -z "${branchList[@]}" ]];then
       [[ -n $(echo $branchNameNow |grep -i "${branchNameTag}") ]] && ftEcho -s "只有当前分支包含TAG，无需切换" && return
       ftEcho -e "未找到[$branchNameTag]对应的分支" && return
    fi
    local itemCount=${#branchList[@]}
    for item in ${branchList[@]} ; do [ -n "$item" ] && branchNameTraget=$item && break ;done
    if (( $itemCount>1 ));then
        local index=0 indexNow=-1
        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        branchNameTag=${branchNameTag^^}
        for item in $(git branch|grep -i "$branchNameTag" ) ; do
            [[  ! ${item^^} =~ "$branchNameTag"  ]] && indexNow=$((index)) && break
            ((index+=1))
        done ; index=0
        for item in ${branchList[@]} ; do
            echo -n "[" ; ftEcho -sn "$(printf "%${length}d" $index)" ; echo -n "]"  ; printf "   %-4s\n" $item
            if (( $index == $indexNow-1 )) || (( $index == $itemCount-1 && $indexNow!=-1 ));then
                    ftEcho -sn "$(printf "%${length}s" "-" | sed -e "s: :-:g")" && ftEcho -sn "->" && ftEcho -s "$(printf "   %-4s\n" $branchNameNow)"
                    indexNow=-1
            fi
            ((index+=1))
        done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex && echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return
        index=0;for item in ${branchList[@]} ; do
            [ -z "$item" ] && continue
            (( $index == $tIndex )) && branchNameTraget=$item && break
            ((index+=1))
        done
    fi

    while true; do
        echo -n "目标分支: ";ftEcho -sn "${branchNameTraget}  "
        ftEcho -y "是否切换(回车默认y):  "
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        case "$sel" in
            y | Y ) echo
                if [ -n "$delayLong" ]; then
                    tput sc
                    for i in $(seq -w $delayLong -1 1) ; do
                        tput rc;tput ed
                        echo -ne "\033[1;31m将在${i}秒后切换分支，ctrl+c 取消\033[0m"
                        sleep 1
                    done
                fi && git checkout "$branchNameTraget"
                break;;
            n | q )  echo
                return;;
            * ) ftEcho -e 错误的选择：$sel
                echo "输入n，q，离开";;
    esac;done
}

complete -W "-h --help --rely_install" ftGitPatch
ftGitPatch()
{
    local ftEffect=git的Patch相关操作的封装
    local isEnable=false

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local isByChange isByHash isApplayPatch isByHashAndMore
    local commitIdNew commitIdOld filePathPatchSource patchNameTarget dirPathPatchTarget
    local valCount=3 errorContent arg arg2 arg3 ;for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#       自动补全方法依赖的工具
#    ftGitPatch -rely_install
#
#       基于修改创建patch包
#    ftGitPatch -c  patch包名
#
#       基于commit_id创建patch
#    ftGitPatch -ch 新hash值 旧hash值 -n patch包名
#
#       基于commit_id创建多patch
#    ftGitPatch -cmh 截止的hash值 patch生成路径
#
#       应用patch
#    ftGitPatch -a patch路径
#
#       cherry-pick patch
#    ftGitPatch -ah hashID
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -n ) patchNameTarget="${arg2}"
          ;;
        -a ) isApplayPatch=true
              filePathPatchSource="${arg2}"
          ;;
        -c ) isByChange=true
              patchNameTarget="${arg2}"
          ;;
        -ch ) isByHash=true
                commitIdNew="${arg2}"
                commitIdOld="${arg3}"
          ;;
        -cmh ) isByHashAndMore=true
                commitIdOld="${arg2}"
                dirPathPatchTarget="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitPatch --rely "git" && return
    #参数校验
    [ -z "$branchNameNow" ] && ftGitPatch --env && return
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitPatch -h && return

    #实现主体
    local dirPathLocal=$(pwd)
    local dirPathGitRoot=$(git rev-parse --show-toplevel)
    [[ ! -d ${dirPathGitRoot} ]] && ftEcho -e "找不到仓库的根目录\\ndirPathGitRoot=$dirPathGitRoot" && return
    cd ${dirPathGitRoot}

    [[ -n "isApplayPatch" ]] && if [[ -f $filePathPatchSource ]]; then
        git am $filePathPatchSource
        return
    # elif [[ -d $filePathPatchSource  ]]; then
    else ftEcho -e "patch添加失败，无效路径：${filePathPatchSource}" && return
    fi

    [[ -n "isByChange" ]] && if [[ -n "${patchNameTarget}" ]]; then
        git diff-tree -r --no-commit-id --name-only ${patchNameTarget} | xargs tar -rf ${patchNameTarget}.tar
        return
    else ftEcho -e "patch生成失败，无效包名：${patchNameTarget}" && return ;fi

    [[ -n "isByHash" ]] && if [[ -n "${commitIdNew}" ]] && [[ -n "${commitIdOld}" ]] && [[ -n "${patchNameTarget}" ]]; then
        git diff ${commitIdNew} ${commitIdOld} --name-only | xargs tar -rf ${patchNameTarget}.tar
        return
    else ftEcho -e "patch生成失败" && return ;fi

    [[ -n "isByHashAndMore" ]] && if [[ -n "${commitIdOld}" ]] && [[ -n "${dirPathPatchTarget}" ]]; then
        git format-patch -s ${commitIdOld} -o ${dirPathPatchTarget}
        return
    else ftEcho -e "patch生成失败" && return ;fi

    cd ${dirPathLocal}
}

complete -W "-h --help --rely_install -f" ftGitTagGrep
ftGitTagGrep()
{
    local ftEffect=GIT的标签内容过滤
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local strKeyContent
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get update
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    在所有标签注释中查找指定字符串
#    ftGitTagGrep -f 查找的字符串
#    可简化 [ftGitTagGrep -f] 为 [xgft] ,其他参数不变
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -f ) strKeyContent="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitTagGrep --rely "git" && return
    #环境校验
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [[ -z "${branchNameNow}" ]] && ftGitTagGrep --env && return
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$strKeyContent" ] && errorContent="${errorContent}\\n[想要的有点多,这个给不了]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagGrep -h && return

    #实现主体
    local tagNameList=$(git tag)
    local dirPathLocal=$(pwd)
    local dirPathTempTag=/tmp/xbashTagContents

    [ -d "$dirPathTempTag" ] && rm -rf $dirPathTempTag
    mkdir $dirPathTempTag
    for tagName in ${tagNameList[*]}; do
        git show -q $tagName > ${dirPathTempTag}/${tagName}
    done
    cd $dirPathTempTag
    find ./ ! -type d -name "*" | xargs grep "${strKeyContent}"
    rm -rf $dirPathTempTag
    cd $dirPathLocal
}

complete -W "-t -h  -a --help --app --modify --branch" ftGitTag
ftGitTag()
{
    local ftEffect=GIT的标签常见操作
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local tagName noteContent commitId isDeleteTag
    local isUseVersionReadMeTemplate isUseModifyReadmeTemplate isUseBranchReadmeTemplate isUseAppReadMeTemplate
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local valCount=1 errorContent arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    添加版本标签 :
#    ftGitTag -a 标签名
#    ftGitTag -a 标签名 对应的commitid
#    可简化 [ftGitTag -a] 为 [xgat] ,其他参数不变
#
#    添加版本标签 [APP项目] :
#    ftGitTag --app 标签名
#    ftGitTag --app 标签名 对应的commitid
#    可简化 [ftGitTag --app] 为 [xgatt] ,其他参数不变
#
#    添加修改说明标签 [修改的详细说明，无模板] :
#    ftGitTag --modify 标签名
#    ftGitTag --modify 标签名 对应的commitid
#    可简化 [ftGitTag --modify] 为 [xgmt] ,其他参数不变
#
#    添加分支说明标签 [分支情况的详细说明，无模板] :
#    ftGitTag --branch 标签名
#    ftGitTag --branch 标签名 对应的commitid
#    可简化 [ftGitTag --branch] 为 [xgbt] ,其他参数不变
#
#    删除标签:
#    ftGitTag -d 标签名
#    可简化 [ftGitTag -d] 为 [xgdt] ,其他参数不变
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            isUseVersionReadMeTemplate=true
            ;;
        --app ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            isUseAppReadMeTemplate=true
            ;;
        --modify ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            (( ${#commitId} > 7 )) && commitId=${commitId:0:7}
            tagName="ModifyDescription_${commitId}"
            isUseModifyReadmeTemplate=true
            ;;
        --branch ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            (( ${#commitId} > 7 )) && commitId=${commitId:0:7}
            tagName="BranchDescription_${tagName}"
            isUseBranchReadmeTemplate=true
            ;;
        -d ) tagName="${arg2}"
              isDeleteTag=true
            ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which git) ]] && ftGitTag --rely "git" && return
    #参数校验
    [ -z "$tagName" ]&&[ -z "${isUseVersionReadMeTemplate}" ] && errorContent="${errorContent}\\n[tagName为空]tagName=$tagName"
    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTag -h && return

    #实现主体
    if [[ -n "$isDeleteTag" ]];then
        # git push origin --delete ${tagName}
        git tag -d $tagName && git push origin :refs/tags/${tagName}
        return
    fi

    local fileNameVersionNote="${tagName}.readme"
    local filePathVersionNote=/tmp/${fileNameVersionNote}
    [ -f "${filePathVersionNote}" ] && rm -rf "${filePathVersionNote}"

    if [ -n "${isUseVersionReadMeTemplate}" ];then
        local key="当前版本："
        ftGitTagCreateVersionTemplateByVersionReadme -t "${filePathVersionNote}"
        if [[ -z ${tagName} ]]; then
            tagName=$(cat $filePathVersionNote |grep ${key})
            tagName=${tagName//$key/}
            tagName=$(echo $tagName |sed s/[[:space:]]//g)
        fi
    fi
    [ -n "${isUseAppReadMeTemplate}" ] && ftGitTagCreateAppReadMeTemplate -v "${tagName}" -f "${filePathVersionNote}"
    [ -n "${isUseBranchReadmeTemplate}" ] && ftGitTagCreateBranchReadMeTemplate -f "${filePathVersionNote}"
    if touch $filePathVersionNote ; then
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathVersionNote
    else
        ftEcho -ex "创建临时说明信息文件失败"
        return;
    fi

    noteContent="$(cat $filePathVersionNote)" ;rm -rf $filePathVersionNote

    if [[ -z "$noteContent" ]];then
        ftEcho -y "空的备注信息，是否使用commit名作为备注信息 (回车默认y)"
        read -n 1 sel ;[ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    noteContent=$(ftGitLogShell -t "%s" -n 1) ; break;;
                n | q )  echo ;
                    return ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
    esac;done ; fi

    [[ -z "$noteContent" ]] && ftEcho -e 标签添加失败,缺少备注 && return
    if ! git tag -a "${tagName}" -m "${noteContent[@]}" "$commitId"; then
        ftEcho -e 标签添加失败 && return
    fi

    ftEcho -y "是否提交(回车默认y)" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y
    [[ "${sel}" != "y" ]] && return
    git push --tag
}

complete -W "-h --help --rely_install" ftGitPushForce_SXTD
ftGitPushForce_SXTD()
{
    local ftEffect=模拟SXTD的git服务器环境下git的push_force功能
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    缺失依赖： ${2}
#    补全依赖： ${3}
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitPushForce_SXTD 无参
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
    --env_warning) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 主分支下无法模拟force
#=========================================================" ;return ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitPushForce_SXTD --rely "git" "ftGitPushForce_SXTD --rely_install" && return
    #解参验耦
    local valCount=0 errorContent
    local branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "${branchNameLocal}" ] && ftGitPushForce_SXTD --env && return
    [[ "${branchNameLocal}" = "master" ]] && ftGitPushForce_SXTD --env_warning && return
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitPushForce_SXTD -h && return

    #实现主体
    git push origin --delete "${branchNameLocal}" \
    && git push origin --set-upstream "${branchNameLocal}" \
    || ftEcho -s "分支[ ${branchNameLocal} ]push force 失败"
}

complete -W "-h --help --rely_install" ftGitSxtdProjectBranchV1
ftGitSxtdProjectBranchV1()
{
    local ftEffect=以目录隔离同平台不同项目的相关实现[sxtd老项目]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get update
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitSxtdProjectBranchV1  #无参数
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 环境未初始化
# 使用前,请先进入AOSP项目
#========================================================="; return ;;
    * ) break;;esac;done

    #环境校验
    if [[ -z "$ANDROID_BUILD_TOP" ]];then
        [[ -d "alps" ]] && [[ -d ".git" ]] && cd alps
        ftAutoInitEnv > /dev/null
    fi
    local dirPathAospRoot=$(dirname $ANDROID_BUILD_TOP)
    [[ ! -d "${dirPathAospRoot}" ]] && ftGitSxtdProjectBranchV1 --env && return
    local dirPathLocal=$(pwd)
    cd "${dirPathAospRoot}"
    #依赖校验
    [[ -z $(which git) ]] && ftGitSxtdProjectBranchV1 --rely "git" && return
    #解参验耦
    local valCount=1 errorContent
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitSxtdProjectBranchV1 -h && return

    #实现主体
    ftEcho -s "开始收集项目状态"
    local hashValBase=$(ftGitLogShell -t "%h" -n 1)
    git reset > /dev/null
    git add -A $(git status --porcelain |grep -v "alps/out" | sed s/??//g\
    | sed -e "s: T ::g"\
    | sed -e "s: M ::g"\
    | sed -e "s: D ::g"\
    |grep "alps/") > /dev/null
    git status --porcelain

    ftEcho -y "请确认待commit修改列表,是否正确(回车默认y)"
    read -n 1 sel ;[ -z "${sel}" ] && sel=y
    while true; do case "$sel" in
            y | Y )
                local tarPackagAutoCreateName=0tempBranch tarPackagAutoCreateNameTemp=temp
                ls | while read line;do
                    [[ ! -d "$line" ]] && continue
                    if [[  ${line//$tarPackagAutoCreateName} != $line ]]; then
                        local dirPath=${line}
                        local dirPath_old=${dirPath}_old
                        [[ -d "$dirPath_old" ]] && dirPath_old=${dirPath_old}_old
                        mv $dirPath $dirPath_old
                    fi
                done

                ftEcho -s "开始添加临时commit"
                git commit -m "temp" > /dev/null
                local hashValTemp=$(ftGitLogShell -t "%h" -n 1)
                git diff $hashValTemp $hashValBase --name-only | xargs tar -rf ${tarPackagAutoCreateName}.tar

                mkdir $tarPackagAutoCreateNameTemp
                tar -xvf ${tarPackagAutoCreateName}.tar -C ${tarPackagAutoCreateNameTemp}

                [[ -z $(ls $tarPackagAutoCreateNameTemp) ]] && ftEcho -e "分支patch包生成失败,请确认是否有除[?/T/M/D]之外修改类型,或检查gitignore配置文件" \
               && rm -rf ${tarPackagAutoCreateNameTemp} ${tarPackagAutoCreateName}.tar && return

                mv ${tarPackagAutoCreateNameTemp}/alps ${tarPackagAutoCreateName}
                rm -rf $tarPackagAutoCreateNameTemp ${tarPackagAutoCreateName}.tar
                ftEcho -s "已生成临时分支: ${tarPackagAutoCreateName}"

                break;;
            n | q )  echo ;
                return ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
    esac;done ;
    git reset $hashValBase > /dev/null #&& ftEcho -s "已删除临时commit"
    cd "${dirPathLocal}"
}

complete -W "-h --help --rely_install -c -r -d" ftGitSxtdProjectBranchV2
ftGitSxtdProjectBranchV2()
{
    local ftEffect=以分支隔离同平台不同项目的相关实现[sxtd新项目]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local isCreateBranch isReName isDelete
    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftGitSxtdProjectBranchV2 --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#   ftGitSxtdProjectBranchV2 -c   #创建分支
#   ftGitSxtdProjectBranchV2 -r   #重命名分支
#   ftGitSxtdProjectBranchV2 -d   #删除分支
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -c )  isCreateBranch=true
            ;;
        -r )  isReName=true
            ;;
        -d )  isDelete=true
            ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitSxtdProjectBranchV2 --rely "git" && return
    #环境校验
    local branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "${branchNameLocal}" ] && ftGitSxtdProjectBranchV2 --env && return
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitSxtdProjectBranchV2 -h && return

    local mFilePathSxtdProjectBranchV2="${dirPathHome}/.cache/projectDescriptionTemp.ini"
    local mBranchList=(
        $(git branch -a|grep -v "* ${branchNameLocal}" |grep -v "remotes/origin") \
        $(git branch -a |grep "remotes/origin"|grep -v "remotes/origin/HEAD -> " | sed -e "s:remotes/origin/::g" ) \
        ${branchNameLocal})
    mBranchList=($(echo "${mBranchList[@]}"  | sed 's/ /\n/g' |sort |uniq)) #去重

    if [[ $isReName = "true" ]]; then
        local TagName="分支信息描述" mKeyIniBranchNameBase="原分支名" mKeyIniBranchNameNew="新分支名"

        echo -e "#ini\n" > $mFilePathSxtdProjectBranchV2
        echo "[分支列表,仅用于复制]" >> $mFilePathSxtdProjectBranchV2
        for index in "${!mBranchList[@]}"; do echo "${mBranchList[$index]}" >> $mFilePathSxtdProjectBranchV2 ;done
        ftIniCreateFileOrTag  -a -p $mFilePathSxtdProjectBranchV2 -t $TagName -l "${mKeyIniBranchNameBase}= ${mKeyIniBranchNameNew}= "

        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2
        local mBranchNameBase=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameBase)
                mBranchNameNew=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameNew)
        [ -z "${mBranchNameBase}" ] && ftEcho -e "缺失原分支名,请确认是否输入" && return
        [ -z "${mBranchNameNew}" ] && ftEcho -e "缺失新分支名,请确认是否输入" && return

        git branch -m "${mBranchNameBase}" "${mBranchNameNew}" || return
        ftEcho -s "${mBranchNameBase} \n本地修改为 \n${mBranchNameNew}"

        ftEcho -y "是否同时重命名服务器分支(回车默认y)"
        read -n 1 sel ; [ -z "${sel}" ] && sel=y ; while true; do case "$sel" in
            y | Y )
                git push origin --delete "${mBranchNameBase}" && git push origin "${mBranchNameNew}" || ftEcho -e "远程操作失败"
                break;;
            n | q ) exit ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
        esac;done

        rm $mFilePathSxtdProjectBranchV2
        return
    fi

    if [[ $isDelete = "true" ]]; then
        local TagName="分支信息描述" mKeyIniBranchNameDelete="待删除分支名"

        echo -e "#ini\n" > $mFilePathSxtdProjectBranchV2
        echo "[分支列表,仅用于复制]" >> $mFilePathSxtdProjectBranchV2
        for index in "${!mBranchList[@]}"; do echo "${mBranchList[$index]}" >> $mFilePathSxtdProjectBranchV2 ;done
        ftIniCreateFileOrTag  -a -p $mFilePathSxtdProjectBranchV2 -t $TagName -l "${mKeyIniBranchNameDelete}= "

        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2 > /dev/null
        local mBranchNameDelete=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameDelete)
        [ -z "${mBranchNameDelete}" ] && ftEcho -e "缺失待删除分支名,请确认是否输入" && return

        git branch -D "${mBranchNameDelete}" || return

        ftEcho -y "是否同时删除对应服务器分支(回车默认y)"
        read -n 1 sel ; [ -z "${sel}" ] && sel=y ; while true; do case "$sel" in
            y | Y )
                git push origin --delete "${mBranchNameDelete}"|| ftEcho -e "远程操作失败"
                break;;
            n | q ) exit ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
        esac;done

        rm $mFilePathSxtdProjectBranchV2
        return
    fi

    if [[ $isCreateBranch = "true" ]]; then
        local TagName="项目描述" mKeyIniClientName="客户名"  mKeyIniProjrctName="项目名"  mKeyIniMotherBoardName="主板名"  mKeyIniDemandSignName="项目的其他特性描述"
        local mKeyBranchClientName="CT" mKeyBranchProjrctName="PJ" mKeyBranchMotherBoardName="MBML" mKeyBranchDemandSignName="DM"

        ftIniCreateFileOrTag  -r -p $mFilePathSxtdProjectBranchV2 -t $TagName -l \
        "${mKeyIniMotherBoardName}= \
        ${mKeyIniProjrctName}= \
        #客户名请使用全拼和驼峰命名法 \
        ${mKeyIniClientName}= \
        #不同特性之间用下划线分割 \
        ${mKeyIniDemandSignName}="
        [[ ! -f "$mFilePathSxtdProjectBranchV2" ]] && ftEcho -e "${TagName}文件创建失败" && return
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2

        local mMotherBoardName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniMotherBoardName) \
                mProjrctName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniProjrctName) \
                mClientName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniClientName) \
                mDemandSignName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniDemandSignName)
        [[ -z "$mMotherBoardName" ]] && ftEcho -e "缺失项目主板名信息,请确认是否输入" && return
        [[ -z "$mProjrctName" ]] && ftEcho -e "缺失项目名信息,请确认是否输入" && return
        [[ -z "$mClientName" ]] && ftEcho -e "缺失项目客户名信息,请确认是否输入" && return
        mDemandSignName=${mDemandSignName:-'ZhongXing'}
        local mBranchName="${mKeyBranchMotherBoardName}(${mMotherBoardName})"
        mBranchName="${mBranchName}_${mKeyBranchProjrctName}(${mProjrctName})"
        mBranchName="${mBranchName}_${mKeyBranchClientName}(${mClientName})"
        mBranchName="${mBranchName}_${mKeyBranchDemandSignName}(${mDemandSignName})"

        for branch in ${mBranchList[@]}; do [[ "$branch" = "$mBranchName" ]] && ftEcho -s "分支[${mBranchName}]已存在"&& return ; done
        git branch "${mBranchName}" && ftEcho -s "分支[${mBranchName}]创建成功"
        rm $mFilePathSxtdProjectBranchV2
        return
    fi
}

complete -W "-h --help -a -v" ftGitCreateAppVersionReadMeBySoftwareVersion
ftGitCreateAppVersionReadMeBySoftwareVersion()
{
    local ftEffect=创建APP软件版本说明模板并添加为Git的TAG
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local versionName isAutoAddTag
    filePathChangeListTemplate=/tmp/版本说明.txt
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitCreateAppVersionReadMeBySoftwareVersion -a -v 版本号
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos # sudo apt-get install tofrodos
#========================================================="; return ;;
        # 变量参数解析部分==============
        -v )   versionName="$arg2" ;;
        -a )   isAutoAddTAg="true" ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #环境校验
    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftGitCreateAppVersionReadMeBySoftwareVersion --rely && return
    local filePathConfig=$rFilePathXbashDBUser

    #实现主体
    #使用git仓库相关记录
    local gitCommitList commitId
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    rm -rf $filePathChangeListTemplate

    #版本说明
    local enterLine="\n"
    local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
    content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
    content=${content}${enterLine}
    content=${content}${enterLine}"当前版本：$versionName"
    content=${content}${enterLine}"基础版本："
    if [[ -n "${branchNameNow}" ]]; then
        gitCommitList=$(ftGitLogShell -nn 10)
        commitId=$(ftGitLogShell -t "%h" -n 1)
        content=${content}${enterLine}"版本CommitHash：${commitId} "
        content=${content}${enterLine}"分支名：${branchNameNow}"
        if [[ "${branchNameNow}" != "master" ]]; then
            content=${content}${enterLine}"父分支名："
        fi
    else
        content=${content}${enterLine}"分支名："
    fi
    content=${content}${enterLine}"客户名："
    content=${content}${enterLine}
    content=${content}${enterLine}"说明："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}
    content=${content}${enterLine}"修改记录："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}
    #git log 列表
    [[ -n "${gitCommitList}" ]] && echo -e "﻿$gitCommitList">$filePathChangeListTemplate
    seq 10 | awk '{printf("    %02d %s\n", NR, $0)}' $filePathChangeListTemplate >${filePathChangeListTemplate}.temp
    # 合并头部和git log 列表
     if [[ -n "${branchNameNow}" ]]; then
        echo -e ${content}${enterLine}${enterLine}"git commit 记录："| cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathChangeListTemplate
        if [[ -n "${isAutoAddTag}" ]]; then
            local noteContent="$(cat $filePathChangeListTemplate)" ;rm -rf $filePathChangeListTemplate
            git tag -a "$versionName" -m "${noteContent[@]}" "$commitId"
        fi
    else
        echo -e ${content} | cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathVersionNote
    fi
    rm ${filePathChangeListTemplate}.temp
}

complete -W "-h --help -f -v" ftGitTagCreateAppReadMeTemplate
ftGitTagCreateAppReadMeTemplate()
{
    local ftEffect=GIT的标签模板[APP版本说明]
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local filePathConfig=$rFilePathXbashDBUser
    local filePathAppReadMe versionName
    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitTagCreateAppReadMeTemplate -f 模板文件路径 -v 版本号
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -f ) filePathAppReadMe="${arg2}"
            filePathAppReadMe=$(ftPath $filePathAppReadMe)
            ;;
        -v ) versionName="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftGitTagCreateAppReadMeTemplate --rely && return
    [ ! -f "$filePathConfig" ] && errorContent="${errorContent}\\n[配置文件不存在]filePathConfig=$filePathConfig"
    [ -z "$filePathAppReadMe" ] && errorContent="${errorContent}\\n[模板路径为空]filePathAppReadMe=$filePathAppReadMe"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateAppReadMeTemplate -h && return

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    #版本说明
    local enterLine="\n"
    local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
    content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
    content=${content}${enterLine}
    content=${content}${enterLine}"硬件项目平台："
    content=${content}${enterLine}"当前版本：$versionName"
    content=${content}${enterLine}"基础版本："
    content=${content}${enterLine}"客户名："
    content=${content}${enterLine}"说明："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}
    content=${content}${enterLine}"修改记录："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}

    echo -e ${content}${enterLine}${enterLine} >$filePathAppReadMe

    # 转化为windows下面文件格式
    unix2dos $filePathAppReadMe
}

complete -W "-h --help -f  " ftGitTagCreateBranchReadMeTemplate
ftGitTagCreateBranchReadMeTemplate()
{
    local ftEffect=GIT的标签模板[分支创建说明]
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local filePathAppReadMe filePathConfig=$rFilePathXbashDBUser
    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitTagCreateBranchReadMeTemplate -f 模板文件路径
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -f ) filePathAppReadMe="${arg2}"
            filePathAppReadMe=$(ftPath $filePathAppReadMe)
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftGitTagCreateBranchReadMeTemplate --rely && return
    [ ! -f "$filePathConfig" ] && errorContent="${errorContent}\\n[配置文件不存在]filePathConfig=$filePathConfig"
    [ -z "$filePathAppReadMe" ] && errorContent="${errorContent}\\n[模板路径为空]filePathAppReadMe=$filePathAppReadMe"
    [[ -n "$errorContent" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateBranchReadMeTemplate -h && return

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    #版本说明
    local enterLine="\n"
    local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
    content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
    content=${content}${enterLine}
    content=${content}${enterLine}"硬件项目平台："
    if [[ -n "${branchNameNow}" ]]; then
        content=${content}${enterLine}"版本CommitHash：$(ftGitLogShell -n 1 -c "%h") "
        content=${content}${enterLine}"分支名[真实]：${branchNameNow}"
        if [[ "${branchNameNow}" != "master" ]]; then
            content=${content}${enterLine}"父分支名[真实]："
        fi
    else
        content=${content}${enterLine}"分支名："
    fi
    content=${content}${enterLine}"分支变更原因说明："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}

    echo -e ${content}${enterLine}${enterLine} >$filePathAppReadMe

    # 转化为windows下面文件格式
    unix2dos $filePathAppReadMe
}

complete -W "-h --help -f -t " ftGitTagCreateVersionTemplateByVersionReadme
ftGitTagCreateVersionTemplateByVersionReadme()
{
    local ftEffect=GIT的标签模板[版本说明]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local filePathReadme
    local valCount=4 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftGitTagCreateVersionTemplateByVersionReadme -t git标签用的模板存放路径
#    ftGitTagCreateVersionTemplateByVersionReadme -f 版本说明路径 -t git标签用的模板存放路径
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
#    环境未初始化
#    使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -f ) filePathReadme="${arg2}"
            ;;
        -t ) filePathReadmeTarget="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${filePathReadmeTarget}" ] && errorContent="${errorContent}\\n[模板存放路径为空]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateVersionTemplateByVersionReadme -h && return

    #实现主体
    if [[ -z $filePathReadme ]] || [[ ! -f $filePathReadme ]]; then
        [[ ! -d out ]] && [ -n "$ANDROID_BUILD_TOP" ] && cd "${ANDROID_BUILD_TOP}"
        [[ ! -d out ]] && ftEcho -s "未找到有效版本说明" && ftGitTagCreateVersionTemplateByVersionReadme -h && return
        filePathReadme=$(find out/packet -name 版本说明.txt)
    fi

    cp "${filePathReadme}" "${filePathReadmeTarget}"
    filePathReadme=$filePathReadmeTarget

    #删除 标题头
    sed -i '1d' $filePathReadme

    #删除 git commit list
    local lineCount=$(awk 'END{print NR}' $filePathReadme)
    local lineNumIndex=$(awk '/git commit 记录：/{print NR}' $filePathReadme)
    ((lineCount=lineCount-lineNumIndex+1))
    for (( i = 1; i <= lineCount; i++ )); do
        sed -i '$d' $filePathReadme
    done
}