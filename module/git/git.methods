#!/bin/bash
#  git常用功能的封装
ftSetBashPs1ByGitBranch()
{
    local ftEffect=根据git分支名,设定bash的PS1
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    [[ "$isUseCustomPS1" != "true" ]] && return

    local editType=$1 defaultPrefix=${rUserName:-'xbash'} defaultColorConfig=44
    [[ "$(whoami)" = "root" ]] && defaultPrefix="root" && defaultColorConfig=42
    export PS1="$defaultPrefix[\[\033[${defaultColorConfig}m\]\w\[\033[0m\]]: "

    [[ -z $(which git) ]] && return $resultFail

    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local branchNameAll
    if [ -n "$branchName" ] && [ "$editType" != "-b" ];then
        local ps1=$(pwd)${branchName}
        branchNameAll="branchName→ ${branchName}: "
        [[ -n "${COLUMNS}" ]] && (( ${#ps1}>$COLUMNS/2-11 )) && branchNameAll="\nbranchName→ ${branchName}: "
        export PS1="$defaultPrefix[\[\033[${defaultColorConfig}m\]\w\[\033[0m\]]\[\033[33m\]${branchNameAll}\[\033[0m\]"
    fi
}

ftGitLogShell()
{
    local ftEffect=git的log特定格式显示
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local branchLogItemCountDef=20
    local isAllBranchLogByGitK isAllBranchLog isAllBranchTree isTagBranchLog branchLogFormat isCustomBranchLog isFindString
    local branchLogItemCount=${branchLogItemCountDef} pathTarget findStringContent pathCommand
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
     --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包
#    请尝试使用 sudo apt-get install git git-core git-gui git-doc 补全依赖
#=========================================================" ;return ;;
     --env) ftEcho -rc "${ftEffect}" "的环境说明" "\
#=========================================================
#    当前目录没有有效的GIT仓库
#=========================================================" ;return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    全部分支log
#    ftGitLogShell -a
#    ftGitLogShell -a 目录/文件
#
#    分支树
#    ftGitLogShell -b
#    可简化 [ftGitLogShell -b] 为 [xglb] ,其他参数不变
#
#    查看分支树
#    ftGitLogShell -at
#
#    用gitk查看指定路径下的全部分支log
#    ftGitLogShell -aw  路径
#
#    用git指定路径下的全部分支log
#    ftGitLogShell -a  路径
#
#    过滤修改内容包含字符串的log
#    ftGitLogShell -fs \"字符串\"
#    可简化 [ftGitLogShell -fs] 为 [xglf] ,其他参数不变
#
#    指定log数量
#    ftGitLogShell -n 数量
#
#    不高亮显示
#    ftGitLogShell -nn 数量
#
#    只输出包含tag的git log
#    ftGitLogShell -t Tag名
#
#    自定义格式输出
#    ftGitLogShell -c \"格式字串\"
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a )  isAllBranchLog=true
                pathTarget="${arg2}"
                ;;
        -aw )  isAllBranchLogByGitK=true
                pathTarget="${arg2}"
                branchLogItemCount=0
                ;;
        -b )  isAllBranchTree=true
                branchLogItemCount=0
                ;;
        -t )   branchLogFormat=${arg2:-'%s'}
                isTagBranchLog=true
                ;;
        -c )   branchLogFormat=${arg2}
                isCustomBranchLog=true
                ;;
        -n )  branchLogItemCount=${arg2:-'$branchLogItemCountDef'}
                (( $#==3 ))&&(echo -n $3 | grep -q -e "^[0-9][0-9]*$")&&(($3>$branchLogItemCount)) && branchLogItemCount=$3
                ;;
        -nn )  branchLogItemCount=${arg2:-'$branchLogItemCountDef'}
                (( $#==3 ))&&(echo -n $3 | grep -q -e "^[0-9][0-9]*$")&&(($3>$branchLogItemCount)) && branchLogItemCount=$3
                branchLogFormat="%<(21 ,trunc)%ai  %<(10,trunc)%an %h %s  %d"
                ;;
        -fs )  findStringContent=${arg2}
                isFindString=true
                ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [[ -z $(which git) ]] && ftGitLogShell --rely && return $resultFail
    [[ -n "$isAllBranchLogByGitK" ]] && [ -z $(which gitk) ] && ftGitLogShell --rely && return $resultFail
    [[ -z $(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/') ]] && ftGitLogShell --env && return $resultFail
    [ -z "$branchLogItemCount" ]||(($branchLogItemCount<0)) && errorContent="${errorContent}\\n log显示数量未指定"
    [ -n "$isFindString" ] && [ -z "${findStringContent}" ] && errorContent="${errorContent}\\n 查找的字符串未制定"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitLogShell -h && return $resultFail

    #实现主体
    local gitVersionMin="2.6.0" gitVersionNow=$(git --version)
    gitVersionNow=${gitVersionNow//git version/}
    gitVersionNow=$(echo $gitVersionNow |sed s/[[:space:]]//g)

    [[ -n "$isAllBranchLogByGitK" ]] && gitk --all "${pathTarget}" && return $resultSuccess
    [[ -n "$isAllBranchTree" ]] && gitk --simplify-by-decoration --all && return $resultSuccess
    [[ -n "$isTagBranchLog" ]] && git log --date=short --pretty=format:"$branchLogFormat" -$branchLogItemCount && return $resultSuccess
    [[ -n "$isAllBranchLog" ]] && pathCommand="-- $pathTarget"

    if [[ $(ftVersionComparison $gitVersionMin $gitVersionNow) = "<" ]] && [ "$isCustomBranchLog" != "true" ];then
        branchLogFormat=${branchLogFormat:-'%C(green)%<(11,trunc)%ad %Cred%<(11,trunc)%an%Creset %Cblue%<(11,trunc)%h%Creset %s %C(yellow) %d'}
        if [[ -n "$isFindString" ]]; then
            git --no-pager log --date=format-local:'%y-%m-%d' --pretty=format:"$branchLogFormat" -$branchLogItemCount -S"${findStringContent}" ${pathCommand}
            echo ; return $resultSuccess
        fi
        git --no-pager log --date=format-local:'%Y-%m-%d' --pretty=format:"$branchLogFormat" -$branchLogItemCount ${pathCommand}
        echo ;return $resultSuccess
    fi
    if [ "${branchLogFormat}" = "%h" ];then
        hashVal=($(git log --pretty=format:"$branchLogFormat" -$branchLogItemCount  ${pathCommand}))
        echo "${hashVal[@]} "
        echo ;return $resultSuccess
    fi
    branchLogFormat=${branchLogFormat:-'%C(green)%<(21,trunc)%ai%x08%x08%Creset %Cred%<(13,trunc)%an%Creset %Cblue%<(9,trunc)%h%Creset %s %C(yellow) %d'}
        if [[ -n "$isFindString" ]]; then
            git --no-pager log --pretty=format:"$branchLogFormat" -$branchLogItemCount -S"${findStringContent}" ${pathCommand}
            echo ; return $resultSuccess
        fi
    git --no-pager log --pretty=format:"$branchLogFormat" -$branchLogItemCount ${pathCommand}
    echo
}

complete -W "-h --help -a -s" ftGitPatchAdd2Branches
ftGitPatchAdd2Branches()
{
    local ftEffect=快速添加git的Patch补丁[跨分支]
    local isEnable=true

    local branchTag isAutoPush isAutoSyncDef=true isAutoSync=true
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftGitPatchAdd2Branches 无参
#
#    #只操作名称中有TAG的分支
#    ftGitPatchAdd2Branches -t 分支TAG
#
#    #添加的补丁自动提交
#    ftGitPatchAdd2Branches -a
#
#    #开始添加的补丁之前,当前分支不进行远程分支同步
#    ftGitPatchAdd2Branches -ns
#
#    #开始添加的补丁之前,初始分支不进行远程分支同步
#    ftGitPatchAdd2Branches -nsd
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -t )  branchTag="${arg2}"
                ;;
        -a )  isAutoPush=true
                ;;
        -ns )  isAutoSync=
                ;;
        -nsd )  isAutoSyncDef=
                ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "$branchNameNow" ] && ftGitPatchAdd2Branches --env && return $resultFail
    local filePathBranchList=待打补丁的分支列表 filePathCommitList="patch的hash值列表[会自动倒序,请按新旧正序填写]"
    local filePathAddPatchTool=$rFilePathXbashModuleGitAddPatchToolExample
    local filePathFailInfo="/home/wgx/.cache/ftGitPatchAdd2Branches.log" ; [ -f "$filePathFailInfo" ] && rm $filePathFailInfo
    [[ ! -f $filePathAddPatchTool  ]] && ftEcho -e "诶，帮忙看看[${filePathAddPatchTool}]在不在" && return $resultFail
    [ ! -f "$filePathAddPatchTool" ] && [ -f "${filePathAddPatchTool}.example" ] &&\
        ftEcho -e "请参考${filePathAddPatchTool}.example在同目录下新建multiBranch.module" && return $resultFail

    #实现主体
    if [[ -n $isAutoSyncDef ]]; then
        ftEcho -s "正同步当前分支,请稍等..."
        git pull --rebase && git push
    fi

    local branchList=($(git branch | sed -e "s:*::g" | grep -v "${branchNameNow}"))
    local branchListLocal=($(git branch | sed -e "s:*::g"))
    local banchApplayPatchFailList banchSyncCancelList banchSyncFailList

    local key="remotes/origin/"
    local branchListServer=($(git branch -a|grep -i "$branchNameTag" \
                                                                     | grep -v "remotes/origin/HEAD -> origin/master" \
                                                                     | grep "$key" \
                                                                     | sed -e "s:*::g" \
                                                                     | grep -v "${branchNameNow}"))
    for (( i = 0; i < ${#branchListServer[@]}; i++ )); do branchListServer[$i]=${branchListServer[$i]##*$key} ; done
    branchList=(${branchList[@]} ${branchListServer[@]}) #合并本地和仓库分支
    branchList=($(echo ${branchList[@]} | sed 's/ /\n/g'|sort |uniq)) #去重

    if [ -n "${branchTag}" ];then echo ${branchList[@]} |grep ${branchTag} | sed 's/ /\n/g' > $filePathBranchList
    else echo ${branchList[@]} | sed 's/ /\n/g' > $filePathBranchList ;fi
    XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathBranchList $filePathCommitList
    branchList=($(cat $filePathBranchList)) hashList=($(cat $filePathCommitList)) 
    rm -f $filePathBranchList $filePathCommitList
     [ -z "$branchList" ] && ftEcho -e "${filePathBranchList} 为空" && return $resultFail
     [ -z "$hashList" ] && ftEcho -e "${filePathCommitList} 为空" && return $resultFail

    for branchName in ${branchList[@]} ; do
        echo;ftEcho -s "================  切换到分支: ${branchName} ====================="

        if [[ ! "${branchListLocal[@]}" =~ "${branchName}" ]]; then
            ftEcho -y "此分支为远程分支，是否继续(回车默认y)" && read -n 1 sel && echo
            [ -z "${sel}" ] && sel=y; [[ "$sel" != "y" ]] && continue
        fi

        git checkout "$branchName"||return $resultFail
        [ -n "$isAutoSync" ] && ftEcho -s "添加补丁前同步当前分支,请稍等..." && git pull --rebase && git push

        #添加多个commit
        i=${#hashList[@]}
        local isApplyFail patchId commitIdNewestOld=$(ftGitLogShell  -n 1 -c "%h")
        while (( $i>0 ));do
            (( i-=1 ))
            patchId=${hashList[$i]}
            ftEcho -s "添加补丁 : ${patchId}"
            if ! git cherry-pick $patchId ;then
                ftEcho -e "补丁：${patchId}，添加失败"
                isApplyFail=true
                banchApplayPatchFailList=(${banchApplayPatchFailList[@]} ${branchName})
                git reset --hard
                break
            fi
        done

        #同步到远程分支
        local commitIdNewestNow=$(ftGitLogShell  -n 1 -c "%h")
        if [[ -z "$isApplyFail" ]] || [[ ${commitIdNewestOld} != ${commitIdNewestNow} ]]; then
            echo && ftEcho -s "更新后的 commit list :"
            ftGitLogShell -n 20

            [ -z "${isAutoPush}" ] && ftEcho -y "当前分支已添加新补丁,是否同步到远程分支 [回车同步]" && read -n 1 sel && [ -z "${sel}" ] && sel=y
            if [ -n "${isAutoPush}" ] || [[ "${sel}" = "y" ]]; then
                ftEcho -s "正在同步,请稍等..." 
                if ! git push; then
                    ftEcho -e "分支${branchName} : 同步失败"
                    banchSyncFailList=(${banchSyncFailList[@]} ${branchName})
                fi
            else
                echo && ftEcho -s "已放弃同步"
                banchSyncCancelList=(${banchSyncCancelList[@]} ${branchName})
            fi
            sel=
        fi
    done

    #异常信息汇总
    if [ -n "${banchApplayPatchFailList}" ] \
        || [ -n "${banchSyncCancelList}" ] \
        || [ -n "${banchSyncFailList}" ]; then
        ftEcho -s "操作结果说明:"
    fi

    [ -n "${banchApplayPatchFailList}" ] && echo && ftEcho -e "下面分支添加补丁没有成功：" &&
    for branchName in ${banchApplayPatchFailList[@]} ; do
        echo ${branchName}
    done && echo

    [ -n "${banchSyncCancelList}" ] && echo && ftEcho -e "下面分支没有同步：" &&
    for branchName in ${banchSyncCancelList[@]} ; do
        echo ${branchName}
    done && echo

    [ -n "${banchSyncFailList}" ] && echo && ftEcho -e "下面分支同步失败：" &&
    for branchName in ${banchSyncFailList[@]} ; do
        echo ${branchName}
    done && echo

    #回到初始点
    echo && ftEcho -s "开始切换初始分支：${branchNameNow}"
    git checkout "${branchNameNow}"
}

ftGitSelectBranch()
{
    local ftEffect=快速选择分支
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local delayLong isAllBranchs branchNameTag
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#==========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    在本地仓库中查切分支
#    ftGitSelectBranch
#
#    在本地仓库中查切含 xxxx 的分支
#    ftGitSelectBranch -t xxxx
#
#    在本地+远程仓库中查切含 xxxx 的分支
#    ftGitSelectBranch -a -t xxxx
#=========================================================" ;return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a ) isAllBranchs=true ;;
        -t ) branchNameTag="${arg2}" ;;
        -d ) delayLong="${arg2}" ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    if [[ -z "$branchNameTag" ]]; then
        git branch
        return $resultFail
    fi
    #依赖校验
    [[ -z $(which git) ]] && ftGitSelectBranch --rely "git" && return $resultFail
    #参数校验
    [ -z "$branchNameTag" ] && errorContent="${errorContent}\\n[分支TAg为空]branchNameTag=$branchNameTag"
    [ -n "$delayLong" ] && ( ! echo -n $delayLong | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[延时设定错误]delayLong=$delayLong"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitSelectBranch -h && return $resultFail

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local branchList=($(git branch|grep -i "$branchNameTag" | sed -e "s:*::g"))
    for (( i = 0; i < ${#branchList[*]}; i++ )); do [[ "${branchList[$i]}" = "${branchNameNow}" ]] && unset branchList[$i] && break ;done

    if [[ -n "$isAllBranchs" ]];then
        local key="remotes/origin/"
        local branchListServer=($(git branch -a|grep -i "$branchNameTag" \
                                                                         |grep -v "remotes/origin/HEAD -> origin/master" \
                                                                         |grep "$key" \
                                                                         | sed -e "s:*::g"))
        for (( i = 0; i < ${#branchListServer[*]}; i++ )); do [[ "${branchListServer[$i]}" = "${branchNameNow}" ]] && \
        unset branchListServer[$i] && break ;done

        for (( i = 0; i < ${#branchListServer[@]}; i++ )); do branchListServer[$i]=${branchListServer[$i]##*$key} ; done
        branchList=(${branchList[@]} ${branchListServer[@]}) #合并本地和仓库分支
        branchList=($(echo ${branchList[@]} | sed 's/ /\n/g'|sort |uniq)) #去重
    fi

    if [[ -z "${branchList[@]}" ]];then
       [[ -n $(echo $branchNameNow |grep -i "${branchNameTag}") ]] && ftEcho -s "只有当前分支包含TAG，无需切换" && return
       ftEcho -e "未找到[$branchNameTag]对应的分支" && return $resultFail
    fi
    local itemCount=${#branchList[@]}
    for item in ${branchList[@]} ; do [ -n "$item" ] && branchNameTraget=$item && break ;done
    if (( $itemCount>1 ));then
        local index=0 indexNow=-1
        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        branchNameTag=${branchNameTag^^}
        for item in $(git branch|grep -i "$branchNameTag" ) ; do
            [[  ! ${item^^} =~ "$branchNameTag"  ]] && indexNow=$((index)) && break
            ((index+=1))
        done ; index=0
        for item in ${branchList[@]} ; do
            echo -n "[" ; ftEcho -sn "$(printf "%${length}d" $index)" ; echo -n "]"  ; printf "   %-4s\n" $item
            if (( $index == $indexNow-1 )) || (( $index == $itemCount-1 && $indexNow!=-1 ));then
                    ftEcho -sn "$(printf "%${length}s" "-" | sed -e "s: :-:g")" && ftEcho -sn "->" && ftEcho -s "$(printf "   %-4s\n" $branchNameNow)"
                    indexNow=-1
            fi
            ((index+=1))
        done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex && echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
        index=0;for item in ${branchList[@]} ; do
            [ -z "$item" ] && continue
            (( $index == $tIndex )) && branchNameTraget=$item && break
            ((index+=1))
        done
    fi

    echo -n "目标分支: ";ftEcho -sn "${branchNameTraget}"
    export GitEnv_BranchNameTraget="${branchNameTraget}"
}

ftGitCheckoutBranch()
{
    local ftEffect=快速切换分支
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local delayLong isAllBranchs branchNameTag
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#==========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    在本地仓库中查切分支
#    ftGitCheckoutBranch
#
#    在本地仓库中查切含 xxxx 的分支
#    ftGitCheckoutBranch -t xxxx
#
#    在本地+远程仓库中查切含 xxxx 的分支
#    ftGitCheckoutBranch -a -t xxxx
#
#    在本地仓库中查切含 xxxx 的分支,延时yyyy秒后切换
#    ftGitCheckoutBranch -t xxxx -d yyyy
#=========================================================" ;return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a ) isAllBranchs=true ;;
        -t ) branchNameTag="${arg2}" ;;
        -d ) delayLong="${arg2}" ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    if [[ -z "$branchNameTag" ]]; then
        git branch
        return $resultFail
    fi
    #依赖校验
    [[ -z $(which git) ]] && ftGitCheckoutBranch --rely "git" && return $resultFail
    #参数校验
    [ -z "$branchNameTag" ] && errorContent="${errorContent}\\n[分支TAg为空]branchNameTag=$branchNameTag"
    [ -n "$delayLong" ] && ( ! echo -n $delayLong | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[延时设定错误]delayLong=$delayLong"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitCheckoutBranch -h && return $resultFail

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local branchList=($(git branch|grep -i "$branchNameTag" | sed -e "s:*::g"))
    for (( i = 0; i < ${#branchList[*]}; i++ )); do [[ "${branchList[$i]}" = "${branchNameNow}" ]] && unset branchList[$i] && break ;done

    if [[ -n "$isAllBranchs" ]];then
        local key="remotes/origin/"
        local branchListServer=($(git branch -a|grep -i "$branchNameTag" \
                                                                         |grep -v "remotes/origin/HEAD -> origin/master" \
                                                                         |grep "$key" \
                                                                         | sed -e "s:*::g"))
        for (( i = 0; i < ${#branchListServer[*]}; i++ )); do [[ "${branchListServer[$i]}" = "${branchNameNow}" ]] && \
        unset branchListServer[$i] && break ;done

        for (( i = 0; i < ${#branchListServer[@]}; i++ )); do branchListServer[$i]=${branchListServer[$i]##*$key} ; done
        branchList=(${branchList[@]} ${branchListServer[@]}) #合并本地和仓库分支
        branchList=($(echo ${branchList[@]} | sed 's/ /\n/g'|sort |uniq)) #去重
    fi

    if [[ -z "${branchList[@]}" ]];then
       [[ -n $(echo $branchNameNow |grep -i "${branchNameTag}") ]] && ftEcho -s "只有当前分支包含TAG，无需切换" && return
       ftEcho -e "未找到[$branchNameTag]对应的分支" && return $resultFail
    fi
    local itemCount=${#branchList[@]}
    for item in ${branchList[@]} ; do [ -n "$item" ] && branchNameTraget=$item && break ;done
    if (( $itemCount>1 ));then
        local index=0 indexNow=-1
        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        branchNameTag=${branchNameTag^^}
        for item in $(git branch|grep -i "$branchNameTag" ) ; do
            [[  ! ${item^^} =~ "$branchNameTag"  ]] && indexNow=$((index)) && break
            ((index+=1))
        done ; index=0
        for item in ${branchList[@]} ; do
            echo -n "[" ; ftEcho -sn "$(printf "%${length}d" $index)" ; echo -n "]"  ; printf "   %-4s\n" $item
            if (( $index == $indexNow-1 )) || (( $index == $itemCount-1 && $indexNow!=-1 ));then
                    ftEcho -sn "$(printf "%${length}s" "-" | sed -e "s: :-:g")" && ftEcho -sn "->" && ftEcho -s "$(printf "   %-4s\n" $branchNameNow)"
                    indexNow=-1
            fi
            ((index+=1))
        done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex && echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
        index=0;for item in ${branchList[@]} ; do
            [ -z "$item" ] && continue
            (( $index == $tIndex )) && branchNameTraget=$item && break
            ((index+=1))
        done
    fi

    while true; do
        echo -n "目标分支: ";ftEcho -sn "${branchNameTraget}  "
        ftEcho -y "是否切换(回车默认y):  "
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        case "$sel" in
            y | Y ) echo
                if [ -n "$delayLong" ]; then
                    tput sc
                    for i in $(seq -w $delayLong -1 1) ; do
                        tput rc;tput ed
                        echo -ne "\033[1;31m将在${i}秒后切换分支，ctrl+c 取消\033[0m"
                        sleep 1
                    done
                fi
                git checkout "$branchNameTraget"
                break;;
            n | q )  echo
                return;;
            * ) ftEcho -e 错误的选择：$sel
                echo "输入n，q，离开";;
    esac;done
}

complete -W "-h --help --rely_install" ftGitPatch
ftGitPatch()
{
    local ftEffect=git的Patch相关操作的封装
    local isEnable=false

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local isByChange isByHash isApplayPatch isByHashAndMore
    local commitIdNew commitIdOld filePathPatchSource patchNameTarget dirPathPatchTarget
    local valCount=3 errorContent arg arg2 arg3 ;for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#       自动补全方法依赖的工具
#    ftGitPatch -rely_install
#
#       基于修改创建patch包
#    ftGitPatch -c  patch包名
#
#       基于commit_id创建patch
#    ftGitPatch -ch 新hash值 旧hash值 -n patch包名
#
#       基于commit_id创建多patch
#    ftGitPatch -cmh 截止的hash值 patch生成路径
#
#       应用patch
#    ftGitPatch -a patch路径
#
#       cherry-pick patch
#    ftGitPatch -ah hashID
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -n ) patchNameTarget="${arg2}"
          ;;
        -a ) isApplayPatch=true
              filePathPatchSource="${arg2}"
          ;;
        -c ) isByChange=true
              patchNameTarget="${arg2}"
          ;;
        -ch ) isByHash=true
                commitIdNew="${arg2}"
                commitIdOld="${arg3}"
          ;;
        -cmh ) isByHashAndMore=true
                commitIdOld="${arg2}"
                dirPathPatchTarget="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitPatch --rely "git" && return $resultFail
    #参数校验
    [ -z "$branchNameNow" ] && ftGitPatch --env && return $resultFail
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitPatch -h && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd)
    local dirPathGitRoot=$(git rev-parse --show-toplevel)
    [[ ! -d ${dirPathGitRoot} ]] && ftEcho -e "找不到仓库的根目录\\ndirPathGitRoot=$dirPathGitRoot" && return $resultFail
    cd ${dirPathGitRoot}

    [[ -n "isApplayPatch" ]] && if [[ -f $filePathPatchSource ]]; then
        git am $filePathPatchSource
        return
    # elif [[ -d $filePathPatchSource  ]]; then
    else ftEcho -e "patch添加失败，无效路径：${filePathPatchSource}" && return $resultFail
    fi

    [[ -n "isByChange" ]] && if [[ -n "${patchNameTarget}" ]]; then
        git diff-tree -r --no-commit-id --name-only ${patchNameTarget} | xargs tar -rf ${patchNameTarget}.tar
        return
    else ftEcho -e "patch生成失败，无效包名：${patchNameTarget}" && return $resultFail ;fi

    [[ -n "isByHash" ]] && if [[ -n "${commitIdNew}" ]] && [[ -n "${commitIdOld}" ]] && [[ -n "${patchNameTarget}" ]]; then
        git diff ${commitIdNew} ${commitIdOld} --name-only | xargs tar -rf ${patchNameTarget}.tar
        return
    else ftEcho -e "patch生成失败" && return $resultFail ;fi

    [[ -n "isByHashAndMore" ]] && if [[ -n "${commitIdOld}" ]] && [[ -n "${dirPathPatchTarget}" ]]; then
        git format-patch -s ${commitIdOld} -o ${dirPathPatchTarget}
        return
    else ftEcho -e "patch生成失败" && return $resultFail;fi

    cd ${dirPathLocal}
}

complete -W "-h --help --rely_install -f" ftGitTagGrep
ftGitTagGrep()
{
    local ftEffect=GIT的标签内容过滤
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local strKeyContent
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get update
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    在所有标签注释中查找指定字符串
#    ftGitTagGrep -f 查找的字符串
#    可简化 [ftGitTagGrep -f] 为 [xgft] ,其他参数不变
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -f ) strKeyContent="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitTagGrep --rely "git" && return $resultFail
    #环境校验
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [[ -z "${branchNameNow}" ]] && ftGitTagGrep --env && return $resultFail
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$strKeyContent" ] && errorContent="${errorContent}\\n[想要的有点多,这个给不了]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagGrep -h && return $resultFail

    #实现主体
    local tagNameList=($(git tag))
    local i=${#tagNameList[@]}
    while (( $i>0 )) ;do (( i-=1 ))
        local tagName=${tagNameList[$i]}
        local tagConnect="$(git show -q $tagName)"
        if [[ -z $(echo "${tagConnect}" |grep "${strKeyContent}") ]]; then
            continue
        fi

        local commitHashId=$(echo "${tagConnect}" | grep commit | sed -e "s:commit ::g")

        ftEcho -s "\n\n====================  ${tagName}  ===================="
        echo "${tagConnect}"
        echo -e "\n\n标签所在分支：\n$(git branch -a --contains ${commitHashId})"
        break

    done
}

complete -W "-t -h  -a --help --app --modify --branch" ftGitTag
ftGitTag()
{
    local ftEffect=GIT的标签常见操作
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local tagName noteContent commitId isDeleteTag
    local isUseVersionReadMeTemplate isUseModifyReadmeTemplate isUseBranchReadmeTemplate isUseAppReadMeTemplate
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local valCount=1 errorContent arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#=========================================================" ;return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    添加版本标签 :
#    ftGitTag -a 标签名
#    ftGitTag -a 标签名 对应的commitid
#    可简化 [ftGitTag -a] 为 [xgat] ,其他参数不变
#
#    添加版本标签 [APP项目] :
#    ftGitTag --app 标签名
#    ftGitTag --app 标签名 对应的commitid
#    可简化 [ftGitTag --app] 为 [xgatt] ,其他参数不变
#
#    添加修改说明标签 [修改的详细说明，无模板] :
#    ftGitTag --modify 标签名
#    ftGitTag --modify 标签名 对应的commitid
#    可简化 [ftGitTag --modify] 为 [xgmt] ,其他参数不变
#
#    添加分支说明标签 [分支情况的详细说明，无模板] :
#    ftGitTag --branch 分支名
#    ftGitTag --branch 分支名 对应的commitid
#    可简化 [ftGitTag --branch] 为 [xgbt] ,其他参数不变
#
#    删除标签:
#    ftGitTag -d 标签名
#    可简化 [ftGitTag -d] 为 [xgdt] ,其他参数不变
#=========================================================" ;return ;;
        # 变量参数解析部分==============
        -a ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            isUseVersionReadMeTemplate=true
            ;;
        --app ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            isUseAppReadMeTemplate=true
            ;;
        --modify ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            (( ${#commitId} > 7 )) && commitId=${commitId:0:7}
            tagName="ModifyDescription_${commitId}"
            isUseModifyReadmeTemplate=true
            ;;
        --branch ) tagName="${arg2}"
            commitId="${arg3}"
            [[ -z "$commitId" ]] && commitId=$(ftGitLogShell -t "%h" -n 1)
            (( ${#commitId} > 7 )) && commitId=${commitId:0:7}
            tagName="BranchDescription_${tagName}"
            isUseBranchReadmeTemplate=true
            ;;
        -d ) tagName="${arg2}"
              isDeleteTag=true
            ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which git) ]] && ftGitTag --rely "git" && return $resultFail
    #参数校验
    [ -z "$tagName" ]&&[ -z "${isUseVersionReadMeTemplate}" ] && errorContent="${errorContent}\\n[tagName为空]tagName=$tagName"
    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTag -h && return $resultFail

    #实现主体
    if [[ -n "$isDeleteTag" ]];then
        git tag -d $tagName && git push origin :refs/tags/${tagName}
        return
    fi

    local fileNameVersionNote="GitTag.readme"
    local filePathVersionNote=/tmp/${fileNameVersionNote}
    [ -f "${filePathVersionNote}" ] && rm -rf "${filePathVersionNote}"

    if [ -n "${isUseVersionReadMeTemplate}" ];then
        local key="当前版本："
        ftGitTagCreateVersionTemplateByVersionReadme -t "${filePathVersionNote}"
        [[ ! -f $filePathVersionNote ]]||[[ -z $(cat $filePathVersionNote) ]] && ftEcho -e "本地缺少有效的版本说明，请手动输入新说明"
        [[ -f $filePathVersionNote ]] && if [[ -z ${tagName} ]]; then
            tagName=$(cat $filePathVersionNote |grep ${key})
            tagName=${tagName//$key/}
            tagName=$(echo $tagName |sed s/[[:space:]]//g)
        fi
    fi

    local localTagResult=$(git tag |grep "${tagName}")
    if [ -n "${localTagResult}" ] && [[ "${localTagResult}" = "${tagName}" ]]; then
        ftEcho -y "已存在标签:${tagName} \n 是否强制删除(回车默认y)"
        read -n 1 sel ;[ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    ftGitTag -d "${TAG}" ; break;;
                n | q )  echo ;
                    return ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
        esac;done ; 
    fi

    [ -n "${isUseAppReadMeTemplate}" ] && ftGitTagCreateAppReadMeTemplate -v "${tagName}" -f "${filePathVersionNote}"
    [ -n "${isUseBranchReadmeTemplate}" ] && ftGitTagCreateBranchReadMeTemplate -f "${filePathVersionNote}"
    if touch "${filePathVersionNote}" ; then
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s "${filePathVersionNote}"
    else
        ftEcho -ex "创建临时说明信息文件失败"
        return;
    fi

    # if [[ -z "$(cat filePathVersionNote |grep 分支名)" ]]; then
    #     local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    #     local filePathVersionNoteTemp=${filePathVersionNote}_temp

    #     echo "分支名[真实]：${branchNameNow}${enterLine}" >> $filePathVersionNoteTemp
    #     cat $filePathVersionNote  >> $filePathVersionNoteTemp
    #     mv $filePathVersionNoteTemp $filePathVersionNote
    # fi

    noteContent="$(cat $filePathVersionNote)" ;rm -rf $filePathVersionNote

    if [[ -z "$noteContent" ]];then
        ftEcho -y "空的备注信息，是否使用commit名作为备注信息 (回车默认y)"
        read -n 1 sel ;[ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    noteContent=$(ftGitLogShell -t "%s" -n 1) ; break;;
                n | q )  echo ;
                    return ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
    esac;done ; fi

    [[ -z "$noteContent" ]] && ftEcho -e 标签添加失败,缺少备注 && return $resultFail
    if ! git tag -a "${tagName}" -m "${noteContent[@]}" "$commitId"; then
        ftEcho -e 标签添加失败 && return $resultFail
    fi

    ftEcho -y "是否提交(回车默认y)" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y
    [[ "${sel}" != "y" ]] && return
    git push --tag && git push 
}

complete -W "-h --help --rely_install" ftGitPushForce_SXTD
ftGitPushForce_SXTD()
{
    local ftEffect=模拟SXTD的git服务器环境下git的push_force功能
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    缺失依赖： ${2}
#    补全依赖： ${3}
#=========================================================" ;return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitPushForce_SXTD 无参
#=========================================================" ;return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#=========================================================" ;return ;;
    --env_warning) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 主分支下无法模拟force
#=========================================================" ;return ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitPushForce_SXTD --rely "git" "ftGitPushForce_SXTD --rely_install" && return $resultFail
    #解参验耦
    local valCount=0 errorContent
    local branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "${branchNameLocal}" ] && ftGitPushForce_SXTD --env && return $resultFail
    [[ "${branchNameLocal}" = "master" ]] && ftGitPushForce_SXTD --env_warning && return $resultFail
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitPushForce_SXTD -h && return $resultFail

    #实现主体
    git push origin --delete "${branchNameLocal}" \
    && git push origin --set-upstream "${branchNameLocal}" \
    || ftEcho -s "分支[ ${branchNameLocal} ]push force 失败"
}

complete -W "-h --help --rely_install" ftGitSxtdProjectBranchV1
ftGitSxtdProjectBranchV1()
{
    local ftEffect=以目录隔离同平台不同项目的相关实现[sxtd老项目]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get update
            sudo apt-get install git
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitSxtdProjectBranchV1  #无参数
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 环境未初始化
# 使用前,请先进入AOSP项目
#========================================================="; return ;;
    * ) break;;esac;done

    #环境校验
    if [[ -z "$ANDROID_BUILD_TOP" ]];then
        [[ -d "alps" ]] && [[ -d ".git" ]] && cd alps
        ftAutoInitEnv > /dev/null
    fi
    local dirPathAospRoot=$(dirname $ANDROID_BUILD_TOP)
    [[ ! -d "${dirPathAospRoot}" ]] && ftGitSxtdProjectBranchV1 --env && return $resultFail
    local dirPathLocal=$(pwd)
    cd "${dirPathAospRoot}"
    #依赖校验
    [[ -z $(which git) ]] && ftGitSxtdProjectBranchV1 --rely "git" && return $resultFail
    #解参验耦
    local valCount=1 errorContent
    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "$branchName" ] && errorContent="${errorContent}\\n[当前目录无有效git仓库]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitSxtdProjectBranchV1 -h && return $resultFail

    #实现主体
    ftEcho -s "开始收集项目状态"
    local hashValBase=$(ftGitLogShell -t "%h" -n 1)
    git reset > /dev/null
    git add -A $(git status --porcelain |grep -v "alps/out" | sed s/??//g\
    | sed -e "s: T ::g"\
    | sed -e "s: M ::g"\
    | sed -e "s: D ::g"\
    |grep "alps/") > /dev/null
    git status --porcelain

    ftEcho -y "请确认待commit修改列表,是否正确(回车默认y)"
    read -n 1 sel ;[ -z "${sel}" ] && sel=y
    while true; do case "$sel" in
            y | Y )
                local tarPackagAutoCreateName=0tempBranch tarPackagAutoCreateNameTemp=temp
                ls | while read line;do
                    [[ ! -d "$line" ]] && continue
                    if [[  ${line//$tarPackagAutoCreateName} != $line ]]; then
                        local dirPath=${line}
                        local dirPath_old=${dirPath}_old
                        [[ -d "$dirPath_old" ]] && dirPath_old=${dirPath_old}_old
                        mv $dirPath $dirPath_old
                    fi
                done

                ftEcho -s "开始添加临时commit"
                git commit -m "temp" > /dev/null
                local hashValTemp=$(ftGitLogShell -t "%h" -n 1)
                git diff $hashValTemp $hashValBase --name-only | xargs tar -rf ${tarPackagAutoCreateName}.tar

                mkdir $tarPackagAutoCreateNameTemp
                tar -xvf ${tarPackagAutoCreateName}.tar -C ${tarPackagAutoCreateNameTemp}

                [[ -z $(ls $tarPackagAutoCreateNameTemp) ]] && ftEcho -e "分支patch包生成失败,请确认是否有除[?/T/M/D]之外修改类型,或检查gitignore配置文件" \
               && rm -rf ${tarPackagAutoCreateNameTemp} ${tarPackagAutoCreateName}.tar && return $resultFail

                mv ${tarPackagAutoCreateNameTemp}/alps ${tarPackagAutoCreateName}
                rm -rf $tarPackagAutoCreateNameTemp ${tarPackagAutoCreateName}.tar
                ftEcho -s "已生成临时分支: ${tarPackagAutoCreateName}"

                break;;
            n | q )  echo ;
                return ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
    esac;done ;
    git reset $hashValBase > /dev/null #&& ftEcho -s "已删除临时commit"
    cd "${dirPathLocal}"
}

complete -W "-h --help --rely_install -c -r -d" ftGitSxtdProjectBranchV2
ftGitSxtdProjectBranchV2()
{
    local ftEffect=以分支隔离同平台不同项目的相关实现[sxtd新项目]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local isCreateBranch isReName isDelete
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftGitSxtdProjectBranchV2 --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#   ftGitSxtdProjectBranchV2 -c   #创建分支
#   ftGitSxtdProjectBranchV2 -r   #重命名分支
#   ftGitSxtdProjectBranchV2 -d   #删除分支
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
# 当前目录无有效GIT仓库
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -c )  isCreateBranch=true
            ;;
        -r )  isReName=true
            ;;
        -d )  isDelete=true
            ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitSxtdProjectBranchV2 --rely "git" && return $resultFail
    #环境校验
    local branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    [ -z "${branchNameLocal}" ] && ftGitSxtdProjectBranchV2 --env && return $resultFail
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitSxtdProjectBranchV2 -h && return $resultFail

    local mFilePathSxtdProjectBranchV2="${dirPathHome}/.cache/projectDescriptionTemp.ini"
    local mBranchList=(
        $(git branch -a|grep -v "* ${branchNameLocal}" |grep -v "remotes/origin") \
        $(git branch -a |grep "remotes/origin"|grep -v "remotes/origin/HEAD -> " | sed -e "s:remotes/origin/::g" ) \
        ${branchNameLocal})
    mBranchList=($(echo "${mBranchList[@]}"  | sed 's/ /\n/g' |sort |uniq)) #去重

    if [[ $isReName = "true" ]]; then
        local TagName="分支信息描述" mKeyIniBranchNameBase="原分支名" mKeyIniBranchNameNew="新分支名"

        echo -e "#ini\n" > $mFilePathSxtdProjectBranchV2
        echo "[分支列表,仅用于复制]" >> $mFilePathSxtdProjectBranchV2
        for index in "${!mBranchList[@]}"; do echo "${mBranchList[$index]}" >> $mFilePathSxtdProjectBranchV2 ;done
        ftIniCreateFileOrTag  -a -p $mFilePathSxtdProjectBranchV2 -t $TagName -l "${mKeyIniBranchNameBase}= ${mKeyIniBranchNameNew}= "

        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2
        local mBranchNameBase=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameBase)
                mBranchNameNew=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameNew)
        [ -z "${mBranchNameBase}" ] && ftEcho -e "缺失原分支名,请确认是否输入" && return $resultFail
        [ -z "${mBranchNameNew}" ] && ftEcho -e "缺失新分支名,请确认是否输入" && return $resultFail

        git branch -m "${mBranchNameBase}" "${mBranchNameNew}" || return $resultFail
        ftEcho -s "${mBranchNameBase} \n本地修改为 \n${mBranchNameNew}"

        ftEcho -y "是否同时重命名服务器分支(回车默认y)"
        read -n 1 sel ; [ -z "${sel}" ] && sel=y ; while true; do case "$sel" in
            y | Y )
                git push origin --delete "${mBranchNameBase}" && git push origin "${mBranchNameNew}" || ftEcho -e "远程操作失败"
                break;;
            n | q ) exit ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
        esac;done

        rm $mFilePathSxtdProjectBranchV2
        return
    fi

    if [[ $isDelete = "true" ]]; then
        local TagName="分支信息描述" mKeyIniBranchNameDelete="待删除分支名"

        echo -e "#ini\n" > $mFilePathSxtdProjectBranchV2
        echo "[分支列表,仅用于复制]" >> $mFilePathSxtdProjectBranchV2
        for index in "${!mBranchList[@]}"; do echo "${mBranchList[$index]}" >> $mFilePathSxtdProjectBranchV2 ;done
        ftIniCreateFileOrTag  -a -p $mFilePathSxtdProjectBranchV2 -t $TagName -l "${mKeyIniBranchNameDelete}= "

        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2 > /dev/null
        local mBranchNameDelete=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniBranchNameDelete)
        [ -z "${mBranchNameDelete}" ] && ftEcho -e "缺失待删除分支名,请确认是否输入" && return $resultFail

        git branch -D "${mBranchNameDelete}" || return $resultFail

        ftEcho -y "是否同时删除对应服务器分支(回车默认y)"
        read -n 1 sel ; [ -z "${sel}" ] && sel=y ; while true; do case "$sel" in
            y | Y )
                git push origin --delete "${mBranchNameDelete}"|| ftEcho -e "远程操作失败"
                break;;
            n | q ) exit ;;
            * ) ftEcho -e "错误的选择：$sel"
                echo "输入n，q，离开";;
        esac;done

        rm $mFilePathSxtdProjectBranchV2
        return
    fi

    if [[ $isCreateBranch = "true" ]]; then
        local TagName="项目描述" mKeyIniClientName="客户名"  mKeyIniProjrctName="项目名"  mKeyIniMotherBoardName="主板名"  mKeyIniDemandSignName="项目的其他特性描述"
        local mKeyBranchClientName="CT" mKeyBranchProjrctName="PJ" mKeyBranchMotherBoardName="MBML" mKeyBranchDemandSignName="DM"

        ftIniCreateFileOrTag  -r -p $mFilePathSxtdProjectBranchV2 -t $TagName -l \
        "${mKeyIniMotherBoardName}= \
        ${mKeyIniProjrctName}= \
        #客户名请使用全拼和驼峰命名法 \
        ${mKeyIniClientName}= \
        #不同特性之间用下划线分割 \
        ${mKeyIniDemandSignName}="
        [[ ! -f "$mFilePathSxtdProjectBranchV2" ]] && ftEcho -e "${TagName}文件创建失败" && return $resultFail
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $mFilePathSxtdProjectBranchV2

        local mMotherBoardName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniMotherBoardName) \
                mProjrctName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniProjrctName) \
                mClientName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniClientName) \
                mDemandSignName=$(ftIniGetValue $mFilePathSxtdProjectBranchV2 $TagName $mKeyIniDemandSignName)
        [[ -z "$mMotherBoardName" ]] && ftEcho -e "缺失项目主板名信息,请确认是否输入" && return $resultFail
        [[ -z "$mProjrctName" ]] && ftEcho -e "缺失项目名信息,请确认是否输入" && return $resultFail
        [[ -z "$mClientName" ]] && ftEcho -e "缺失项目客户名信息,请确认是否输入" && return $resultFail
        mDemandSignName=${mDemandSignName:-'ZhongXing'}
        local mBranchName="${mKeyBranchMotherBoardName}(${mMotherBoardName})"
        mBranchName="${mBranchName}_${mKeyBranchProjrctName}(${mProjrctName})"
        mBranchName="${mBranchName}_${mKeyBranchClientName}(${mClientName})"
        mBranchName="${mBranchName}_${mKeyBranchDemandSignName}(${mDemandSignName})"

        for branch in ${mBranchList[@]}; do [[ "$branch" = "$mBranchName" ]] && ftEcho -s "分支[${mBranchName}]已存在"&& return ; done
        git branch "${mBranchName}" && ftEcho -s "分支[${mBranchName}]创建成功"
        rm $mFilePathSxtdProjectBranchV2
        return
    fi
}

complete -W "-h --help -f -v" ftGitTagCreateAppReadMeTemplate
ftGitTagCreateAppReadMeTemplate()
{
    local ftEffect=GIT的标签模板[APP版本说明]
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] &&[ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local filePathConfig=$rFilePathXbashDBUser
    local filePathAppReadMe versionName
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitTagCreateAppReadMeTemplate -f 模板文件路径 -v 版本号
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -f ) filePathAppReadMe="${arg2}"
            filePathAppReadMe=$(ftPath $filePathAppReadMe)
            ;;
        -v ) versionName="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftGitTagCreateAppReadMeTemplate --rely && return $resultFail
    [ ! -f "$filePathConfig" ] && errorContent="${errorContent}\\n[配置文件不存在]filePathConfig=$filePathConfig"
    [ -z "$filePathAppReadMe" ] && errorContent="${errorContent}\\n[模板路径为空]filePathAppReadMe=$filePathAppReadMe"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateAppReadMeTemplate -h && return $resultFail

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    #版本说明
    local enterLine="\n"
    local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
    content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
    content=${content}${enterLine}
    content=${content}${enterLine}"硬件项目平台："
    content=${content}${enterLine}"当前版本：$versionName"
    content=${content}${enterLine}"基础版本："
    content=${content}${enterLine}"客户名："
    content=${content}${enterLine}"说明："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}
    content=${content}${enterLine}"修改记录："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}

    echo -e ${content}${enterLine}${enterLine} >$filePathAppReadMe

    # 转化为windows下面文件格式
    unix2dos $filePathAppReadMe
}

complete -W "-h --help -f  " ftGitTagCreateBranchReadMeTemplate
ftGitTagCreateBranchReadMeTemplate()
{
    local ftEffect=GIT的标签模板[分支创建说明]
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local filePathAppReadMe filePathConfig=$rFilePathXbashDBUser
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftGitTagCreateBranchReadMeTemplate -f 模板文件路径
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -f ) filePathAppReadMe="${arg2}"
            filePathAppReadMe=$(ftPath $filePathAppReadMe)
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftGitTagCreateBranchReadMeTemplate --rely && return $resultFail
    [ ! -f "$filePathConfig" ] && errorContent="${errorContent}\\n[配置文件不存在]filePathConfig=$filePathConfig"
    [ -z "$filePathAppReadMe" ] && errorContent="${errorContent}\\n[模板路径为空]filePathAppReadMe=$filePathAppReadMe"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateBranchReadMeTemplate -h && return $resultFail

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    #版本说明
    local enterLine="\n"
    local content="$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordMeTag)"
    content=${content}${enterLine}"记录创建人：$(ftIniGetValue $filePathConfig projectSoftwareReadMeInfo recordCreator)"
    content=${content}${enterLine}
    content=${content}${enterLine}"硬件项目平台："
    if [[ -n "${branchNameNow}" ]]; then
        content=${content}${enterLine}"版本CommitHash：$(ftGitLogShell -n 1 -c "%h") "
        content=${content}${enterLine}"分支名[真实]：${branchNameNow}"
        if [[ "${branchNameNow}" != "master" ]]; then
            content=${content}${enterLine}"父分支名[真实]："
        fi
    else
        content=${content}${enterLine}"分支名："
    fi
    content=${content}${enterLine}"分支变更原因说明："
    content=${content}${enterLine}"\t01 "
    content=${content}${enterLine}

    echo -e ${content}${enterLine}${enterLine} >$filePathAppReadMe

    # 转化为windows下面文件格式
    unix2dos $filePathAppReadMe
}

complete -W "-h --help -f -t " ftGitTagCreateVersionTemplateByVersionReadme
ftGitTagCreateVersionTemplateByVersionReadme()
{
    local ftEffect=GIT的标签模板[版本说明]
    local isEnable=sub

    #可用性校验
    [[ "$isEnable" != "true" ]] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local filePathReadme
    local valCount=4 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftGitTagCreateVersionTemplateByVersionReadme -t git标签用的模板存放路径
#    ftGitTagCreateVersionTemplateByVersionReadme -f 版本说明路径 -t git标签用的模板存放路径
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
#    环境未初始化
#    使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -f ) filePathReadme="${arg2}"
            ;;
        -t ) filePathReadmeTarget="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${filePathReadmeTarget}" ] && errorContent="${errorContent}\\n[模板存放路径为空]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitTagCreateVersionTemplateByVersionReadme -h && return $resultFail

    #实现主体
    if [[ -z $filePathReadme ]] || [[ ! -f $filePathReadme ]]; then
        [[ ! -d out ]] && [ -n "$ANDROID_BUILD_TOP" ] && cd "${ANDROID_BUILD_TOP}"
        [[ ! -d out ]] && ftEcho -s "未找到有效版本说明" && ftGitTagCreateVersionTemplateByVersionReadme -h && return $resultFail
        filePathReadme=$(find out/packet -name 版本说明.txt)
    fi

    cp "${filePathReadme}" "${filePathReadmeTarget}"
    filePathReadme=$filePathReadmeTarget

    #删除 标题头
    sed -i '1d' $filePathReadme
    sed -i '1d' $filePathReadme

    #删除 git commit list
    local lineCount=$(awk 'END{print NR}' $filePathReadme)
    local lineNumIndex=$(awk '/git commit 记录：/{print NR}' $filePathReadme)
    ((lineCount=lineCount-lineNumIndex+1))
    for (( i = 1; i <= lineCount; i++ )); do
        sed -i '$d' $filePathReadme
    done
}

complete -W "-h --help --rely_install -b" ftGitgetParentBranch
ftGitgetParentBranch()
{
    local ftEffect=获取父分支
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return $resultFail
    #解参验耦
    local branchNameLocal
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftGitgetParentBranch --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install git
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#   查看当前目录下GIT分支的父分支
#    ftGitgetParentBranch
#    可简化 [ftGitgetParentBranch] 为 [xgp] ,其他参数不变
#
#
#   查看当前目录下指定GIT分支的父分支
#    ftGitgetParentBranch -b 分支名
#    可简化 [ftGitgetParentBranch -b] 为 [xgpp] ,其他参数不变
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
#    环境未初始化
#    使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -b ) branchNameLocal="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftGitgetParentBranch --rely "git" && return $resultFail
    [ -z "${branchNameLocal}" ] &&
        branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${branchNameLocal}" ] && errorContent="${errorContent}\\n[未指定分支名]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitgetParentBranch -h && return $resultFail

    #实现主体
     local branchNameParent=($(git reflog show --date=iso "${branchNameLocal}"|grep "branch: Created from"))
     local arrayLength=${#branchNameParent[@]}
    ((arrayLength-=1))
    ftEcho -sn "父分支名:" && echo ${branchNameParent[$arrayLength]}
}

complete -W "-h --help -p" ftGitPullFailForceUpdateHEAD
ftGitPullFailForceUpdateHEAD()
{
    local ftEffect=git更新失败时的强制更新
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local projectName
    local valCount=2 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    #eval arg3=\${$((i+2))} #; eval arg4=\${$((i+3))}
    case "${arg}" in
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftGitPullFailForceUpdateHEAD -p 项目名称
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -p ) projectName="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${projectName}" ] && errorContent="${errorContent}\\n[项目名无效]projectName=$projectName"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitPullFailForceUpdateHEAD -h && return $resultFail

    #实现主体
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    #远程分支最新提交
    local originCommitHashIdNew=$(git log --pretty=format:"%h" -1 origin/${branchNameNow})
    local branchOldTemp=AutoBackupFromMaster_Temp_$(date -d "today" +"%y%m%d%H%M%S")

    ftEcho -e "${projectName} 更新失败" && \
    git branch ${branchOldTemp} && \
    git reset --soft ${originCommitHashIdNew} && \
    ftEcho -s "已强制更新到${originCommitHashIdNew}"
}

complete -W "-h --help" ftGitAutoClone
ftGitAutoClone()
{
    local ftEffect=多仓库快速克隆[懒癌版]
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local isActive
    local valCount=1 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    # 全部克隆
#    ftGitAutoClone 无参
#
#    # 只克隆活跃仓库
#    ftGitAutoClone -m
#========================================================="; return ;;
        # 变量参数解析部分==============
        -m ) isActive=true
         ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGitAutoClone -h && return $resultFail

    #实现主体
    local projectList=($(ftXbGetValue AospProjectsInfo AospProjectGitStorehouseList))
    [[ -n "$isActive" ]] && projectList=($(ftXbGetValue AospProjectsInfo AospProjectActiveGitStorehouseList))
    local gitStorehouseServerAddress=($(ftXbGetValue AospProjectsInfo AospProjectGitStorehouseServerAddress))
    local dirPathLocal=$(pwd)
    for project in ${projectList[@]}; do
        cd $dirPathLocal
        if [[ -d "${project}" ]]; then
            cd $project
            ftEcho -s "=============== 开始更新${project} ================="
            git pull || ftGitPullFailForceUpdateHEAD -p ${project}
            continue
        else
            ftEcho -s "=============== 开始拉取${project} ================="
            git clone --no-checkout ${gitStorehouseServerAddress}/${project} || continue
        fi
        sleep 600
    done
}
