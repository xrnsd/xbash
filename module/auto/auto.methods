#!/bin/bash
#  AOSP项目相关方法实现
ftAutoInitEnv()
{
    local ftEffect=初始化xbash_Android_build相关所需的部分环境变量
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftAutoInitEnv 无参
#    ftAutoInitEnv -bp #强制解析build.prop信息
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT buildType=$TARGET_BUILD_VARIANT
    local editType=$1
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ]\
        ||[ -z "$TARGET_PRODUCT" ];then
        local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
        local dirPathLocal=$(pwd)
        #if [  -d "${dirPathLocal}/out" ] && [ -n "$branchName" ];then
        if [  -d "${dirPathLocal}/out" ] ;then
            export ANDROID_BUILD_TOP=$dirPathLocal
            dirPathCode=$ANDROID_BUILD_TOP
            dirPathOut=${ANDROID_BUILD_TOP}/out/target/product
            if [[ -d $dirPathOut ]]; then
                        while read item ;do
                           if [[ -f ${dirPathOut}/${item}/system/build.prop ]]; then
                                dirPathOut="${dirPathOut}/${item}"
                                export TARGET_PRODUCT=full_${item}
                                export ANDROID_PRODUCT_OUT=$dirPathOut
                                ftAutoInitEnv $@
                                export TARGET_BUILD_VARIANT=$AutoEnv_buildType
                                return
                           fi
                        done < <(echo "$(ls $dirPathOut)")
            fi
        else
            ftAutoInitEnv --env
        fi
        return
    fi
    local valCount=2 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoInitEnv -h && return $resultFail

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    # 项目平台
    local dirPathVendor=${dirPathCode}/vendor
    if [ -d $dirPathVendor ];then
            dirList=$(ls $dirPathVendor)
            for item in $dirList ; do
                if [ $item = "sprd" ];then
                     local mnufacturers=sprd
                    #device路径
                    export AutoEnv_deviceDirPath=
                    local dirPathDevice=$(find device/ -name "$(basename $ANDROID_PRODUCT_OUT)")
                    [[ -d "$dirPathDevice" ]] && export AutoEnv_deviceDirPath=$dirPathDevice

                     continue
                fi
                [ $item = "mediatek" ] && local mnufacturers=mtk
            done
    fi
    export AutoEnv_mnufacturers=
    [[ -z "$mnufacturers" ]] && ftEcho -e "未找到 $dirPathVendor\n mnufacturers[项目平台] 获取失败" || \
    export AutoEnv_mnufacturers=$mnufacturers


    #软件版本名
    export AutoEnv_versionName=
    local filePathOutBuildProp=${dirPathOut}/system/build.prop
    if [ -f $filePathOutBuildProp ];then
            local keyVersion="ro.build.display.id="
            local versionName=$(cat $filePathOutBuildProp|grep $keyVersion)
            versionName=${versionName//$keyVersion/}
            if [[ -n "$LZ_BUILD_VERSION" ]] && [[ "$versionName" != "$LZ_BUILD_VERSION" ]]; then
                    ftEcho -e "环境与本地，软件版本不一致:\n本地:${versionName}\n环境:${LZ_BUILD_VERSION}"
            fi
    elif [[ -n "$LZ_BUILD_VERSION" ]];then
            local versionName=$LZ_BUILD_VERSION
    fi
    [ -z "$versionName" ] && versionName=$(basename $ANDROID_PRODUCT_OUT)
    versionName=${versionName// /_}
    versionName=${versionName//
/_}
    [[ -n "$versionName" ]] && export AutoEnv_versionName=$versionName

    #软件编译类型
    if [ -d $dirPathOut ];then
            local filePathBuildInfo=${dirPathOut}/system/build.prop
            local filePathPreviousBuildConfig=${dirPathOut}/previous_build_config.mk
            if [ -f $filePathBuildInfo ];then
                        local keybuildType="ro.build.type="
                        local buildTypeFile
                        if [ -f "$filePathBuildInfo" ];then
                            buildTypeFile=$(cat $filePathBuildInfo|grep $keybuildType)
                            if [[ -n "$buildTypeFile" ]];then
                                buildTypeFile=${buildTypeFile/$keybuildType/}
                                if [[ -n "$buildType" ]];then
                                    if [ "$buildType" != "$buildTypeFile" ];then
                                        ftEcho -e "环境与本地，编译类型不一致:\n本地:$buildTypeFile\n环境:$buildType"
                                        buildType=$buildTypeFile
                                    fi
                                else
                                    buildType=$buildTypeFile
                                fi
                            else
                                ftEcho -e "[$filePathBuildInfo]中未找到编译类型"
                            fi
                        fi
            else
                        ftEcho -e "未找到 $filePathBuildInfo\n build Type[本地] 获取失败"

                        if [ -f "$filePathPreviousBuildConfig" ];then
                                info=$(cat $filePathPreviousBuildConfig|grep $TARGET_PRODUCT)
                                if [[ -n "$info" ]];then

                                    local OLD_IFS="$IFS"
                                    IFS="-"
                                    local arrayItems=($info)
                                    IFS="$OLD_IFS"
                                    if [ "$info" = "$arrayItems" ];then
                                            ftEcho -e "${filePathPreviousBuildConfig} 信息解析失败"
                                    else
                                            local buildinfo=null
                                            for item in ${arrayItems[@]} ;  do
                                                if [[ "$item" = "$TARGET_PRODUCT" ]]; then
                                                    buildinfo=
                                                elif [[ -z "$buildinfo" ]]; then
                                                    buildType=$item
                                                    buildinfo=$buildType
                                                fi
                                            done
                                    fi
                                fi
                        fi
            fi
    fi
    export AutoEnv_buildType=$buildType

    if [[ -n $ANDROID_PRODUCT_OUT ]]; then
        local productName=$(basename $ANDROID_PRODUCT_OUT)
        local filepathDeviceMtk9ProjectConfig="device/mediateksample/${productName}/ProjectConfig.mk"
        if [[ -f ${filepathDeviceMtk9ProjectConfig} ]]; then
            local keyNameModemConfig="CUSTOM_MODEM"
            local dirNameModem=$(cat ${filepathDeviceMtk9ProjectConfig} |grep ${keyNameModemConfig} | awk '{print $3}')
            export AutoEnv_ModemPath="vendor/mediatek/proprietary/modem/${dirNameModem}"
        fi
    fi

    #git分支信息解析
   ftBranchNameResolution

    cd $dirPathLocal
    trap SIGINT
}

complete -W "-h --help" ftBranchNameResolution
ftBranchNameResolution()
{
    local ftEffect=分支名解析
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftBranchNameResolution -h
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftBranchNameResolution --rely "git" && return $resultFail
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ];then
        ftBranchNameResolution --env
        return $resultFail
    fi
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBranchNameResolution -h && return $resultFail

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    local branchName=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    local key="branchName="
    local filePathGitConfigInfoLocal=${dirPathOut}/git.info
    if [ -f "$filePathGitConfigInfoLocal" ];then
        local bn=$(cat $filePathGitConfigInfoLocal|grep "$key")
        if [[ -n "$bn" ]];then
            local branchNameFile=${bn//$key/}
            if [[ "$branchNameFile" != "$branchName" ]]; then
                    ftEcho -e "环境与本地，分支不一致:\n本地:$branchNameFile\n环境:$branchName"
            fi
            branchName=$branchNameFile
        else
            echo "${key}${branchName}" >>$filePathGitConfigInfoLocal
        fi
    elif [ -d "$dirPathOut" ];then
        echo "${key}${branchName}" >$filePathGitConfigInfoLocal
    fi
    if [[ -n "$branchName" ]];then
        local OLD_IFS="$IFS"
        IFS=")"
        local arrayItems=($branchName)
        IFS="$OLD_IFS"
        export AutoEnv_branchName=$branchName
        if [ "$branchName" = "$arrayItems" ];then
                ftEcho -e "分支信息解析失败 :${branchName}" > /dev/null
        else
                export AutoEnv_clientName=
                export AutoEnv_projrctName=
                export AutoEnv_modelAllName=
                export AutoEnv_demandSignName=
                export AutoEnv_motherboardName=
                export AutoEnv_screenScanDirection=
                export AutoEnv_BandInfo=
                export AutoEnv_FlashConfig=
                export AutoEnv_branchName=null

                for item in ${arrayItems[@]} ; do
                        local key=${item%\(*}
                        local val=${item//$key/}
                        val=${val//\(/}
                        key=${key//_/}

                         [[ $key = "CT" ]] && export AutoEnv_clientName=$val && continue
                         [[ $key = "PJ" ]] && export AutoEnv_projrctName=$val && continue
                         [[ $key = "SS" ]] && export AutoEnv_screenScanDirection=$val && continue
                         [[ $key = "DM" ]] && export AutoEnv_demandSignName=$val && continue
                         [[ $key = "PMA" ]] && export AutoEnv_modelAllName=$val && continue
                         [[ $key = "MBML" ]] && export AutoEnv_motherboardName=$val && continue
                         [[ $key = "BAND" ]] && export AutoEnv_BandInfo=$val && continue
                         [[ $key = "FLASH" ]] && export AutoEnv_FlashConfig=$val && continue
                done
                [[ -n "$branchName" ]] && export AutoEnv_branchName=$branchName
        fi
    fi
    cd $dirPathLocal
}

complete -W "-h --help" ftBuildPropResolution
ftBuildPropResolution()
{
    local ftEffect=build.prop解析
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftBuildPropResolution -h
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #依赖校验
    [[ -z $(which git) ]] && ftBuildPropResolution --rely "git" && return $resultFail
    #解参验耦
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    if [ -z "$ANDROID_BUILD_TOP" ]\
        ||[ -z "$ANDROID_PRODUCT_OUT" ];then
        ftBuildPropResolution --env
        return $resultFail
    fi
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBuildPropResolution -h && return $resultFail

    #实现主体
    local dirPathLocal=$PWD
    cd $dirPathCode

    local keySoftType="ro.build.type=" keyModel="ro.product.model=" keySoftVersion="ro.build.display.id="
    local keySDKVersion="ro.build.version.sdk=" filePathSystemBuildprop=${dirPathOut}/system/build.prop
    local deviceModelName deviceSoftType deviceSoftVersion deviceSdkVersion

    export AutoEnv_deviceModelName=
    export AutoEnv_deviceSoftType=
    export AutoEnv_deviceSoftVersion=
    export AutoEnv_deviceSdkVersion=
    export AutoEnv_AndroidVersion=

    if [ -f "$filePathSystemBuildprop" ];then
            deviceModelName=$(cat $filePathSystemBuildprop|grep "$keyModel")
            deviceSoftType=$(cat $filePathSystemBuildprop|grep "$keySoftType")
            deviceSoftVersion=$(cat $filePathSystemBuildprop|grep "$keySoftVersion")
            deviceSdkVersion=$(cat $filePathSystemBuildprop|grep "$keySDKVersion")
    elif [ "$editType" = "-bp" ];then
            ftEcho -s "未找到 $filePathSystemBuildprop\n版本软件信息未获取"
            return $resultFail
    fi

    if [[ -n "$deviceSoftVersion" ]];then
            deviceModelName=${deviceModelName//$keyModel/}
            deviceModelName=${deviceModelName// /_}
            deviceModelName=$(echo $deviceModelName |sed s/[[:space:]]//g)
            deviceModelName=${deviceModelName:-'null'}
            export AutoEnv_deviceModelName=$deviceModelName

            deviceSoftType=${deviceSoftType//$keySoftType/}
            deviceSoftType=$(echo $deviceSoftType |sed s/[[:space:]]//g)
            deviceSoftType=${deviceSoftType:-'null'}
            export AutoEnv_deviceSoftType=$deviceSoftType

            deviceSoftVersion=${deviceSoftVersion//$keySoftVersion/}
            deviceSoftVersion=$(echo $deviceSoftVersion |sed s/[[:space:]]//g)
            deviceSoftVersion=${deviceSoftVersion:-'null'}
            export AutoEnv_deviceSoftVersion=$deviceSoftVersion

            deviceSdkVersion=${deviceSdkVersion//$keySDKVersion/}
            deviceSdkVersion=$(echo $deviceSdkVersion |sed s/[[:space:]]//g)
            deviceSdkVersion=${deviceSdkVersion:-'null'}
            export AutoEnv_deviceSdkVersion=$deviceSdkVersion
            local AndroidVersion=$(ftXbGetValue androidSDK2Verison $deviceSdkVersion)
            export AutoEnv_AndroidVersion=$AndroidVersion
    fi

    cd $dirPathLocal
}

complete -W "-b -h --help" ftAutoBuildMultiBranchEnvSeparation
ftAutoBuildMultiBranchEnvSeparation()
{
    local ftEffect=多分支串行编译[环境独立]/在多个终端间串行执行命令
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    查看帮助
#    ftAutoBuildMultiBranchEnvSeparation -h
#
#    根据分支列表进行串行编译
#    ftAutoBuildMultiBranchEnvSeparation -b
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) break;;esac;done

    #环境校验
    [ -z "$ANDROID_BUILD_TOP" ] && ftAutoInitEnv
    [ -z "$ANDROID_BUILD_TOP" ] && ftAutoBuildMultiBranchEnvSeparation --env && return $resultFail
    [ -z "$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')" ] && ftEcho -e "当前目录不存在有效git仓库" && return $resultFail
    #解参验耦
    local editType=${1,,}
    local filePathserialBuildTool=${rDirPathXbashModuleAuto}/serialBuildByBranchName.module
    local dirPathProcessEnableId=/tmp/ProcessEnableIds
    local requestEnvState=$(/bin/rm -rf $dirPathProcessEnableId&&mkdir $dirPathProcessEnableId)
    local valCount=1 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$editType" ] && errorContent="${errorContent}\\n[请指定操作]"
    [[ -n "$requestEnvState" ]] && errorContent="${errorContent}\\n[环境初始化异常,文件夹无法重置]requestEnvState=$requestEnvState"
    [ ! -f "$filePathserialBuildTool" ] && errorContent="${errorContent}\\n[串行编译工具不存在]filePathserialBuildTool=$filePathserialBuildTool"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoBuildMultiBranchEnvSeparation -h && return $resultFail

    #实现主体
    if [[ "$editType" = "-b" ]]; then
        cd $ANDROID_BUILD_TOP
        [ -d "$dirPathProcessEnableId" ] && rm -rf $dirPathProcessEnableId
        mkdir $dirPathProcessEnableId

        local filePathBranchList=${dirPathProcessEnableId}/branch.list
        local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
        git branch|grep -v "${branchNameNow}" | sed -e "s:*::g" > $filePathBranchList
        echo "${branchNameNow}" >> $filePathBranchList
        XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $filePathBranchList
        local branchArray=($(cat $filePathBranchList))
        if [[ -n "$branchArray" ]];then
                    export branchArray=(${branchArray[@]})
                    for (( index = 0; index <${#branchArray[@]}; index++ )); do
                        ftEcho -s "任务${index}开始执行"
                        filePathState="${dirPathProcessEnableId}/${index}"
                        mkfifo $filePathState #利用管道文件堵塞循环，写入为堵，读取为疏
                        gnome-terminal  --title="任务:${index} : 编译${branchArray[$index]}" -x bash -c "$filePathserialBuildTool $index $filePathBranchList"
                        echo 1 > $filePathState
                    done
        fi
    fi
}

ftAutoBackupOrRestoreOuts()
{
    local ftEffect=Android编译生成out相关自动维护
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    ftAutoInitEnv
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    local isMoveBack mTagContent filterString
    local arg arg2 errorContent ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    备份out
#    ftAutoBackupOrRestoreOuts 无参
#    ftAutoBackupOrRestoreOuts -t 备注
#
#    移动匹配out到当前项目
#    ftAutoBackupOrRestoreOuts -m
#    ftAutoBackupOrRestoreOuts -m xxx   #分支名包含xxx的out列表
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t ) mTagContent="${arg2}"
             ;;
        -m )  isMoveBack=true
                filterString="${arg2}"
             ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    if [ -z "$ANDROID_BUILD_TOP" ]||[ -z "$ANDROID_PRODUCT_OUT" ];then
        if [[ -f "ftAutoBackupOrRestoreOuts" ]];then
            ./ftAutoBackupOrRestoreOuts $@
            return $resultFail
        fi
        ftAutoBackupOrRestoreOuts --env && return $resultFail
    fi
    [ ! -d "$dirPathCode" ]||[  -z "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoBackupOrRestoreOuts -h && return $resultFail

    #实现主体
    cd $dirPathCode
    #分支名
    local buildType=$AutoEnv_buildType versionName=$AutoEnv_versionName branchName="$AutoEnv_branchName"
    local dirNameCodeRootOuts=outs
    local versionInfoDateTime=$(date -d "today" +"%Y%m%d[%H:%M]")
    local dirNameBranchVersion=BuildType[${buildType}]----BranchName[${branchName}]----VersionName[${versionName}]----${versionInfoDateTime}
    [[ -n "$mTagContent" ]] && dirNameBranchVersion=${dirNameBranchVersion}_Tag[${mTagContent}]

    local dirPathOutLocal=${dirPathCode}/out
    local dirPathCodeRootOutsLocal=$(dirname $(dirname ${dirPathOutLocal}))/${dirNameCodeRootOuts}
    local dirPathOutBranchVersionLocal=${dirPathCodeRootOutsLocal}/${dirNameBranchVersion}

    if [ ! -d "$dirPathCodeRootOutsLocal" ];then
        [[ -n "$isMoveBack" ]] && ftEcho -e "${dirNameCodeRootOuts}为空" && return $resultFail
        mkdir -p $dirPathCodeRootOutsLocal
    fi

    if [[ -n "$isMoveBack" ]]; then
        if [[ -d "$dirPathOut" ]]||[[ -d "$dirPathOutLocal" ]]; then
            #lunch生成的out，视为无效
            local excludeConfigInfo=($(ftXbGetValue backupOrRestoreOutsInfo excludeConfig))
            local excludeConfigSize=${#excludeConfigInfo[@]}
            local dirPathOutLocalInfo=($(ls $dirPathOutLocal))
            local dirPathOutLocalSize=${#dirPathOutLocalInfo[@]}
            for item in ${excludeConfigInfo[@]} ; do
                    item=${dirPathOutLocal}/${item}
                    [[ ! -d "$item" ]] && [[ ! -f "$item" ]] && ((excludeConfigSize-=1)) && break
            done
            if (( $excludeConfigSize == $dirPathOutLocalSize )); then
                rm -rf $dirPathOutLocal
            else
                ftEcho -e "out已存在 ,请先备份"
                return $resultFail
            fi
        fi

        [[ -n "$filterString" ]] && branchName=$filterString
        local dirPathOutList=($(ls $dirPathCodeRootOutsLocal|grep $branchName))
        [[ ${filterString} = "user" ]] && dirPathOutList=($(ls $dirPathCodeRootOutsLocal|grep $branchName |grep -v "userdebug"))
        [[ -z "$dirPathOutList" ]] && ftEcho -e "未找到\n分支[$branchName]对应的out" && return $resultFail

        local itemCount=${#dirPathOutList[@]}
        local dirNameOutTraget=$dirPathOutList
        if (( $itemCount>1 ));then
            ftEcho -s 对应分支对应多个out,请选择
            local index=0
            for item in ${dirPathOutList[@]} ; do
                printf "%-4s %-4s\n" [$index] $item
                ((index+=1))
            done

            local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
            ftEcho -r  "请输入对应的序号(回车默认0):"
            read -n $length tIndex &&echo
            #设定默认值
            [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
            (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
            dirNameOutTraget=${dirPathOutList[$tIndex]}
        fi

        local dirPathOutTragetLocal="${dirPathCodeRootOutsLocal}/${dirNameOutTraget}"
        local dirPathOutTragetReal="$(readlink -f ${dirPathOutTragetLocal})"
        [[ -n "$dirPathOutTragetReal" ]] && if [[ "${dirPathOutTragetReal}" != "${dirPathOutTragetLocal}" ]]; then
            local dirPathCodeReal=$(dirname $(dirname ${dirPathOutTragetReal}))/alps
            [ ! -d "$dirPathCodeReal" ] && mkdir -p $dirPathCodeReal
            local dirPathOutReal="${dirPathCodeReal}/out"
            mv "${dirPathOutTragetReal}" "${dirPathOutReal}"&&
            ftEcho -s "移动 ${dirPathOutTragetReal}\n 到  ${dirPathOutReal}"
            rm "${dirPathOutTragetLocal}"
            ln -s "${dirPathOutReal}" "${dirPathOutLocal}"
            return
        fi

        mv "${dirPathOutTragetLocal}" "${dirPathOutLocal}"&&
        ftEcho -s "移动 ${dirPathOutTragetLocal}\n 到  ${dirPathOutLocal}"
        return
    fi

    local dirPathOutReal=$(readlink -f ${dirPathOutLocal})
    local dirPathCodeRootOutsReal=$(dirname $(dirname ${dirPathOutReal}))/${dirNameCodeRootOuts}
    [ ! -d "$dirPathCodeRootOutsReal" ] && mkdir -p $dirPathCodeRootOutsReal
    local dirPathOutBranchVersionReal=${dirPathCodeRootOutsReal}/${dirNameBranchVersion}

    if [ ! -d "$dirPathOutBranchVersionReal" ];then
        [[ ! -d "$dirPathOutReal" ]] && ftEcho -e "out 不存在" && return $resultFail
        if [[ ! -d "$dirPathOut" ]]; then
             ftEcho -e "out 不完整"
             dirNameBranchVersion=${dirNameBranchVersion}____section
        fi

        local fileNameGitLogInfo=git.log
        local filePathGitLogInfo=${dirPathOutReal}/${fileNameGitLogInfo}
        [[ ! -f $filePathGitLogInfo ]] && touch $filePathGitLogInfo
        echo -e "

======================================================================================================
$dirNameBranchVersion
======================================================================================================
$(ftGitLogShell  -n 20 -c "%h  %s")" >> $filePathGitLogInfo
        mv ${dirPathOutReal}/ $dirPathOutBranchVersionReal &&
        ftEcho -s "移动 $dirPathOutReal \n到  ${dirPathCodeRootOutsReal}/${dirNameBranchVersion}"
        [[ -n "$dirPathOutReal" ]] && if [[ "${dirPathOutReal}" != "${dirPathOutLocal}" ]]; then
            ln -sf "${dirPathCodeRootOutsReal}/${dirNameBranchVersion}" "${dirPathCodeRootOutsLocal}/${dirNameBranchVersion}"
            rm "${dirPathOutLocal}"
        fi
    else
        ftEcho -ex 存在相同out
    fi
}

ftAutoUpload()
{
    local ftEffect=文件[夹]上传服务器
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    依赖缺失,请使用下面命令安装
#    sudo add-apt-repository ppa:pi-rho/security && sudo apt-get update
#    sudo apt-get install sshpass pigz pv nmap
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftAutoUpload 源存放目录 服务器地址
#
#    ftAutoUpload xxx xxx.xxx.xxx.xxx
#========================================================="; return ;;
    * ) break;;esac;done

    #环境校验
     [[ -z $(which nmap) ]]|| [[ -z $(which sshpass) ]]|| [[ -z $(which pigz) ]]|| [[ -z $(which pv) ]] && ftAutoUpload --rely && return $resultFail
    #解参验耦
    local dirPathContentUploadSource=$1 serverIp=$2
    local valCount=2 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathContentUploadSource" ] && errorContent="${errorContent}\\n上传源存放目录不存在:dirPathContentUploadSource=$dirPathContentUploadSource"
    if [ -z "$serverIp" ];then
        errorContent="${errorContent}\\n 这个东西送到哪都没说:serverIp=$serverIp"
    else
        if [ "$serverIp" = "$(/sbin/ifconfig -a|grep inet|grep -v 127.0.0.1|grep -v inet6 |grep 192.168.|awk '{print $2}'|tr -d "addr:" |tr -d "地址")" ];then
            errorContent="${errorContent}\\n 目标服务器指向本机，请确认配置:serverIp=$serverIp"
        else
            local tagName=serverConfig_${serverIp}
            local userName=$(ftXbGetValue $tagName userName)
            local userPassword=$(ftXbGetValue $tagName userPassword)
            local dirPathServerStore=$(ftXbGetValue $tagName dirPathServerStore)
            local dirNameServerStore=$(ftXbGetValue serverConfigDef softwareStoreDirName)

            [ -z "$userName" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]用户名获取失败"
            [ -z "$userPassword" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]密码获取失败"
            [ -z "$dirPathServerStore" ] && errorContent="${errorContent}\\n 服务器[${serverIp}]目标路径获取失败"
        fi
    fi
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoUpload -h && return $resultFail
    #实现主体

    ftEcho -s "\n========================\n开始上传文件:\n  ${dirPathContentUploadSource}\n服务器路径:\n  ${serverIp}$dirPathServerStore\n========================\n"

    local serverProtInfo="$(nmap $serverIp)"
    if [[ -z $(echo ${serverProtInfo[@]}|grep ssh) ]] && [[ -n $(echo ${serverProtInfo[@]}|grep 445) ]]; then #使用smb协议
        local dirPathServerLocalBase=$(ftXbGetValue $tagName dirPathPackageLocal)
        if ! mountpoint -q $dirPathServerLocalBase; then
            #ftEcho -e "当前目录未挂载服务器共享目录:\n${dirPathUploadLocal}" && return
            ftEcho -s "未挂载SMB服务器共享目录到本地,将使用SMB协议在线传输"
            local targetName=$(basename $dirPathContentUploadSource)
            local dirPathServer=${dirNameServerStore}/${targetName}
            smbclient //${serverIp}/${dirPathMoule}  -U $userName%$pasword<< EOF
                mkdir ${dirPathServer}
                put $dirPathContentUploadSource ${dirPathServer}
EOF
        else
            local key="智能机软件"
            cp -r -b -S _old -v $key $(echo $dirPathServerLocalBase | sed -e "s:/$key::g")
        fi
    else #使用ssh协议
        # 自动添加旧软件的TAG
        local dirPathServerLocalBase=$(ftXbGetValue $tagName dirPathPackageLocal)
        if [[ -n "$dirPathServerLocalBase" ]]; then
            local dirPathServerLocal=${dirPathServerLocalBase}/${dirPathContentUploadSource}
            if [[ -d $dirPathServerLocal ]] && [[ -n "$ANDROID_BUILD_TOP" ]]; then
                    local versionPath=$(dirname $dirPathServerLocal)
                    local versionName=$(basename $dirPathServerLocal)

                    ls $versionPath | while read line;do
                        if [[  ${line//$versionName} != $line ]]; then
                            local dirPath=${versionPath}/${line}
                            local dirPath_old=${dirPath}_old
                            [[ -d "$dirPath_old" ]] && dirPath_old=${dirPath_old}_old
                            mv $dirPath $dirPath_old
                        fi
                    done
            fi
        fi

        local dirPathLocal=$(pwd)
        local packageSize=$(du -sk $dirPathContentUploadSource | cut -f1)k
        local dirNameContentUploadSource=$(basename $dirPathContentUploadSource)
        dirPathContentUploadSource=$(dirname $dirPathContentUploadSource)

        cd $dirPathContentUploadSource
        mkdir ${dirNameServerStore}
        mv ${dirPathContentUploadSource}/${dirNameContentUploadSource} ${dirPathContentUploadSource}/${dirNameServerStore}
        # tar -cv  ${dirPathContentUploadSource%%/*}| pv --size $packageSize -p --timer --rate --bytes| pigz -1|sshpass -p $userPassword ssh $userName@$serverIp "gzip -d |tar -xPC $dirPathServerStore"
        tar -cv  ${dirNameServerStore}/| pv --size $packageSize -p --timer --rate --bytes| pigz -1|sshpass -p $userPassword ssh $userName@$serverIp "gzip -d |tar -xPC ${dirPathServerStore}"

        mv ${dirNameServerStore}/${dirNameContentUploadSource} ${dirNameContentUploadSource} && rm -rf ${dirNameServerStore}
        cd $dirPathLocal

    fi

    ftEcho -s "上传结束"
}

complete -W "-a -h --help" ftAutoPacket
ftAutoPacket()
{
    local ftEffect=基于android的out生成版本软件包
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isClean isReadMe isUpload isPacket isMove isCopy isSpecial isBale
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftClearTail $dirPathLocal ;ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftAutoPacket -y #免确认自动清理out/packet
#    ftAutoPacket -u #上传到服务器
#    ftAutoPacket -r #创建版本说明相关文档
#    ftAutoPacket -p #生成软件压缩包,添加MD5信息,整理包结构
#    ftAutoPacket -a #默认启动全部流程
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a ) isClean=true
              isReadMe=true
              isUpload=true
              isPacket=true
              isBale=true ;;
        -y ) isClean=true ;;
        -u ) isUpload=true ;;
        -r ) isReadMe=true ;;
        -p ) isPacket=true
              isReadMe=true
              isBale=true ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #解参验耦
    ftAutoInitEnv
    if [ -z "$ANDROID_BUILD_TOP" ]\
            ||[ -z "$TARGET_PRODUCT" ]\
            ||[ -z "$ANDROID_PRODUCT_OUT" ];then
        if [[ -f "ftAutoPacket" ]];then
            ./ftAutoPacket
            return
        fi
        ftAutoPacket --env
        return
    fi
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    local dirPathLocal=$dirPathCode \
            dirNameVersionSoftware=packet \
            buildType=$AutoEnv_buildType
    local dirPathVersionSoftware=${dirPathCode}/out/${dirNameVersionSoftware}
    local editType=$1 valCount=1 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ ! -d "$dirPathOut" ] && errorContent="${errorContent}\\n[工程out目录不存在]dirPathOut=$dirPathOut"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoPacket -h && return $resultFail

    #实现主体
    if [[ -d "$dirPathVersionSoftware" ]]; then

            if [[ -n "$isClean" ]]; then
                rm  -rf $dirPathVersionSoftware
                ftEcho -s "删除旧的软件包"
            fi

            if [[ -z "$isUpload" ]]; then
                  while true; do
                        ftEcho -y "有旧的软件包  ${dirPathVersionSoftware}\n是否删除(回车默认y)"
                        read -n 1 sel ;[ -z "${sel}" ] && sel=y
                        case "$sel" in
                            y | Y ) rm  -rf $dirPathVersionSoftware
                                       break ;;
                            n | q ) isMove=true; break ;;
                            * ) ftEcho -e 错误的选择：$sel
                                echo "输入n，q，离开";;
                        esac
                done
                echo
            fi

            if [[ -n "$isMove" ]]; then
                local keyDirNameFlag="_old"
                echo
                ls ${dirPathVersionSoftware}* | while read dirPath;do
                       dirPath=${dirPath%?}
                       [[ -z ${dirPath} ]] && continue
                       [[ ${dirPath} == *${keyDirNameFlag}* ]] && continue

                        local dirPathLastTime=$(stat -c %Y $dirPath)
                        local dirPathFormartDate=$(date '+[%Y%m%d_%H%M%S]' -d @$dirPathLastTime)
                        local dirPath_old="${dirPath}${keyDirNameFlag}_${dirPathFormartDate}"
                       mv ${dirPath} ${dirPath_old}
                       ftEcho -s "旧软件包已移至${dirPath_old}"
                done
            fi
    fi

    [[ ! -d "$dirPathVersionSoftware" ]] && mkdir $dirPathVersionSoftware
    cd $dirPathVersionSoftware && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    if [[ $AutoEnv_mnufacturers = "mtk" ]]; then
            local deviceName=$(basename $ANDROID_PRODUCT_OUT)

            #版本号特殊处理
            local dirNameVeriosionBase=${AutoEnv_versionName}
            #非user版本标记编译类型
            [ "$AutoEnv_buildType" != "user" ] && [[ -z "$(echo ${dirNameVeriosionBase} |grep ${AutoEnv_buildType})" ]] && dirNameVeriosionBase=${buildType}____${dirNameVeriosionBase}
            #软件版本的日期与当前时间不一致就设定编译时间
            arr=(${AutoEnv_versionName//_/ })
            length=${#arr[@]}
            ((length-=1))
            local versionNameDate=${arr[$length]}
            [[ $versionNameDate =~ "." ]] && versionNameDate=${versionNameDate%.*}
            # system.img文件最新修改时间
            if [[ -f "${dirPathOut}/system.img" ]]; then
                    local fileChangeTime=$(stat -c "%y" ${dirPathOut}/system.img|awk '{print $1}'|sed s/-//g)
                    [[ -n "$fileChangeTime" ]] && [ "$versionNameDate" != "${fileChangeTime}" ] && export AutoEnv_SoftwareVersion_BuildTime=buildtime____${fileChangeTime}
            fi

            if [[ -n "$isSpecial" ]]; then
                ftEcho -r $"请输入版本: "${dirNameVeriosionBase}"\n相应的说明[回车默认为常规]:"
                read tag
                tag=${tag:-'常规'}
                dirNameVeriosionBase=${tag}____${dirNameVeriosionBase}
            fi

            local isAddToolReadme=
            local dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${dirNameVeriosionBase}

            # 生成本地软件包
            if [[ -n "$isPacket" ]]; then
                    mkdir -p $dirPathVersionSoftwareVersion
                    local fileSizeCheckMax=536870912 #512*1024*1024

                    ftEcho -s "\n========================\n包名: ${dirNameVeriosionBase}\n路径: ${dirPathVersionSoftwareVersion}\n========================\n"
                    #packages
                    ftEcho -s "创建 packages"
                    local tagName="xbashAOSPConfigSoftwarePackageFileLIst"
                    local dirNamePackage="packages"
                    local filePathSystemImage=${dirPathOut}/system.img
                    local dirPathPackage=${dirPathVersionSoftwareVersion}/${dirNamePackage}
                   local fileList= #($(ftXbGetValue $tagName ${TARGET_PRODUCT}))
                    if [[ -z "$fileList" ]];then
                        ftEcho -e "未找到 [${TARGET_PRODUCT}] 对应的独立配置,将默认复制全部文件"
                        while read item ;do
                            [[ ! -f "${dirPathOut}/${item}" ]] && continue || fileList=(${fileList[@]} ${item})
                        done < <(echo "$(ls ${dirPathOut})")
                    fi
                    if [[ -f "$filePathSystemImage" ]]; then
                        if mkdir -p $dirPathPackage; then
                            for file in ${fileList[@]}; do
                                local filePath=${dirPathOut}/${file}
                                [[ ! -f "$filePath" ]] && ftEcho -e "找不到 : ${filePath}" && ftClearTail $dirPathLocal && return $resultFail
                                local fileSize=$(stat -c "%s" $filePath)
                                if (( $fileSize >= $fileSizeCheckMax )) \
                                    && [[ "${file}" != "system.img" ]] \
                                    && [[ "${file}" != "super.img" ]]; then
                                            ftEcho -yn "${file}文件过大,是否放弃(回车默认y)" ; read -n 1 sel
                                            [ -z "${sel}" ] && sel=y
                                            [[ "${sel}" != "y" ]] && echo && ftEcho -e "放弃 ${file}"&& continue
                                fi
                                printf "%-2s %-30s\n" 复制 $file
                                cp -r -f  $filePath $dirPathPackage
                            done
                        else
                            ftEcho -e "packages创建失败" && ftClearTail $dirPathLocal && return $resultFail
                        fi
                    else
                        ftEcho -e "软件包不完整,请确认\n不存在  $filePathSystemImage" && ftClearTail $dirPathLocal && return $resultFail
                    fi

                    # database
                    ftEcho -s "创建 database"
                    tagName=xbashAOSPConfigSoftwareDataBaseFileLIst
                    local dirNamePackageDataBase="database"
                    local dataBaseFileList dataBaseFileListTemp
                    local dirPathPackageDataBase=${dirPathVersionSoftwareVersion}/${dirNamePackageDataBase}
                    local apdbDirPathList=($(ftXbGetValue $tagName apdbDirPathList))
                    local mddbDirPathList=($(ftXbGetValue $tagName mddbDirPathList))
                    for item in ${apdbDirPathList[@]} ; do
                            item=$(ftPath $item)
                            local itemPathRoot=${dirPathOut}/${item}
                            [[ ! -d "${itemPathRoot}" ]] && ftEcho -e "未找到database的apdb的相关项: ${item}" && continue
                            while read fileName ;do
                                [[ -z $(echo "${fileName}"|grep '^APDB') ]] && [[ -z $(echo "${fileName}"|grep '^_APDB') ]] && continue
                                local filePath=${item}/${fileName}
                                [[ -f "${itemPathRoot}/${fileName}" ]] && dataBaseFileList=(${dataBaseFileList[@]} ${filePath})
                            done < <(echo "$(ls ${itemPathRoot})")
                    done

                    for item in ${mddbDirPathList[@]} ; do
                            item=$(ftPath $item)
                            local itemPathRoot=${dirPathOut}/${item}
                            [[ ! -d "${itemPathRoot}" ]] && ftEcho -e "未找到database的mddb的相关项: ${item}" && continue
                            while read fileName ;do
                                local filePath=${item}/${fileName}
                                [[ -f "${itemPathRoot}/${fileName}" ]] && dataBaseFileList=(${dataBaseFileList[@]} ${filePath})
                            done < <(echo "$(ls ${itemPathRoot})")
                    done

                    [[ -n "$AutoEnv_ModemPath" ]] && cd ${dirPathCode} && while read filePath ;do
                                [[ -f "${filePath}" ]] && dataBaseFileList=(${dataBaseFileList[@]} ${filePath})
                     done < <(echo "$(find ${AutoEnv_ModemPath} -type f -name MDDB* -o -name Db*)") && cd ${dirPathVersionSoftware}

                    if [[ -n "$dataBaseFileList" ]];then
                        if mkdir -p $dirPathPackageDataBase; then
                            for filePath in ${dataBaseFileList[@]}; do
                                 [[ ! -f "$filePath" ]] && [[ -f "${dirPathOut}/${filePath}" ]] && filePath=${dirPathOut}/${filePath}
                                 [[ ! -f "$filePath" ]] && [[ -f "${dirPathCode}/${filePath}" ]] && filePath=${dirPathCode}/${filePath}
                                 [[ ! -f "$filePath" ]] && ftEcho -e "找不到 : ${filePath}" && continue

                                fileName=$(basename $filePath)
                                printf "%-2s %-30s\n" 复制 $(echo $fileName | sed "s ${dirPathOut}  ")
                                cp -r -f  $filePath $dirPathPackageDataBase
                            done
                        else
                            ftEcho -e "database 创建失败,无法创建${dirPathPackageDataBase}"  && ftClearTail $dirPathLocal && return $resultFail
                        fi
                    else
                        ftEcho -e "database 创建失败" && ftClearTail $dirPathLocal && return $resultFail
                    fi

                    # otaPackages
                    local fileNameOtaPackage="target_files-package.zip"
                    local dirNamePackageOtaPackages="otaPackages"
                    local dirPathPackageOtaPackages=${dirPathVersionSoftwareVersion}/${dirNamePackageOtaPackages}
                    local filePathOtaPackage=${dirPathPackage}/${fileNameOtaPackage}
                    local fileSizeMini=104857600 #100*1024*1024
                    if [[ -f ${filePathOtaPackage} ]]; then
                        local fileSize=$(stat -c "%s" $filePathOtaPackage)
                        if (( $fileSizeMini < $fileSize )); then
                            ftEcho -s "创建 otaPackages"
                            printf "%-2s %-30s\n" 移动 $fileNameOtaPackage
                            [[ ! -d "$dirPathPackageOtaPackages" ]] && mkdir -p $dirPathPackageOtaPackages
                            mv ${filePathOtaPackage} ${dirPathPackageOtaPackages}
                        fi
                    fi

                    #tools
                    tagName="xbashAOSPConfigMTKSoftwareDownloadToool"
                    local dirNamePackageTools="tools"
                    local dirPathPackageTools=${dirPathVersionSoftwareVersion}/${dirNamePackageTools}
                    local filePathTools=($(ftXbGetValue $tagName filePath))
                    if [[ -n ${filePathTools} ]]; then
                        ftEcho -s "创建 tools"

                        [[ ! -d $dirPathPackageTools ]] && mkdir -p $dirPathPackageTools
                        for filePath in ${filePathTools[@]}; do
                            [[ ! -f "$filePath" ]] && ftEcho -e "找不到 : ${filePath}" && ftClearTail $dirPathLocal \
                            && isAddToolReadme="-dt" && continue

                             printf "%-2s %-30s\n" 复制 $filePath
                             cp -r -f  $filePath $dirPathPackageTools
                        done
                    else
                        ftEcho -e "tools包配置错误,软件包可能不完整"
                    fi
            fi

            # 创建版本说明/客户说明
            if [[ -n "$isReadMe" ]]; then
                ftEcho -s "创建 版本说明相关文档" && ftAutoCreateReadMeBySoftwareVersion "${isAddToolReadme}" -t ${dirPathVersionSoftwareVersion}
                ftEcho -y "是否更新版本说明 [回车更新]" ; read -n 1 sel ; [ -z "${sel}" ] && sel=y
                [[ "${sel}" = "y" ]] &&  XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $AutoEnv_filePathReleaseNotes $AutoEnv_filePathCustomerDescription || echo
             fi

            # 生成软件压缩包,添加MD5信息,整理包结构
            if [[ -n "$isBale" ]] ;then
                ftEcho -s "创建 软件压缩包"
                local dirPathSoftwareTemp=$(pwd)
                local fileNamePackage=${dirNameVeriosionBase}.tgz
                # local fileNamePackage=$(basename ${dirPathVersionSoftwareVersion}).tgz
                cd ${dirPathVersionSoftware}
                tar cvPf - ${dirNameVeriosionBase} | pigz -p $(grep 'processor' /proc/cpuinfo | sort -u | wc -l) > ${fileNamePackage}
                cd ${dirPathSoftwareTemp}

                #记录版本MD5
                ftMD5 -a ${dirPathVersionSoftware}/${fileNamePackage}
                local versionPacketMd5Base="版本MD5："
                local versionPacketMd5Now="${versionPacketMd5Base}${ftMD5Info}"
                sed -i "s:$versionPacketMd5Base:$versionPacketMd5Now:g" $AutoEnv_filePathReleaseNotes \
                || ftEcho -e "版本说明中的MD5信息写入失败"

                #修改版本包目录结构
                [[ -f ${dirPathVersionSoftware}/${fileNameOtaPackage} ]] && \
                mv ${dirPathVersionSoftware}/${fileNameOtaPackage} ${dirPathVersionSoftwareVersion}
                mv ${dirPathVersionSoftware}/${fileNamePackage} ${dirPathVersionSoftwareVersion}
                mv ${AutoEnv_filePathReleaseNotes} ${dirPathVersionSoftwareVersion}
                mv ${AutoEnv_filePathBasicHardwareConfig} ${dirPathVersionSoftwareVersion}
                rm -rf ${AutoEnv_filePathCustomerDescription}
                rm -rf ${dirPathPackage}
                rm -rf ${dirPathPackageDataBase}
                rm -rf ${dirPathPackageOtaPackages}
                rm -rf ${dirPathPackageTools}

                #软件包临时文件清理
                ftEcho -s "软件打包结束"
            fi

            #上传服务器
            if [[ -n "$isUpload" ]]; then
                local serverIpAdress=$(ftXbGetValue serverConfigDef softwareServerIp)
                ftAutoUpload ${dirPathVersionSoftwareVersion}/${dirNameVeriosionBase} ${serverIpAdress:-'10.168.1.253'}
            fi
    elif [[ $AutoEnv_mnufacturers = "sprd" ]]; then
            if [ "$TARGET_PRODUCT" != "sp7731c_1h10_32v4_oversea" ];then
                ftEcho -ea " ${ftEffect} 缺少平台${AutoEnv_mnufacturers}的项目${TARGET_PRODUCT}的配置\
                \n请查看下面说明:"
                ftAutoPacket -h
                return $resultFail
            fi
            local dirPathNormalBin=$dirPathOut
            local dirPathLogo=${dirPathCode%/*}/res
            local versionName=$AutoEnv_versionName
            local dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${versionName}
            local dirPathModemBin=${dirPathCode%/*}/res/packet_modem
            local softwareVersion=MocorDroid6.0_Trunk_16b_rls1_W16.29.2
            local filePathPacketScript=${rDirPathXbashModuleAuto}/packet_7731c.module

            [[ -n "$(cat $versionName|grep 451)" ]] && dirPathModemBin=${dirPathModemBin}2

            if [ ! -f "$filePathPacketScript" ];then
                    ftEcho -ea "[${ftEffect}]的参数错误 \
                       找不到 [sprd的打包工具]filePathPacketScript=$filePathPacketScript \
                        请查看下面说明:"
                    ftAutoPacket -h
                    return $resultFail
            fi

            [[ -n "$buildType" ]] && [ $buildType != "user" ] && versionName=${versionName}____${buildType}

            local dirPathVersionSoftwareLocal="智能机软件"

            dirPathVersionSoftwareVersion=${dirPathVersionSoftware}/${versionName}
            mkdir -p $dirPathVersionSoftwareVersion

            # 生成软件包
            if [[ -n "$isPacket" ]]; then
                   ftEcho -s "开始生成 ${versionName}.pac\n"
                    cd $dirPathVersionSoftwareVersion && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

                    /usr/bin/perl $filePathPacketScript \
                        $versionName.pac \
                        SC77xx \
                        ${versionName}\
                        ${dirPathNormalBin}/SC7720_UMS.xml \
                        ${dirPathNormalBin}/fdl1.bin \
                        ${dirPathNormalBin}/fdl2.bin \
                        ${dirPathModemBin}/nvitem.bin \
                        ${dirPathModemBin}/nvitem_wcn.bin \
                        ${dirPathNormalBin}/prodnv.img \
                        ${dirPathNormalBin}/u-boot-spl-16k.bin \
                        ${dirPathModemBin}/SC7702_pike_modem_AndroidM.dat \
                        ${dirPathModemBin}/DSP_DM_G2.bin \
                        ${dirPathModemBin}/SC8800G_pike_wcn_dts_modem.bin \
                        ${dirPathNormalBin}/boot.img \
                        ${dirPathNormalBin}/recovery.img \
                        ${dirPathNormalBin}/system.img \
                        ${dirPathNormalBin}/userdata.img \
                        ${dirPathLogo}/logo.bmp \
                        ${dirPathNormalBin}/cache.img \
                        ${dirPathNormalBin}/sysinfo.img \
                        ${dirPathNormalBin}/u-boot.bin \
                        ${dirPathNormalBin}/persist.img&&
                    ftEcho -s 生成7731c使用的pac[${dirPathVersionSoftwareVersion}/${versionName}.pac]
                    cd $dirPathLocal && dirPathLocal=
            fi
            # 生成软件压缩包
            ftEcho -s "创建 压缩packages"
            local fileNamePackage=$(basename ${dirPathVersionSoftwareVersion}).tgz
            tar --use-compress-program=pigz -xf $fileNamePackage ${dirPathVersionSoftwareVersion}

            # 生成说明文件
            [[ -n "$isReadMe" ]] && ftAutoCreateReadMeBySoftwareVersion -t $dirPathVersionSoftwareVersion

            #上传服务器
            [[ -n "$isUpload" ]] && ftAutoUpload $dirPathVersionSoftwareLocal 192.168.1.75

    else
            ftEcho -ea "${ftEffect} 没有平台${AutoEnv_mnufacturers}的配置\n请查看下面说明:"
            ftAutoPacket -h
            return $resultFail
    fi
    cd $dirPathLocal
    trap SIGINT
}

complete -W "-h -d --help" -A file ftAutoCreateReadMeBySoftwareVersion
ftAutoCreateReadMeBySoftwareVersion()
{
    local ftEffect=创建软件版本相关客户说明和版本说明
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isAddToolsConnnect=true
    local valCount=2 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftAutoCreateReadMeBySoftwareVersion -t [dir_path_pac_res] #生成7731c使用的pac的目录，和生成所需的文件存放的目录
#    ftAutoCreateReadMeBySoftwareVersion -t out/pac
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    工具依赖包 unix2dos #sudo apt-get install tofrodos
#========================================================="; return ;;
    --env ) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -dt ) isAddToolsConnnect=
            ;;
        -t ) dirPathVersionSoftware="${arg2}"
            ;;
    * ) break;;esac;done

    #环境校验
    [[ -z $(which todos) ]]|| [[ -z $(which fromdos) ]] && ftAutoCreateReadMeBySoftwareVersion --rely && return $resultFail
    #解参验耦
    ftAutoInitEnv
    [ -z "$ANDROID_BUILD_TOP" ]||[ -z "$ANDROID_PRODUCT_OUT" ] && ftAutoCreateReadMeBySoftwareVersion --env && return $resultFail
    local dirPathCode=$ANDROID_BUILD_TOP dirPathOut=$ANDROID_PRODUCT_OUT
    [[ -z "$dirPathVersionSoftware" ]] && dirPathVersionSoftware=${dirPathOut}/${AutoEnv_versionName}
    dirPathVersionSoftware=$(ftPath $dirPathVersionSoftware)
    #(( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathCode" ] && errorContent="${errorContent}\\n[工程根目录不存在]dirPathCode=$dirPathCode"
    [ ! -d "$dirPathOut" ] && errorContent="${errorContent}\\n[工程out目录不存在]dirPathOut=$dirPathOut"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoCreateReadMeBySoftwareVersion -h && return $resultFail

    #实现主体
    local dirPathLocal=${PWD} fileNameReadMeTemplate=客户说明.txt fileNameChangeListTemplate=版本说明.txt
    local filePathReadMeTemplate=${dirPathVersionSoftware}/${fileNameReadMeTemplate}
    local filePathChangeListTemplate=$(dirname $dirPathVersionSoftware)/${fileNameChangeListTemplate}
    local versionName=$AutoEnv_versionName
    local filePathToolCopyBasicHardwareConfig=${ANDROID_BUILD_TOP}/copyBasicHardwareConfig.sh

    if [[ -f $filePathToolCopyBasicHardwareConfig ]]; then
        export AutoEnv_filePathBasicHardwareConfig=$($filePathToolCopyBasicHardwareConfig ${dirPathVersionSoftware})
    fi

    [ ! -d "$dirPathVersionSoftware" ] && mkdir $dirPathVersionSoftware
    cd $dirPathCode && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    #使用git仓库相关记录
    local gitCommitList=$(ftGitLogShell -nn 20)
    local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')

    if [ $AutoEnv_mnufacturers = "sprd" ];then
            # 暗码清单,动画切换暗码
            local filePathPawInfo=${dirPathCode}/packages/apps/Dialer/src/com/android/dialer/SpecialCharSequenceMgr.java
            if [ -f $filePathPawInfo ];then
                    local key="    private static final String PAW_NUM_INFO ="
                    local pawNumInfo=$(cat $filePathPawInfo|grep "$key")  #获取暗码清单信息
                    pawNumInfo=${pawNumInfo//$key/};
                    pawNumInfo=${pawNumInfo//\";/};
                    pawNumInfo=${pawNumInfo//\"/};
                    pawNumInfo=$(echo $pawNumInfo |sed s/[[:space:]]//g)

                    key="    private static final String LOGO_CHANGE ="
                    local changLogoNumInfo=$(cat $filePathPawInfo|grep "$key")  #动画切换暗码信息
                    changLogoNumInfo=${changLogoNumInfo//$key/};
                    changLogoNumInfo=${changLogoNumInfo//\";/};
                    changLogoNumInfo=${changLogoNumInfo//\"/};
                    changLogoNumInfo=$(echo $changLogoNumInfo |sed s/[[:space:]]//g)
            else
                    ftEcho -e "[工程暗码配置文件不存在:]\n$filePathPawInfo"
            fi

            #摄像头配置相关
            local filePathCameraConfig=${dirPathCode}/${AutoEnv_deviceDirPath}/BoardConfig.mk
            if [ -f $filePathCameraConfig ];then
                    local keyType="LZ_CONFIG_CAMERA_TYPE := "
                    local keySizeBack="CAMERA_SUPPORT_SIZE := "
                    local keySizeFront="FRONT_CAMERA_SUPPORT_SIZE := "

                    local cameraTypeInfo=$(cat $filePathCameraConfig|grep "$keyType")
                    local cameraSizeBackMax=$(cat $filePathCameraConfig|grep "$keySizeBack")
                    local cameraSizeFrontMax=$(cat $filePathCameraConfig|grep "$keySizeFront")

                    cameraTypeInfo=${cameraTypeInfo//$keyType/};
                    cameraSizeFrontMax=${cameraSizeFrontMax//$keySizeFront/};

                    cameraSizeBackMax=${cameraSizeBackMax//${keySizeFront}$cameraSizeFrontMax/};
                    cameraSizeBackMax=${cameraSizeBackMax//$keySizeBack/};

                    cameraTypeInfo=$(echo $cameraTypeInfo |sed s/[[:space:]]//g)
                    cameraSizeFrontMax=$(echo $cameraSizeFrontMax |sed s/[[:space:]]//g)
                    cameraSizeBackMax=$(echo $cameraSizeBackMax |sed s/[[:space:]]//g)

                    sizeFcameraList=(real 2M 5M 8M)
                    sizeBcameraList=(real 2M 5M 8M 12M)
                    local cameraSizeFrontDefault=${sizeFcameraList[LZ_FCAM]}
                    local cameraSizeBackDefault=${sizeBcameraList[LZ_BCAM]}
            else
                    ftEcho -e "[相机配置文件不存在，获取失败]\n$filePathCameraConfig"
            fi

            #修改记录头部
            local enterLine="\n"
            local content="当前版本：$versionName"${enterLine}
            content=${content}${enterLine}"说明：$(ftXbGetValue projectSoftwareReadMeInfo recordMeTag)"
            content=${content}${enterLine}"记录创建人：$(ftXbGetValue softwareVersionReadMeInfo projectManager)"
            content=${content}${enterLine}
            content=${content}${enterLine}"摄像头类型：$cameraTypeInfo"
            content=${content}${enterLine}"默认 前/后摄大小：$cameraSizeFrontDefault/$cameraSizeBackDefault"
            content=${content}${enterLine}"真实插值 前/后摄大小：$cameraSizeFrontMax/$cameraSizeBackMax"
            # content=${content}${enterLine}"默认 RAM/ROM：$sizeRam/$sizeRom"
            content=${content}${enterLine}
            content=${content}${enterLine}"暗码清单：$pawNumInfo"
            content=${content}${enterLine}"开关机动画暗码：$changLogoNumInfo"

            #git log 列表
            echo -e "﻿$gitCommitList">$filePathChangeListTemplate
            seq 10 | awk '{printf("    %02d %s\n", NR, $0)}' $filePathChangeListTemplate >${filePathChangeListTemplate}.temp
            local lineNumIndex=($(awk '/\(tag:/{print NR}' ${filePathChangeListTemplate}.temp))
            local item="\    \n\    =========================================================================================================\n"
            [[ -n $lineNumIndex ]] && sed  -i "${lineNumIndex}i ${item}" ${filePathChangeListTemplate}.temp

            # 合并头部和git log 列表
            echo -e ${content}${enterLine}${enterLine}"修改记录："| cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate
            rm ${filePathChangeListTemplate}.temp

            # 转化为windows下面文件格式
            unix2dos $filePathChangeListTemplate

            export AutoEnv_filePathReleaseNotes=$filePathChangeListTemplate

   elif [[ $AutoEnv_mnufacturers = "mtk" ]]; then

            #版本说明
            local enterLine="\n"
            local content="本文件为内部使用，请勿释放给客户"
            content=${content}${enterLine}"$(ftXbGetValue projectSoftwareReadMeInfo recordMeTag)"
            content=${content}${enterLine}
            content=${content}${enterLine}"记录创建人：$(ftXbGetValue projectSoftwareReadMeInfo recordCreator)"
            content=${content}${enterLine}"项目负责人：$(ftXbGetValue projectSoftwareReadMeInfo projectManager)"
            content=${content}${enterLine}"客户对接人：$(ftXbGetValue projectSoftwareReadMeInfo projectManager)"
            content=${content}${enterLine}
            content=${content}${enterLine}"软件路径[公网]："
            content=${content}${enterLine}"    01 百度网盘："
            content=${content}${enterLine}"    链接："
            content=${content}${enterLine}"    提取码："
            content=${content}${enterLine}"    有效期：永久"
            content=${content}${enterLine}
            content=${content}${enterLine}"当前版本：$versionName"
            content=${content}${enterLine}"基础版本："
            content=${content}${enterLine}"版本MD5："
            if [[ -n "${branchNameNow}" ]]; then
                content=${content}${enterLine}"版本CommitHash：$(ftGitLogShell -n 1 -c "%h") "
                content=${content}${enterLine}"分支名[真实]：${branchNameNow}"
                if [[ "${branchNameNow}" != "master" ]]; then
                    content=${content}${enterLine}"父分支名[真实]：$(ftGitgetParentBranch -m -b ${branchNameNow})"
                fi
            else
                content=${content}${enterLine}"分支名："
            fi
            content=${content}${enterLine}"分支名[目录]：alps"
            content=${content}${enterLine}"客户名："
            content=${content}${enterLine}
            content=${content}${enterLine}"说明："
            content=${content}${enterLine}"\t01 "
            content=${content}${enterLine}
            content=${content}${enterLine}"修改记录："
            content=${content}${enterLine}"\t01 "
            content=${content}${enterLine}
            #git log 列表
            echo -e "﻿$gitCommitList">$filePathChangeListTemplate
            seq 10 | awk '{printf("    %02d %s\n", NR, $0)}' $filePathChangeListTemplate >${filePathChangeListTemplate}.temp
            local lineNumIndex=($(awk '/\(tag:/{print NR}' ${filePathChangeListTemplate}.temp))
            local item="\    \n\    =========================================================================================================\n"
            [[ -n $lineNumIndex ]] && sed  -i "${lineNumIndex}i ${item}" ${filePathChangeListTemplate}.temp

            # 合并头部和git log 列表
            echo -e ${content}${enterLine}${enterLine}"git commit 记录："| cat - ${filePathChangeListTemplate}.temp >$filePathChangeListTemplate
            rm ${filePathChangeListTemplate}.temp

            #客户说明
            local lineNumCR=1
            content="$(ftXbGetValue projectSoftwareReadMeInfo recordMeTag)"
            content=${content}${enterLine}"记录创建人：$(ftXbGetValue projectSoftwareReadMeInfo recordCreator)"
            content=${content}${enterLine}
            content=${content}${enterLine}"当前版本：$versionName"
            content=${content}${enterLine}"基础版本："
            content=${content}${enterLine}
            content=${content}${enterLine}"说明："
            if [[ -n "$isAddToolsConnnect" ]]; then
                content=${content}${enterLine}"\t0${lineNumCR} $(ftXbGetValue projectSoftwareReadMeInfo softwareDescriptionMtkTools)"; ((lineNumCR+=1))
            fi
            content=${content}${enterLine}"\t0${lineNumCR} $(ftXbGetValue projectSoftwareReadMeInfo softwareDescriptionMtkPackages)" ; ((lineNumCR+=1))
            content=${content}${enterLine}"\t0${lineNumCR} $(ftXbGetValue projectSoftwareReadMeInfo softwareDescriptionMtkDatabase)" ; lineNumCR=1
            content=${content}${enterLine}
            content=${content}${enterLine}"修改记录："
            content=${content}${enterLine}"\t0${lineNumCR} "
            echo -e ${content}${enterLine}${enterLine} >$filePathReadMeTemplate

            # 转化为windows下面文件格式
            unix2dos $filePathChangeListTemplate
            unix2dos $filePathReadMeTemplate

            export AutoEnv_filePathReleaseNotes=$filePathChangeListTemplate
            export AutoEnv_filePathCustomerDescription=$filePathReadMeTemplate
    fi
    cd $dirPathLocal
    trap  SIGINT
}

complete -W "-rc -rt -e -p -h --help -d" ftAutoTest
ftAutoTest()
{
    local ftEffect=AndroidMonkey测试
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local editType=$1
    local eventCountDef=$(( 100 * 100 *100 ))
    local eventCount=$eventCountDef dirPathLogRoot=~/log
    local packageNameList packageBlackNameList packageWhiteNameList throttleLong deviceIdTargetForce
    local arg  arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ;eval arg2=\${$((i+1))}
        case "${arg}" in
        # 说明参数解析部分==============
     --rely) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    adb当前无法正常使用， 请确认 Android SDK 配置是否正确
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    #-xx 为独立参数类型标识,不可拆分
#    #参数之间没有先后约束
#
#    ftAutoTest -r #重置环境变量
#
#    指定设备id , 和-r同时使用时将-r放前面
#    ftAutoTest -s 设备ID
#
#    测试白名单,允许多个包名,和黑名单互斥
#    ftAutoTest -p \"com.xx com.yy.zz\"
#
#    测试黑名单,允许多个包名,和白名单互斥
#    ftAutoTest -pb \"com.xx com.yy.zz\"
#
#    log存放路径
#    ftAutoTest -d /home/xxx/xxx
#
#    monkey事件数
#    ftAutoTest -e 2000
#
#    延时[ms]
#    ftAutoTest -t 2000
#========================================================="; return ;;
        # 变量参数解析部分==============
        -r)     export   autoTestDeviceId=                          ;;
        -s)     deviceIdTargetForce=${arg2}; export autoTestDeviceId= ;;
        -p)    packageNameList=${arg2}                            ;;
        -pb)   packageBlackNameList=${arg2}                   ;;
        -d)     dirPathLogRoot=${arg2:-'dirPathLogRoot'}          ;;
        -t)     throttleLong=${arg2}                            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #环境校验
     [[ -z $(which adb) ]] && ftAutoTest --rely && return $resultFail
    #参数校验
    local errorContent
    # (($rebootTimeLong!=$rebootTimeLongDef))&&( ! echo -n $rebootTimeLong | grep -q -e "^[0-9][0-9]*$") && errorContent="${errorContent}\\n[时长必须为数字[单位S]]rebootTimeLong=$rebootTimeLong"
    [[ -n $packageBlackNameList ]] && [[ -n $packageNameList ]] && errorContent="${errorContent}\\n 包限制配置错误1"
    [[ -n "$errorContent" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoTest -h && return $resultFail

    #实现主体

    #adb状态确认
    ftAdbConnect -u ; [[ -z "${autoTestDeviceId}" ]] && return $resultFail
    local deviceId=${autoTestDeviceId}
    ftEcho -s "开始对设备 : [$deviceId] 进行测试"
    local deviceIdTarget=${deviceId}

    local filePathDeviceInfo=/system/build.prop
    local dirPathLogMonkeyBase=${dirPathLogRoot}/monkey
    local dirNameLogMonkey=$deviceIdTarget
    local dirPathLogMonkey=${dirPathLogMonkeyBase}/${dirNameLogMonkey}
    local filePathLogMonkey=${dirPathLogMonkey}/monkey.log
    local filePathLogAdbLogcat=${dirPathLogMonkey}/logcat.log
    local dirPathDevicesTarget="/sdcard"
    local monkeyConfig logcatFlag #="*:E"

    # monkey命令参数配置
    [[ -n "$throttleLong" ]] && monkeyConfig=${monkeyConfig}" --throttle $throttleLong"
    monkeyConfig=${monkeyConfig}" --ignore-crashes --ignore-timeouts --ignore-security-exceptions"
    if [[ -n $packageBlackNameList ]]; then
        local fileNameBlack="monkey.blacklist"
        local filePathBlack="${rDirPathUserHome}/temp/${fileNameBlack}"
        local filePathBlackDevices="${dirPathDevicesTarget}/${fileNameBlack}"
        rm -rf $filePathBlack
        for packageName in ${packageBlackNameList[@]} ; do echo package:${packageName} >> $filePathBlack ;done
        adb -s $deviceId push $filePathBlack $dirPathDevicesTarget && monkeyConfig=${monkeyConfig}" --pkg-blacklist-file ${filePathBlackDevices}"
    fi
    if [[ -n "$packageNameList" ]]; then
        # if ((${#packageNameList[@]}>1)); then
            # local fileNameWhite="monkey.whitelist"
            # local filePathWhite="${rDirPathUserHome}/temp/${fileNameWhite}"
            # local filePathWhiteDevices="${dirPathDevicesTarget}/${fileNameWhite}"
            # rm -rf $filePathWhite
            # for packageName in ${packageWhiteNameList[@]} ; do echo package:${packageName} >> $filePathWhite ;done
            # adb -s $deviceId push $filePathWhite $dirPathDevicesTarget && monkeyConfig=${monkeyConfig}" --pkg-whitelist-file ${filePathWhiteDevices}"

            for packageName in ${packageNameList[@]} ; do monkeyConfig=${monkeyConfig}" -p ${packageName}" ;done
        # else
        #     monkeyConfig=${monkeyConfig}" -p ${packageNameList}"
        # fi
    fi
    monkeyConfig=${monkeyConfig}" -v -v -v"
    monkeyConfig=${monkeyConfig}" ${eventCount}"
    #环境清理
    for folder in $(ls $dirPathLogMonkeyBase); do  [[ ! $folder =~ "done" ]] && rm -rf ${dirPathLogMonkeyBase}/${folder} ;done
    [[ ! -d $dirPathLogMonkey ]] && mkdir -p $dirPathLogMonkey
    adb -s $deviceId logcat -c
    #无效进程清理
    for pid in $(ps -ef |grep adb -s $deviceId |grep logcat |awk '{print $2}'); do kill -9 $pid  ;done
    ftKillApplicationByPackageName monkey > /dev/null
    #记录设备信息
    adb -s $deviceId pull $filePathDeviceInfo $dirPathLogMonkey > /dev/null&& ftEcho -s "设备信息已保存到${dirPathLogMonkey}"
    #开始测试
    local filePathDeviceMonkeyFlag=/sdcard/monkey_test_${deviceIdTarget} #设备进行过monkey测试的标示文件
    adb -s $deviceId shell "echo > $filePathDeviceMonkeyFlag"
    adb -s $deviceId logcat "$logcatFlag" > $filePathLogAdbLogcat &
    echo "monkeyConfig = ${monkeyConfig}"
    adb -s $deviceId shell monkey "${monkeyConfig}" 2>&1 |tee $filePathLogMonkey
    local isMonkeyTestSucess=$( [[ -n "$(grep -n '// Monkey finished' $filePathLogMonkey | tail -n 1)" ]]&&echo true|| echo false )
    #测试状态确认
    local isPulllog=false
    local deviceIdDefault=0123456789ABCDEF
    if [[ "${isMonkeyTestSucess}" = "true" ]];then
        ftEcho -sn "monkey测试>完成"
        isPulllog=true
    else
        sleep 1
        ftEcho -sn "monkey测试>"; ftEcho -en "异常结束"
        sleep 4

        local deviceIdList=($(adb devices |grep -v "List of devices attached" |awk '{print $1}'))
        if [[ -n $(adb devices|grep $deviceId) ]]; then
            ftEcho -s ">设备usb连接不稳定>建议重新测试"
            isPulllog=true
        else
            ftEcho -sn ">设备连接已断开"
            local timeLong=4
            tput sc
            for i in $(seq -w $timeLong -1 1) ; do
                tput rc;tput ed
                ftEcho -sn ">将在${i}秒后开始重新连接设备"
                sleep 1
            done

            [[ -z $(adb devices|grep $deviceIdDefault) ]] && ftEcho -sn ">" && ftEcho -e "设备连接失败,请确认原因" && return $resultFail
            [[ -z $(adb -s $deviceIdDefault shell ls $filePathDeviceMonkeyFlag) ]] && ftEcho -sn ">" && ftEcho -s "连接到新设备,建议重新测试" && return $resultFail

            ftEcho -sn ">" && ftEcho -e "设备在测试过程中已重启"
            isPulllog=true;
        fi
    fi

    # 测试log处理
    [[ "${isPulllog}" = "true" ]] && ftMtkLog --stop --clearn -p $dirPathLogMonkey
    [[ "${isMonkeyTestSucess}" = "true" ]] && mv $dirPathLogMonkey ${dirPathLogMonkey}_done
}

ftAutoLnOut()
{
    local ftEffect=自动链接out到其他硬盘
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local dirPathDev
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftAutoLnOut -p 存放out的设备路径
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 环境未初始化
# 使用前,请先进入AOSP项目
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p ) dirPathDev="${arg2}"
            dirPathDev=$(ftPath ${dirPathDev})
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #环境校验
    if [[ -z "$ANDROID_BUILD_TOP" ]];then
        [[ -d "alps" ]] && [[ -d ".git" ]] && cd alps
        ftAutoInitEnv > /dev/null
    fi
    local dirPathAospRoot aospProjectName
    dirPathAospRoot=$(dirname $ANDROID_BUILD_TOP)
    aospProjectName=$(basename $dirPathAospRoot)
    [[ ! -d "${dirPathAospRoot}" ]] && ftAutoCreateSxtdOldProjectBranch --env && return $resultFail
    #参数校验
    local dirPathLocal=$(pwd)
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathDev" ] && errorContent="${errorContent}\\n[无法链接到目标路径]dirPathDev=$dirPathDev"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoLnOut -h && return $resultFail

    #实现主体
    cd "${ANDROID_BUILD_TOP}"
    [[ -L "out" ]] && rm out
    if [[ -d "out" ]]; then
        echo -en "out已存在,请选择操作 (回车默认1):\n1 备份 \n2 删除 \n任意其他键取消操作"
        read -n 1 sel ;[ -z "${sel}" ] && sel=1;echo
        while true; do case "$sel" in
                1 )
                    ftAutoBackupOrRestoreOuts
                    break;;
                2 )
                    rm -rf out
                    break;;
                n | q )
                    ftEcho -s "取消操作"
                    return ;;
        esac;done ;
    fi

    dirPathDev="${dirPathDev}/outs/${aospProjectName}"
    [[ ! -d "${dirPathDev}" ]] && mkdir -p "${dirPathDev}"
    [[ ! -d "${dirPathDev}" ]] && ftEcho -s "设备路径初始化失败,无法创建${dirPathDev}" && return $resultFail
    ln -s "${dirPathDev}" out && ftEcho -s "已创建指向[${dirPathDev}]的软链接"
    cd "${dirPathLocal}"
}

complete -W "-h --help" ftAutoFindAospBuildOuts
ftAutoFindAospBuildOuts()
{
    local ftEffect=快速查找所有AOSP工程项目下的所有out
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local mAospProjectNameList mAospProjectStoragePathList
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftAutoFindAospBuildOuts xxxx
#========================================================="; return ;;
    * ) break;;esac;done

    #参数校验
    ftAutoCdAospProject -u > /dev/null
    mAospProjectNameList="$(ftXbGetValue AospProjectsInfo AospProjectNameList)"
    mAospProjectStoragePathList="$(ftXbGetValue AospProjectsInfo AospProjectStoragePathList)"
    [ -z "$mAospProjectStoragePathList" ] && errorContent="${errorContent}\\n找不到AOSP项目存储路径,请检查数据库:\n${rFilePathXbashDBUser}中的AospProjectsInfo"
    [ -z "$mAospProjectNameList" ] && errorContent="${errorContent}\\n找不到AOSP项目,请检查数据库:\n${rFilePathXbashDBUser}中的AospProjectsInfo"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoFindAospBuildOuts -h && return $resultFail

    #实现主体
    #去重，去掉软连接引起的重复
    local dirPathAospProject mAospProjectStoragePathListNew
    for dirPath in ${mAospProjectStoragePathList[@]}; do
        [ ! -d "${dirPath}" ] && continue
        for dirNameAospProject in ${mAospProjectNameList[@]}; do
            dirPathAospProject="${dirPath}/${dirNameAospProject}"
            [ ! -d "${dirPathAospProject}" ] && continue
            dirPathAospProject=$(readlink -f  $dirPathAospProject)
            mAospProjectStoragePathListNew=(${mAospProjectStoragePathListNew[@]} ${dirPathAospProject})
        done
    done
    mAospProjectStoragePathListNew=($(echo ${mAospProjectStoragePathListNew[@]} | sed 's/ /\n/g'|sort |uniq))

    #开始查找
    local dirPathAospProjectOut dirPathAospProjectOuts dirPathAospProjectOutList
    for dirPath in ${mAospProjectStoragePathListNew[@]}; do
                dirPathAospProjectOutList=
                dirPathAospProjectOut="${dirPath}/alps/out"
                if [[ -d "${dirPathAospProjectOut}" ]]; then
                    local dirPathAospProjectOutReal=$(readlink -f  $dirPathAospProjectOut)
                    [[ "${dirPathAospProjectOutReal}" == "${dirPathAospProjectOut}" ]]&&dirPathAospProjectOutList="${dirPathAospProjectOut}"
                fi
                dirPathAospProjectOuts="${dirPath}/outs"
                [ -d "${dirPathAospProjectOuts}" ] && dirPathAospProjectOutList=($dirPathAospProjectOutList $(ls $dirPathAospProjectOuts))

                [[ -z ${dirPathAospProjectOutList} ]] && continue
                ftEcho -s "${dirPath}"
                for dirPathAospProjectOut in ${dirPathAospProjectOutList[@]}; do
                    echo -e "    ${dirPathAospProjectOut}"
                done
    done
}

complete -W "-h --help --rely_install" ftAutoAsConfigFileAutoCreate
ftAutoAsConfigFileAutoCreate()
{
    local ftEffect=在AOSP下面自动生成AndroidStudio的配置文件
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftAutoAsConfigFileAutoCreate --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install make
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftAutoAsConfigFileAutoCreate -h
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
# 环境未初始化 或 当前目录不是AOSP项目的根目录
# 使用前,请先初始化[source build/envsetup.sh;lunch xxxx]
#========================================================="; return ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
    [[ -z $(which make) ]] && ftAutoAsConfigFileAutoCreate --rely "make" && return $resultFail
    #环境校验
    local filePathEnvsetup=build/envsetup.sh
    [ -z "$ANDROID_BUILD_TOP" ] && ftAutoInitEnv
    [ -z "$ANDROID_BUILD_TOP" ] && ftAutoAsConfigFileAutoCreate --env && return $resultFail
    [ ! -f "${filePathEnvsetup}" ] && ftAutoAsConfigFileAutoCreate --env && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -f "${rFilePathXbashDBAuto}" ] && errorContent="${errorContent}\\n[Auto模块的数据库不存在]rFilePathXbashDBAuto=${rFilePathXbashDBAuto}"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoAsConfigFileAutoCreate -h && return $resultFail

    #实现主体
    local filePathAndroidIML=android.iml
    [[ -f "$filePathAndroidIML" ]] &&ftEcho -y "存在旧的${filePathAndroidIML},是否删除(回车默认删除)" && read -n 1 sel && echo
    if [ -z "${sel}" ]||[[ "$sel" = "y" ]];then rm -f $filePathAndroidIML
    else return ;fi

    source $filePathEnvsetup
    local filePathJarIdegen=out/host/linux-x86/framework/idegen.jar
    if [[ ! -f "$filePathJarIdegen" ]]; then
        ftEcho -s "idegen.jar不存在，生成中..."
        local cpuCores=$(cat /proc/cpuinfo | grep processor | wc -l)
        ((cpuCores/=2))
        make idegen -j${cpuCores} > /dev/null|| ftEcho -e "idegen.jar 生成失败"
        [[ ! -f "$filePathJarIdegen" ]] && return $resultFail
    fi

    local filePathShIdegen=development/tools/idegen/idegen.sh
    [[ ! -f "$filePathJarIdegen" ]] && ftEcho -s "未找到: ${filePathJarIdegen}" && return $resultFail
    ftEcho -s "开始使用脚本 idegen.sh 扫描AOSP"
    echo $userPassword | sudo -p '' -S $filePathShIdegen

    local filePathExcludeFolderListTemp=excludeFolder.list
    [[ ! -f "$filePathAndroidIML" ]] && ftEcho -s "未找到: ${filePathAndroidIML}，放弃更新" && return $resultFail
    ftEcho -s "开始优化 ${filePathAndroidIML}的excludeFolder配置"
    local lineNumList=($(awk '/excludeFolder/{print NR}' android.iml))
    [[ -z $lineNumList ]] && ftEcho -s "在 ${filePathAndroidIML} 中未找到excludeFolder的配置，放弃更新" && return $resultFail
    local lineNumCount=${#lineNumList[@]}
    ((lineNumCount-=1))
    local lineNum=${lineNumList[$lineNumCount]}
    lineNum=$(echo $lineNum |sed s/[[:space:]]//g)

    local excludeFolderList=($(ftIniGetValue $rFilePathXbashDBAuto autoAsConfigFileAutoCreateConfig excludeFolderList))
    for i in ${excludeFolderList[@]}; do
        echo "<excludeFolder url=\"file://\$MODULE_DIR\$/${i}\" />" >> $filePathExcludeFolderListTemp
    done

    sed -i "$lineNum r $filePathExcludeFolderListTemp" $filePathAndroidIML
    rm $filePathExcludeFolderListTemp

    echo $userPassword | sudo -p '' -S chmod 777 android.ipr android.iml android.iws
}

complete -W "-h --help -p -s --rely_install" ftAutoLnCcacheByAosp
ftAutoLnCcacheByAosp()
{
    local ftEffect=自动创建AOSP项目独立的ccache目录
    local isEnable=true

    #可用性校验
    [[ -z "${isUseBuildCcache}" ]] && return
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local aospProjectName ccacheMaxSize
    local valCount=4 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftAutoLnCcacheByAosp --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install ccache
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftAutoLnCcacheByAosp -p 项目名
#    ftAutoLnCcacheByAosp -s 缓存大小,单位G
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -p ) aospProjectName="${arg2}"
            ;;
        -s ) ccacheMaxSize="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
    [[ -z $(which ccache) ]] && ftAutoLnCcacheByAosp --rely "ccache" && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${aospProjectName}" ] && errorContent="${errorContent}\\n[项目名为空]"
    [ ! -d "${CCACHE_DEV_DIR}" ] && errorContent="${errorContent}\\n[缓存设备路径不存在]CCACHE_DEV_DIR=CCACHE_DEV_DIR"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoLnCcacheByAosp -h && return $resultFail

    #实现主体
    local dirPathCcache="${CCACHE_DEV_DIR}/.ccache/${aospProjectName}"
    [ ! -d "${dirPathCcache}" ] && mkdir -p "${dirPathCcache}"
    export CCACHE_DIR=$dirPathCcache
    export USE_CCACHE=1
    export CACHE_UMASK=002
    unset CCACHE_HARDLINK

    #ccache空间自动扩容
    ccacheMaxSize=${ccacheMaxSize:-'20G'}
    if [[ "$(type -t ftCheckCcache)" = "function" ]] && ftCheckCcache -c; then
        if (( $ccacheEnv_SizeNow > 0 )); then
                ((ccacheEnv_SizeNow+=10))
                ccacheMaxSize="${ccacheEnv_SizeNow}G"
        fi
    fi
    ccache -M ${ccacheMaxSize}G

    #校验ccache是否有足够的剩余空间
    [[ "$(type -t ftCheckCcache)" = "function" ]] && ftCheckCcache
}

complete -W "-h --help --rely_install" ftAutoCdAospProject
ftAutoCdAospProject()
{
    local ftEffect=快速进入不同Aosp项目
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isUserFileManager itemCount mAospProjectName mAospProjectStoragePathEffective
    local mAospProjectStoragePathList="$(ftXbGetValue AospProjectsInfo AospProjectStoragePathList)"
    local valCount=1 errorContent arg arg2  arg3  arg4
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; eval arg4=\${$((i+3))} ; case "${arg}" in
    # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    自动更新项目列表
#    ftAutoCdAospProject -u
#
#    切换终端路径
#    ftAutoCdAospProject -n 项目名
#
#    在文件管理器中打开
#    ftAutoCdAospProject -fm 项目名
#
#    可简化 [ ftAutoCdAospProject 或 ftAutoCdAospProject -n ] 为 [xcd] ,其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -fm ) isUserFileManager=true
                mAospProjectName="${arg2}"
         ;;
        -n ) mAospProjectName="${arg2}"
         ;;
        -u | --update ) #更新数据库
                local mAospProjectNameIgnoreList="$(ftXbGetValue AospProjectsInfo AospProjectNameIgnoreList)"
                local mAospProjectNameListUpdate
                for path in ${mAospProjectStoragePathList[@]}; do
                    while read projectName ;do
                        [[ -n $(echo ${mAospProjectNameIgnoreList[@]} |grep ${projectName}) ]] && continue
                        [[ ! -d "${path}/${projectName}" ]] && continue
                        mAospProjectNameListUpdate=(${mAospProjectNameListUpdate[@]} ${projectName})
                    done < <(echo "$(ls ${path})")
                done
                mAospProjectNameListUpdate=($(echo ${mAospProjectNameListUpdate[@]} | sed 's/ /\n/g'|sort |uniq))
                ftIniSetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectNameList -l "${mAospProjectNameListUpdate[*]}"
                ftIniSetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectGitStorehouseList -l "${mAospProjectNameListUpdate[*]}"
                ftEcho -s "Aosp项目列表更新完成"
                return;;
        settings ) dirPathTarget="packages/apps/Settings" ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ -z "$mAospProjectStoragePathList" ] && errorContent="${errorContent}\\n[Aosp项目存放路径列表为空]"
    [ -z "$mAospProjectName" ] && errorContent="${errorContent}\\n[未指定Aosp项目名]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoCdAospProject -h && return $resultFail

    #实现主体
    local mAospProjectNameList=($(ftXbGetValue AospProjectsInfo AospProjectNameList| sed 's/ /\n/g'|sort |uniq |grep -i $mAospProjectName))
    itemCount=${#mAospProjectNameList[@]}
    if (( $itemCount>1 ));then
        ftEcho -s 对应多个Aosp项目,请选择
        local index=0
        for item in ${mAospProjectNameList[@]} ; do
            printf "%-4s %-4s\n" [$index] $item
            ((index+=1))
        done

        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex &&echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
        mAospProjectName=${mAospProjectNameList[$tIndex]} && echo
    else
        mAospProjectName=$mAospProjectNameList
    fi

    local mAospProjectStoragePathEffectiveList dirPathAll dirPathBase dirPathProjectStorehouseList
    for path in ${mAospProjectStoragePathList[@]}; do
        dirPathBase=${path}/${mAospProjectName}

        [[ ! -d "${dirPathBase}" ]] && continue

        #默认路径下无git仓库,开始遍历查找仓库
        if [[ ! -d "${dirPathBase}/.git" ]]; then
             #dirPathProjectStorehouse=($(find ${dirPathBase} -maxdepth 2  -type d -path '*/.git'))
             dirPathProjectStorehouse=($(find ${dirPathBase} -maxdepth 2 -path '*/.git'))
             for pathStorehouse in ${dirPathProjectStorehouse[@]}; do
                mAospProjectStoragePathEffectiveList=("${mAospProjectStoragePathEffectiveList[@]} $(dirname $pathStorehouse)")
             done
             continue
        fi

        dirPathAll=${dirPathBase}/alps
        if [[ -d "$dirPathAll" ]]; then
            mAospProjectStoragePathEffectiveList=("${mAospProjectStoragePathEffectiveList[@]} $dirPathAll")
            continue
        fi

        mAospProjectStoragePathEffectiveList=("${mAospProjectStoragePathEffectiveList[@]} $dirPathBase")
    done
    [ -z "$mAospProjectStoragePathEffectiveList" ] && ftEcho -e "找不到${mAospProjectName}对应的Aosp项目有效存放路径" && return $resultFail

    mAospProjectStoragePathEffectiveList=($(echo "${mAospProjectStoragePathEffectiveList}"| sed -e "s: ^::g"))
    mAospProjectStoragePathEffective=$mAospProjectStoragePathEffectiveList
    itemCount=${#mAospProjectStoragePathEffectiveList[@]}
    if (( $itemCount>1 ));then
        ftEcho -s 对应Aosp项目有多个存放位置,请选择
        local index=0
        for item in ${mAospProjectStoragePathEffectiveList[@]} ; do
            printf "%-4s %-4s\n" [$index] $item
            ((index+=1))
        done

        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex &&echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
        mAospProjectStoragePathEffective=${mAospProjectStoragePathEffectiveList[$tIndex]}
    fi

    #项目存在嵌套
    [[ -d "${mAospProjectStoragePathEffective}/${mAospProjectName}" ]] && mAospProjectStoragePathEffective=${mAospProjectStoragePathEffective}/${mAospProjectName}

    [[ -z "$isUserFileManager" ]] && cd $mAospProjectStoragePathEffective && return $resultFail
    ftOpenNemoTab -p $mAospProjectStoragePathEffective
}

complete -W "-h -f --help" -A file ftAutoAdbPush
ftAutoAdbPush()
{
    local ftEffect=adbPush命令的简单封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local filePathSourceList fileNameSource isAutoReboot isTacitMode productName
    local errorContent arg  ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}}
    case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖 Android SDK
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   注意：-f 参数必须在最后使用
#
#   开启新终端,进行操作
#   ftAutoAdbPush -c
#    可简化 [ftAutoAdbPush -c -f] 为 [xpc] ,其他参数不变
#
#   自动push,用户选择操作
#   ftAutoAdbPush -f 文件路径
#    可简化 [ftAutoAdbPush -f] 为 [xp] ,其他参数不变
#
#   push完,自动重启
#   ftAutoAdbPush -a -f 文件路径
#    可简化 [ftAutoAdbPush -a -f] 为 [xpa] ,其他参数不变
#
#   push完,不重启
#   ftAutoAdbPush -n -f 文件路径
#    可简化 [ftAutoAdbPush -n -f] 为 [xpn] ,其他参数不变
#========================================================="; return ;;
       # 变量参数解析部分==============
       -c ) shift ;local valList=(${@})
             [[ ! -f "${rFilePathXbashModuleBaseAdbPush}" ]] && \
             ftEcho -s "脚本不存在:${rFilePathXbashModuleBaseAdbPush}" && return $resultFail
             gnome-terminal -x bash -c "$rFilePathXbashModuleBaseAdbPush ${valList[*]}"
             return
            ;;
       -a ) isAutoReboot=true
            ;;
       -n ) isTacitMode=true
            ;;
       -f )
            local valIndex=$i
            while (( $valIndex>=0 )) ;do (( valIndex-=1 )) && shift ;done
            filePathSourceList=($@)
            ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which adb) ]] && ftAutoAdbPush --rely "adb" && return $resultFail
    #参数校验
    [ -z "$filePathSourceList" ] && errorContent="${errorContent}\\n[push的源路径不存在]filePathSourceList=$filePathSourceList"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoAdbPush -h && return $resultFail

    #实现主体
    #adb连接状态检测
    ftAdbConnect -e ; [[ -z "${autoTestDeviceId}" ]] && return $resultFail
    local deviceId=${autoTestDeviceId}

    for filePath in ${filePathSourceList[@]}; do
            [[ ! -f "$filePath" ]] && ftEcho -e "找不到:${filePath}" && continue
            if [[ -n $(echo $filePath |grep product) ]] ;then
                fileNameSource=$(basename $filePath)

                local filePathTemp=$filePath
                while true; do
                    if [[ "." = $filePathTemp ]]; then
                        ftEcho -en "无法解析:";echo "${filePathTemp}"
                        return
                    fi
                    if [[ -z $filePathTemp ]]; then
                        break
                    fi
                    if [[ "out/target/product" = $(dirname $filePathTemp) ]]; then
                        productName=$(basename $filePathTemp)
                        break
                    fi
                    filePathTemp=$(dirname $filePathTemp)
                done
                dirPathTarget=$(echo ${filePath#*${productName}} | sed -e "s:/$fileNameSource::g")

                echo "push ${filePath} > ${dirPathTarget}"
                adb -s $deviceId push $filePath $dirPathTarget &&  ftEcho -s "${fileNameSource} push to [${dirPathTarget}] finish"
            else
                ftEcho -en "无法自动解析:";echo "${filePath}"
            fi
    done
    if [[ -z "$isTacitMode" ]]; then
        [[ -z "$isAutoReboot" ]] &&ftEcho -y "是否重启(回车默认重启)" && read -n 1 sel && echo
        if [ -z "${sel}" ]||[[ "$sel" = "y" ]];then
            local keySDKVersion="ro.build.version.sdk="
            local deviceSdkVersion=$(adb shell "cat /system/build.prop" |grep ${keySDKVersion})
            deviceSdkVersion=${deviceSdkVersion//$keySDKVersion/}
            deviceSdkVersion=$(echo $deviceSdkVersion |sed s/[[:space:]]//g)
            deviceSdkVersion=${deviceSdkVersion:-'null'}
            if (( $deviceSdkVersion>=28 )); then
                sleep 2 && adb shell stop && adb shell start
                ftEcho -s "已重启设备服务:${deviceId} "
            else
                 adb -s $deviceId reboot
                 ftEcho -s "已重启设备:${deviceId} "
            fi
        fi
    fi
}

complete -W "-a -d -f -o -h --help" -A file ftAutoApkMergeOdex
ftAutoApkMergeOdex()
{
    local ftEffect=合并odex和apk
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isAutoPull fileNameApk filePathApk filePathOdex dirPathFramework
    local filePathToolResign=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/re-sign.jar
    local filePathToolSmali=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/smali-2.2.7.jar
    local filePathToolBaksmali=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/baksmali-2.2.7.jar
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    指定app名称，插上手机，执行pull和合并操作
#    ftAutoApkMergeOdex -a xxxx
#    直接指定已存在包路径，执行合并操作
#    ftAutoApkMergeOdex -d framework路径 -f apk路径 -o odex文件路径
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a ) fileNameApk="${arg2}"
               isAutoPull=true
          ;;
        -d ) dirPathFramework="${arg2}"
          ;;
        -f ) filePathApk="${arg2}"
          ;;
        -o ) filePathOdex="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #预处理
    if [[ "$isAutoPull" = "true" ]]; then
        [[ -z "${fileNameApk}" ]] && ftEcho -ea "命令[${ftEffect}]的参数错误,未指定app名\\n请查看下面说明:" && ftAutoApkMergeOdex -h && return $resultFail

        ftAdbConnect ; [[ -z "${autoTestDeviceId}" ]] && return $resultFail
        local deviceId=${autoTestDeviceId}

        local dirPathLocal=$(pwd) dirPathTarget=/tmp/mergeOdex
        [[ ! -d "$dirPathTarget" ]] && mkdir $dirPathTarget
        [[ ! -d "$dirPathTarget" ]] && ftEcho -e "初始化失败,无法新建临时目录:${dirPathTarget}" && return $resultFail
        cd $dirPathTarget

        [[ "$fileNameApk" == *.apk* ]] && fileNameApk=$(echo $fileNameApk| sed -e "s:.apk::g")
        local dirPathDevices=system/app/${fileNameApk}
        [[ -n $(adb -s $deviceId shell ls system/priv-app|grep $fileNameApk) ]] && dirPathDevices=system/priv-app/${fileNameApk}

        filePathApk=${dirPathTarget}/${fileNameApk}/${fileNameApk}.apk
        filePathOdex=${dirPathTarget}/${fileNameApk}/oat/arm/${fileNameApk}.odex
        dirPathFramework=${dirPathTarget}/framework

        if [[ -n "$(ls ${dirPathFramework})" ]];then
            ftEcho -y "存在旧framework, 是否清理(回车默认清理)" && \
            read -n 1 sel && echo
            if [ -z "${sel}" ]||[[ "$sel" = "y" ]];then
             rm -rf $dirPathFramework && sel= ; else ftEcho -s "将使用旧framework" && sel=n ;fi
        fi
        if [ -z "${sel}" ]; then
            adb -s $deviceId pull $dirPathDevices ${dirPathTarget}&& ftEcho -s "pull ${fileNameApk} 完成"
            adb -s $deviceId pull system/framework/  ${dirPathTarget}&& ftEcho -s "pull framework 完成"
            cp -rf -v ${dirPathTarget}/framework/arm/* ${dirPathTarget}/framework && ftEcho -s "复制 framework/arm/* 到 framework 完成"
        fi
    fi
    #依赖校验
    [[ -z $(which zip) ]] && ftAutoApkMergeOdex --rely "zip" && return $resultFail
    #参数校验
    local errorContent
    [ -z "$JAVA_HOME" ] && errorContent="${errorContent}\\n[java环境未配置]缺失JAVA_HOME"
    [ ! -f "$filePathToolSmali" ] && errorContent="${errorContent}\\n[找不到 filePathToolSmali=${filePathToolSmali}]"
    # [ ! -f "$filePathToolResign" ] && errorContent="${errorContent}\\n[找不到 filePathToolResign=${filePathToolResign}]"
    [ ! -f "$filePathToolBaksmali" ] && errorContent="${errorContent}\\n[找不到 filePathToolBaksmali=${filePathToolBaksmali}]"

    [ ! -f "$filePathApk" ] && errorContent="${errorContent}\\n[找不到 filePathApk=${filePathApk}]"
    [ ! -f "$filePathOdex" ] && errorContent="${errorContent}\\n[找不到 filePathOdex=${filePathOdex}]"
    [ ! -d "$dirPathFramework" ] && errorContent="${errorContent}\\n[找不到 dirPathFramework=${dirPathFramework}]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoApkMergeOdex -h && return $resultFail

    #实现主体
    cd $dirPathFramework

    if java -jar $filePathToolBaksmali deodex $filePathOdex ;then
        ftEcho -s "odex转smali 完成" ; else ftEcho -e "odex转smali失败" && return $resultFail ;fi

    if java -jar $filePathToolSmali assemble out -o classes.dex ;then
        ftEcho -s "smali转dex 完成" ; else ftEcho -e "smali转dex失败" && return $resultFail ;fi

    if zip -g $filePathApk classes.dex > /dev/null ;then
        ftEcho -s "classes.dex/apk合并 完成" ;else ftEcho -e "classes.dex/apk合并失败" && return $resultFail ;fi

    if java -jar $filePathToolResign $filePathApk ;then
        ftEcho -s "apk签名 完成" ; else ftEcho -e "apk签名失败" && return $resultFail ;fi

    ftEcho -s "${fileNameApk}的${ftEffect}操作成功"

    cd $dirPathLocal
}

complete -W "-f -h --help" -A file ftAutoApkSignature
ftAutoApkSignature()
{
    local ftEffect=apk签名
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local filePathApk
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftAutoApkSignature -f xxx.apk
#========================================================="; return ;;
       --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 环境未初始化
# 使用前,请先初始化
# source build/envsetup.sh && lunuch xxxxx
#========================================================="; return ;;
        # 变量参数解析部分==============
        -f ) filePathApk="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #环境校验
    local toolFilePathSignapk="${ANDROID_BUILD_TOP}/out/host/linux-x86/framework/signapk.jar"
    [ ! -f "$toolFilePathSignapk" ] && [ ! -d "$ANDROID_BUILD_TOP" ] && ftAutoApkSignature --env && return $resultFail
    [ -d "$ANDROID_BUILD_TOP" ] && cd $ANDROID_BUILD_TOP
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$JAVA_HOME" ] && errorContent="${errorContent}\\n[java环境未配置]缺失JAVA_HOME"
    [ ! -f "$toolFilePathSignapk" ] && errorContent="${errorContent}\\n[缺少有效的签名工具]${toolFilePathSignapk}不存在"
    [ ! -f "$filePathApk" ] && errorContent="${errorContent}\\n[你想干嘛]${filePathApk}不存在"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoApkSignature -h && return $resultFail

    #实现主体
    local toolFilePathlibconscrypt_openjdk_jni="${ANDROID_BUILD_TOP}/prebuilts/sdk/tools/linux/lib64/libconscrypt_openjdk_jni.so"
    local toolFilePathPlatformx509pem="${ANDROID_BUILD_TOP}/build/target/product/security/platform.x509.pem"
    local toolFilePathPlatformpk8="${ANDROID_BUILD_TOP}/build/target/product/security/platform.pk8"

    local fileNameApk=$(basename $filePathApk)
    local fileNameApkBase=${fileNameApk%.*}
    local fileNameApkEnd=${fileNameApk##*.}
    local fileNameApkNew=$(dirname $filePathApk)/${fileNameApkBase}_new${fileNameApkEnd}

    local dirPathLocal=$(pwd) dirPathSign=$(dirname $filePathApk)
    # cp -v "${toolFilePathlibconscrypt_openjdk_jni}" "${dirPathSign}"
    cd "${dirPathSign}"
    java -Djava.library.path=. -jar "${toolFilePathSignapk}" "${toolFilePathPlatformx509pem}" "${toolFilePathPlatformpk8}" "${filePathApk}" "${fileNameApkNew}" \
    && mv "${fileNameApkNew}" "${filePathApk}" &&ftEcho -s  "${filePathApk}  签名成功"|| ftEcho -s "${filePathApk}签名失败"
    rm -f $(basename "${toolFilePathlibconscrypt_openjdk_jni}")
    cd "${dirPathLocal}"
}
