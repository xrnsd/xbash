#!/bin/bash
#########################
##                                              ##
##             框架通用实现             ##
##                                              ##
#########################
_ftMainVal()
{
    local ftEffect=bash内建命令和xbash扩展封装对应的参数补全实现
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    case "${COMP_WORDS[1]}" in
                    -)
                            COMP_WORDS[1]="-h"
                            export COMP_WORDS=${COMP_WORDS[@]}; ;;
                    *)  COMPREPLY=( $(compgen -W '-h -hb -hc --help -t test  -v --version -ft' -- $curr_arg ) ); ;;
      esac
}
ftMain()
{
    local ftEffect=早期工具主入口
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    while true; do case $1 in
    -v | --version )
                local dirPathLocal=$(pwd) flag="-v beta"
                cd $rDirPathXbash
                local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
                [[ "$branchNameNow" = "master" ]] && flag="-i beta"
                local tagList=($(git tag |grep ${flag} ))
                local length=${#tagList[@]}
                ((length-=1))
                echo -n \"Xrnsd extensions to bash\" && ftEcho -s " ${tagList[$length]}"
                cd "${dirPathLocal}"
                break;;
    -t | test )
                ftTest "$@"
                break;;
    -h | --help )
                ftEcho -s "xc -h    #查看所有说明\nxc -hb   #bash命令封装和xbash扩展封装的说明\nxc -ft   #xbash的扩展实现说明" && 
                echo && ftMain -ft && echo && ftMain -hb
                break;;
    -hb )
                ftReadAllAlias
                break;;
    -ft )
                ftReadAllFt
                break;;
    -sc )
                sensors |grep °C | awk '{print $3}'|grep °C|awk '{sum+=$1} END {printf("CPU %s °C \n",sum/NR)}'
                break;;
    -scc )
                sensors |grep °C | awk '{print $3}'|grep °C
                break;;
    *) ftMain -h && return;; esac;done
}

ftClearTail()
{
    local ftEffect=清尾
    local isEnable=def

    local dirPathLocal=$1
    [[ -n $dirPathLocal ]] && cd $dirPathLocal
    trap SIGINT
}

complete -W "-a --adb -h -j -s" ftResetXbash
ftResetXbash()
{
    local ftEffect=更新xbash配置
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    export isResetJdk= isResetGcc= isResetCcache= isResetXbash=true targetSdkVersionForce=
    local dirPathCode dirPathLocal=$(pwd)
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}}  ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    可简化 [ftResetXbash] 为 [xr] ,其他参数不变
#    以下[参数对]无先后顺序可任意组合
#
#    更新xbash默认配置
#    ftResetXbash
#
#    重启adb服务
#    ftResetXbash -a/--adb
#
#    更新 jdk配置 / gcc配置 / jdk和gcc配置 / jdk和gcc和ccache配置
#    ftResetXbash -j / -c / -jc / -jcc
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a |--adb) ftRestartAdb && return
          ;;
        -j ) export isResetJdk=true
            targetSdkVersionForce="${arg2}"
            [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return
          ;;
        -c ) export isResetGcc=true
            targetSdkVersionForce="${arg2}"
            [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return
          ;;
        -cj | -jc |-jcc)
                [[ -n "${arg2}" ]] && export targetSdkVersionForce="${arg2}"
                [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return
                [ -d "${dirPathLocal}/alps" ] && dirPathCode=${dirPathLocal}/alps
                [ -d "${dirPathLocal}/idh" ] && dirPathCode=${dirPathLocal}/idh
                [ -n "${dirPathCode}" ] && cd $dirPathCode

                [[ -n "$isUseBuildCcache" ]] && [ "${arg}" = "-jcc" ] && export isResetCcache=true
                export isResetGcc=true
                export isResetJdk=true
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #实现主体
    # source ~/.bashrc
    source $filePathHomeBash
    export isResetXbash=
    cd ${dirPathLocal}
}

ftReadAllAlias()
{
        local ftEffect=bash命令封装和xbash扩展封装的说明
        local isEnable=def

        #可用性校验
        [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
        #解参验耦
        [[ ! -f $rFilePathXbashModuleBasePackaging ]] && ftEcho -e "xbash配置不存在:$rFilePathXbashModuleBasePackaging" && return

        local cmdName cmdContent
        local intervalSize=24

        ftEcho -s "$ftEffect"
        echo -e "========================================================="
        printf "%s  %${intervalSize}s \n" 命令 说明
        echo -e "========================================================"
        cat $rFilePathXbashModuleBasePackaging|grep alias | sort | while read line; do
                cmdName=$(echo $line | awk '{split($2,b,"=");print  b[1] }')
                cmdContent=$(echo $line | awk '{split($2,b,"=");print  b[3]}'| awk '{split($0,b,";");print  b[1]}')
                [[ -n "$cmdContent" ]] && printf "%${intervalSize}s  %s\n" ${cmdName} ${cmdContent}
        done | column -t
}

ftReadAllFt()
{
        local ftEffect=xbash的扩展实现说明
        local isEnable=def

        #isEnable设为 def 时将不在说明中显示
        #可用性校验
        [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

        local key="local ftEffect=" keyEnable="local isEnable="
        local effectDescription effectDescriptionEnable
        local intervalSize=40

        ftEcho -s "$ftEffect"
        echo -e "========================================================="
        printf "%s%${intervalSize}s" 命令 说明 && ftEcho -s " [ 查看对应命令的具体说明: 命令 -h ]"
        echo -e "========================================================"
        for effectName in $(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto  $rFilePathXbashModuleGit| grep '^ft'  |grep "()"| sort) ; do
            effectDescription=$(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto $rFilePathXbashModuleGit|grep  -C 3 $effectName|grep "$key")
            effectDescription=${effectDescription//$key/}
            effectDescription=${effectDescription// /}

            effectDescriptionEnable=$(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto $rFilePathXbashModuleGit|grep  -C 3 $effectName|grep "$keyEnable")
            effectDescriptionEnable=${effectDescriptionEnable//$keyEnable/}
            effectDescriptionEnable=${effectDescriptionEnable// /}

            [[ "$effectDescriptionEnable" = "def" ]] && continue

            printf "%${intervalSize}s  " ${effectName//()/}
            [[ "$effectDescriptionEnable" = "true" ]] && echo ${effectDescription} || ftEcho -s "[暂时关闭]"
        done | column -t
}

ftTest()
{
    local ftEffect=调试
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftTest 任意参数
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    if [[ ! -f "$rFilePathXbashModuleTest" ]] && [[ -f $rFilePathXbashModuleTestExpmale ]]; then
       cp $rFilePathXbashModuleTestExpmale $rFilePathXbashModuleTest
       echo $userPassword | sudo -p '' -S chmod a+x $rFilePathXbashModuleTest
       [[ -z $(cat ${rDirPathXbash}/.gitignore |grep $rFileNameXbashModuleTestBase) ]] && \
       echo $(echo $rFilePathXbashModuleTest | sed -e "s:${rDirPathXbash}/::g") >> ${rDirPathXbash}/.gitignore
    fi
    local valCount=1 errorContent
    [ ! -d "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[用户路径为空]rDirPathUserHome=$rDirPathUserHome"
    [ ! -f "$rFilePathXbashModuleTest" ] && errorContent="${errorContent}\\n[测试模块不存在]filePathXbashModuleTest=$rFilePathXbashModuleTest"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftTest -h && return

    #实现主体
    local dirPathLocal=$PWD dirPathTemp=${rDirPathUserHome}/.temp
    [[ ! -d "${dirPathTemp}" ]] && mkdir $dirPathTemp
    [[ ! -f ${dirPathLocal}/Makefile ]] && [[ -z "$ANDROID_BUILD_TOP" ]] && cd $dirPathTemp && trap '[ -d $dirPathLocal ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    ftTimeConsuming -i
    shift&&$rFilePathXbashModuleTest "$@"
    ftTimeConsuming -r $ftEffect
    cd $dirPathLocal
    trap SIGINT
}

complete -W " --rely_install" ftGitUpdateVersion
ftGitUpdateVersion()
{
    local ftEffect=xbash自动更新
    local isEnable=true

    #可用性校验
    [[ -n "$isAutoUpdate" ]] && isEnable=$isAutoUpdate
    [[ "$isEnable" != "true" ]] && return
    #依赖校验
    [[ -z $(which git) ]] && return
    #解参验耦
    local dirPathLocal=$(pwd)
    local checkUpdateDateNow=$(date -d "today" +"%Y%m%d")
    local tagName=xbashUpdateVersionConfig
    local keyName=checkUpdateDate
    local checkUpdateDateOld=$(ftIniGetValue $rFilePathXbashDBUser $tagName $keyName)
    [[ -z "${checkUpdateDateOld}" ]] && ftIniCreateFileOrTag  -a -p $rFilePathXbashDBUser -t $tagName -l "${keyName}=${checkUpdateDateNow}" || \
    [[ "${checkUpdateDateOld}" = "${checkUpdateDateNow}" ]] && return
    [[ -n "${rDirPathXbash}" ]] && cd $rDirPathXbash

    local branchNameMaster="master"
    local branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    #实现主体
    [ -z "$branchNameLocal" ] || [ "$branchNameLocal" = "$branchNameMaster" ] && cd "${dirPathLocal}" && return
    echo "$(git pull > /dev/null &)" > /dev/null
    cd "${dirPathLocal}"
    ftIniSetValue $rFilePathXbashDBUser $tagName $keyName $checkUpdateDateNow
}

ftEcho()
{
    local ftEffect=工具信息提示
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftEcho          内容    # 直接显示内容
#    ftEcho    -b    内容    # 标题，不换行，对字符串的缩进敏感
#    ftEcho    -bh   内容    # 标题，换行，对字符串的缩进敏感
#    ftEcho    -e    内容    # 错误信息显示，对字符串的缩进敏感
#    ftEcho    -en   内容    # 错误信息显示，对字符串的缩进敏感
#    ftEcho    -ex   内容    # 错误信息显示，显示完退出，对字符串的缩进敏感
#    ftEcho    -ea   内容    # 错误信息多行显示，对字符串的缩进不敏感，包含内置数组会显示不正常
#    ftEcho    -eax  内容    # 错误信息多行显示，对字符串的缩进不敏感，包含内置数组会显示不正常，显示完退出
#    ftEcho    -y    内容    # 特定信息显示，y/n，对字符串的缩进敏感
#    ftEcho    -s    内容    # 执行信息，对字符串的缩进敏感
#    ftEcho    -sn   内容    # 执行信息，不换行，对字符串的缩进敏感
#    ftEcho    -rc   内容    # xbash函数的说明显示，对字符串的缩进敏感
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    local content option=$1 valList=$@
    option=${option:-'未制定显示信息'}
    if [ ${#valList[@]} -eq 2 ];then
        content=$(echo $content |sed s/[[:space:]]//g)
    else
        #除第一个参数外的所有参数列表，可正常打印数组
        content="${valList[@]/$option/}"
        content=${content/ /}
    fi
    while true; do case $option in
        -e )      echo -e "\033[1;31m$content\033[0m"; break;;
        -en )    echo -en "\033[1;31m$content\033[0m"; break;;
        -ex )    echo -e "\033[1;31m$content\033[0m" ; [ "$XMODULE" = "env" ] && return ; exit;;
        -s )       echo -e "\033[1;33m$content\033[0m"; break;;
        -sn )     echo -en "\033[1;33m$content\033[0m"; break;;
        -sh )     echo;echo -e "\033[1;33m$content\033[0m";echo; break;;
        -b )       echo -e "\e[41;33;1m =========== $content ============= \e[0m"; break;;
        -bh )    echo;echo -e "\e[41;33;1m =========== $content ============= \e[0m";echo; break;;
        -y )       echo;echo -en "${content}[y/n]"; break;;
        -yn )     echo -en "${content}[y/n]"; break;;
        -ye )     echo -en "${content}[y/n]"; break;;
        -r )        echo;echo -en "${content}"; break;;
        -ea )      for val in ${content[@]} ; do echo -e "\033[1;31m$val\033[0m"; done; break;;
        -eax )   for val in ${content[@]} ; do echo -e "\033[1;31m$val\033[0m"; done; exit;;
        -rc )     echo -en "\033[1;33m${2}\033[0m";echo "${3}";echo -e "${4}" ; break;;
    * )    echo $option ;break;; esac ;done
}

ftTimeConsuming()
{
    local ftEffect=脚本操作耗时记录
    local isEnable=def

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    #解参验耦
    local contentName=本技能 arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        -r ) contentName="${arg2:-"$contentName"}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ -z "$mTimingStart" ]||[ "$1" = "-i" ] && mTimingStart=$(date +%s -d $(date +"%H:%M:%S")) && return 0

    local content timeNow=$(date +%s -d $(date +"%H:%M:%S"))
    local time3=$(((timeNow-mTimingStart)%60))
    local time5=$(((timeNow-mTimingStart)/3600))
    local time4=$((((timeNow-mTimingStart)-time5*3600)/60))
    mTimingStart=

    (($time3==0)) && (($time4==0)) && (($time5==0)) && return
    (($time5!=0)) && content="${content}${time5} 时"
    (($time4!=0)) && content="${content}${time4} 分"
    (($time3!=0)) && content="${content}${time3} 秒"
    ftEcho -s "${contentName}耗时 ${content}!"
}

ftPath()
{
    local ftEffect=路径处理
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftPath 路径       #去掉最后的斜杠
#    ftPath 路径 文件  #正确拼接路径
#    ftPath -s 路径 文件  #正确拼接路径，显示错误提示
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPath=$1 fileName=$2
    if [[ "$1" = "-s" ]]; then
        local isEchoExceptionInfo=true
        dirPath=$2
        fileName=$3
    fi
    local valCount=3 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$dirPath" ] && errorContent="${errorContent}\\n[路径字串不能为空]dirPath=$dirPath"
    [ -n "$errorContent" ] && [ -z "$isEchoExceptionInfo" ] && return
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPath -h && return

    #实现主体
    [[ "${dirPath: -1}" = "/" ]] && dirPath=${dirPath%/*}
    [[ -z "$fileName" ]] && echo $dirPath || echo ${dirPath}/${fileName}
}

ftVersionComparison()
{
    local ftEffect=版本号大小对比
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftVersionComparison -h    #查看帮助
#
#    只能比对xx.xx格式的版本号
#    echo \$(ftVersionComparison 版本1 版本2)   #比对版本1和2大小
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftVersionComparison -h && return

    #实现主体
    [[ "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" != "$1" ]] && echo ">" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" != "$1" ]] && echo "<" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" == "$1" ]] && echo "<=" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" == "$1" ]] && echo ">=" && return
}

ftCheckUserConfig()
{
    local ftEffect=校验用户配置和模版版本一致性
    local isEnable=true
    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    local filePathUserConfigExpmale=${rDirPathXbashConfig}/expmale.config

    [[ ! -f ${filePathUserConfigExpmale}  ]] && return
    [[ ! -f ${rFilePathXbashConfigUser}  ]] && return

    local key="versionNum="
    local versionNumExcepmale=$(cat $filePathUserConfigExpmale |grep $key)
    local versionNumUser=$(cat $rFilePathXbashConfigUser |grep $key)

    versionNumExcepmale=${versionNumExcepmale//$key/}
    versionNumUser=${versionNumUser//$key/}

    [[ -z "${versionNumUser}" ]] && ftEcho -e "建议更新用户配置到:${versionNumExcepmale}" && return
    [[ -z "${versionNumExcepmale}" ]] || [[ $(ftVersionComparison $versionNumUser $versionNumExcepmale) != "<"  ]] && return

    ftEcho -e "建议更新用户配置: ${versionNumUser} > ${versionNumExcepmale}"
    echo -n "更新文件" ; ftEcho -s "：$rFilePathXbashConfigUser"
    echo -n "更新模版" ; ftEcho -s "：$filePathUserConfigExpmale"
}

ftCheckUserDatabase()
{
    local ftEffect=校验用户数据库和模版版本一致性
    local isEnable=true
    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    [[ ! -f ${rFilePathXbashDBUserExcepmale}  ]] && return
    [[ ! -f ${rFilePathXbashDBUser}  ]] && return

    local  tag=informationInThisDb key="versionNum"
    local versionNumExcepmale=$(ftIniGetValue $rFilePathXbashDBUserExcepmale $tag $key)
    local versionNumUser=$(ftIniGetValue $rFilePathXbashDBUser $tag $key)

    if [[ -z "${versionNumUser}" ]];then
        ftEcho -e "建议更新用户数据库配置到:${versionNumExcepmale}"
        echo -n "更新模版"; ftEcho -s "：$rFilePathXbashDBUserExcepmale"
    elif [[ -n "${versionNumExcepmale}" ]];then
        local val=$(ftVersionComparison $versionNumUser $versionNumExcepmale)
        if [[ ${val} = "<"  ]];then
            ftEcho -e "建议更新用户数据库配置: ${versionNumUser} > ${versionNumExcepmale}"
            echo -n "更新文件" ; ftEcho -s "：$rFilePathXbashDBUser"
            echo -n "更新模版" && ftEcho -s "：$rFilePathXbashDBUserExcepmale"
            return
        fi
        [[ ${val} = ">"  ]] && ftEcho -e "建议更新用户数据库配置版本不一致，建议查看" && return
    fi
}

ftIniCreateFileOrTag()
{
    local ftEffect=创建ini文件,添加TAG
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local filePathIni editType contentTagName contentTagKeyValList
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    添加内容
#    ftIniCreateFileOrTag  -a -p 文件路径 -t 块名 -l 块对应的键值对列表
#    覆盖文件
#    ftIniCreateFileOrTag  -r -p 文件路径 -t 块名 -l 块对应的键值对列表
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a )   editType=add                                   ;;
        -r )   editType=replace                               ;;
        -p )   filePathIni="$arg2"                            ;;
        -t )   contentTagName="$arg2"                 ;;
        -l )   contentTagKeyValList="${arg2[@]}" ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$filePathIni" ] && errorContent="${errorContent}\\n[不知道要去那，请使用-p制定文件路径]"
    [ -z "$contentTagName" ] && errorContent="${errorContent}\\n[块名为空]contentTagName=$contentTagName"
    [ -z "$contentTagKeyValList" ] && errorContent="${errorContent}\\n[块对应的列表为空]contentTagKeyValList=$contentTagKeyValList"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniCreateFileOrTag -h && return

    #实现主体
    local content enterLine="\n"
    #added TAG
    content=${enterLine}"[$contentTagName]"
    #add List
    for item in ${contentTagKeyValList[*]} ; do content=${content}${enterLine}"$item" ;done
    content=${content}${enterLine}

    if [[ ! -f "$filePathIni" ]]||[ "$editType" = "replace" ]; then
        localContent="#ini"
        localContent=${localContent}${enterLine}"#文件由ftIniCreateFileOrTag自动创建，请避免手动编辑造成解析失败"
        localContent=${localContent}${enterLine}
        echo -e ${localContent} > $filePathIni
    fi

    if [ -n "$(cat $filePathIni |grep  $contentTagName)" ];then
        ftEcho -y "存在旧TAG，是否删除(回车默认y)"
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    while [ -n "$(cat $filePathIni |grep  $contentTagName)" ]; do
                        ftIniDeleteTag -p $filePathIni -t $contentTagName
                    done; break;;
                n | q )  echo ; exit ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
    esac;done ; fi
    echo  -e "${content}" >> $filePathIni
}

ftIniDeleteTag()
{
    local ftEffect=删除ini文件中对应TAG块
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local tagName filePathIni
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniDeleteTag -p ini文件路径 -t TAG块名
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t )   tagName="${arg2}"        ;;
        -p )   filePathIni="${arg2}"     ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteTag -h && return

    #实现主体
    local index=1 indexEnd indexStart lineCount=$(cat $filePathIni|wc -l)
    while read -r line ; do
        if [[ "$line" = "[${tagName}]" ]]||[[ -n "$indexStart" ]]; then
            [[ -z "$indexStart" ]] && indexStart=$index
            (($index==$lineCount)) && ((index+=1)) && line=

            if [[ -z "$line" ]]; then
                indexEnd=$index
                local lineRange="${indexStart},${indexEnd}d"
                sed -i $lineRange $filePathIni
                break
            fi
        fi
        ((index+=1))
    done < $filePathIni
}

ftIniAddItem()
{
    local ftEffect=在ini文件对应TAG中添加指定item
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local tagName itemContent filePathIni
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniAddItem -p ini文件路径 -t TAG块名  -l 块对应的键值对列表
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t )   tagName="${arg2}"        ;;
        -l )   itemContent="${arg2}"    ;;
        -p )   filePathIni="${arg2}"    ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$itemContent" ] && errorContent="${errorContent}\\n[缺少必要参数]itemContent=$itemContent"
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniAddItem -h && return

    #实现主体
    local indexStart=0 index=1 tagContent
    cat $filePathIni | while read line ;do
        if [[ "$line" = "[${tagName}]" ]]||(( $indexStart != 0 )); then
            (( $indexStart == 0 )) && indexStart=1
            tagContent=(${tagContent[@]} ${line})
            if [[ -z "$line" ]]; then
                for item in ${itemContent[*]} ; do
                    for itemBase in ${tagContent[*]}; do
                        [[ "${itemBase}" = "${item}" ]] &&item= && break
                    done
                    [ -z "${item}" ] && break
                    sed  -i "${index}i ${item}" $filePathIni
                    ((index+=1))
                done
                break
            fi
        fi
        ((index+=1))
    done

}

ftIniDeleteItem()
{
    local ftEffect=在ini文件对应TAG中删除指定item
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local tagName itemName filePathIni
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniDeleteItem -p ini文件路径 -t TAG块名 -i item名
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t )   tagName="${arg2}"            ;;
        -i )   itemName="${arg2}"           ;;
        -p )   filePathIni="${arg2}"        ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$itemName" ] && errorContent="${errorContent}\\n[缺少必要参数]itemName=$itemName"
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteItem -h && return

    #实现主体
    local indexStart indexEnd index=0
    cat $filePathIni | while read line ;do
        if [[ "$line" = "[${tagName}]" ]]||[[ -n "$indexStart" ]]; then
            [[ -z "$indexStart" ]] && indexStart=$index && ((indexStart+=1))
            if [[ "$line" =~ ^${itemName}* ]]; then
                ((index+=1))
                sed -i "${index}d" $filePathIni
                break
            fi
            [[ -z "$line" ]] && indexEnd=$index && break
        fi
        ((index+=1))
    done
}

ftIniGetValue()
{
    local ftEffect=在ini文件对应TAG中读取指定item
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    #默认不输出异常信息
#    ftIniGetValue 文件路径 目标块TAG 键名
#    value=\$(ftIniGetValue 文件路径 目标块TAG 键名)
#    value表示key对应的值
#
#    #输出异常信息
#    ftIniGetValue -f [文件路径] [目标块TAG] [键名]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local filePath=$1 blockName=$2 keyName=$3 isReadSilence
    if [[ "$filePath" = "-f" ]]; then
            filePath=$2
            blockName=$3
            keyName=$4
            isReadSilence=true
    fi
    local valCount=3 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    if [ ! -f "$filePath" ];then    errorContent="${errorContent}\\n[文件不存在]filePath=$filePath"
    else
        testBockName=$(cat $filePath|grep $blockName)
        testKeyName=$(cat $filePath|grep $keyName)
        if [ -z "$blockName" ];then    errorContent="${errorContent}\\n[目标块TAG为空]blockName=$blockName"
        elif [ -z "$testBockName" ];then    errorContent="${errorContent}\\n[目标块TAG不存在]blockName=$blockName" ; fi
        if [ -z "$keyName" ];then    errorContent="${errorContent}\\n[目标块TAG为空]keyName=$keyName"
        elif [ -z "$testKeyName" ];then    errorContent="${errorContent}\\n[目标块TAG不存在]keyName=$keyName" ; fi
    fi
    if [ -n "$errorContent" ];then
            [[ -z "$isReadSilence" ]] && return
            ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:"
            ftIniGetValue -h
            return
    fi

    #实现主体
    local begin_block=0 end_block=0

    cat $filePath | while read line ; do
        [ "X$line" = "X[$blockName]" ] && begin_block=1 && continue

        if (( $begin_block==1 ));then
            (( $(echo $line | awk 'BEGIN{ret=0} /^\[.*\]$/{ret=1} END{print ret}')==1 )) && break
            (( $(echo $line | awk 'BEGIN{ret=0} /^#/{ret=1} /^$/{ret=1} END{print ret}')==1 )) && continue

            key=$(echo $line | awk -F= '{gsub(" |\t","",$1); print $1}')
            [ "X$keyName" = "X$key" ] && echo $(echo $line | awk -F= '{gsub("\t","",$2); print $2}') && break
        fi
    done
}

ftIniSetValue()
{
    local ftEffect=在ini文件对应TAG中修改指定item
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local isListValue filePath=$1 blockName=$2 keyName=$3 keyValue=$4
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniSetValue [文件路径] [目标块TAG] [键名] [键对应的值]
#    ftIniSetValue /temp/odbcinst.ini PostgreSQL Setup 1232
#    ftIniSetValue /temp/odbcinst.ini PostgreSQL Setup -l \"${xxx[*]}\"  #写入数组
#========================================================="; return ;;
        # 变量参数解析部分==============
        -l )    keyValue="${arg2}"
                isListValue=true
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    if [ ! -f "$filePath" ];then    errorContent="${errorContent}\\n[目标ini文件不存在]filePath=$filePath"
    else
        if [ -z "$blockName" ];then    errorContent="${errorContent}\\n[目标块TAG为空]blockName=$blockName"
        elif [ -z "$(cat $filePath|grep $blockName)" ];then    errorContent="${errorContent}\\n[目标块TAG不存在]blockName=$blockName" ; fi
        if [ -z "$keyName" ];then    errorContent="${errorContent}\\n[目标Key为空]keyName=$keyName"
        elif [ -z "$(cat $filePath|grep $keyName)" ];then    errorContent="${errorContent}\\n[目标Key不存在]keyName=$keyName" ; fi
        [ -z "$keyValue" ] && errorContent="${errorContent}\\n[目标Key对应的Value为空]keyValue=$keyValue"
    fi
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniSetValue -h && return

    #实现主体
    [[ "$isListValue" = "true" ]] && return`sed -i "/^\[$blockName\]/,/^\[/ {/^\[$blockName\]/b;/^\[/b;s:^$keyName*=.*:$keyName=$keyValue:g;}" $filePath`
    keyValue=$(echo $keyValue |sed s/[[:space:]]//g)
    return`sed -i "/^\[$blockName\]/,/^\[/ {/^\[$blockName\]/b;/^\[/b;s ^$keyName*=.* $keyName=$keyValue g;}" $filePath`
}

#########################
##                                                 ##
##             非框架通用实现          ##
##                                                  ##
#########################
ftBashHistory()
{
    local ftEffect=处理bash历史记录
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    # 环境校验
    [ "$(whoami)" == "root" ] || [[ -z "$isUseXbashHistory" ]] && return
    #参数解析
    local filePathBashHistory=${dirPathHome}/.bash_history
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   #显示bash命令历史存储路径
#    ftBashHistory -p
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p )    echo ${filePathBashHistory} ;return
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    local bashHistorySize filePathBashHistoryArchive filePathBashHistoryArchiveTemp
    [ ! -d $dirPathHome ]  && errorContent="${errorContent}\\n[迷路中，请稍等]dirPathHome=$，dirPathHome"
    [ ! -f $filePathBashHistory ] && errorContent="${errorContent}\\n[历史记录为空]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteItem -h && return

    filePathBashHistoryArchive=${filePathBashHistory}_archive
    filePathBashHistoryArchiveTemp=${filePathBashHistoryArchive}_temp

    #备份历史记录
    [ -f $filePathBashHistory ] && cat $filePathBashHistory >> $filePathBashHistoryArchive
    #历史去重
    sort -k2n $filePathBashHistoryArchive | awk '{if ($0!=line) print;line=$0}' >${filePathBashHistoryArchiveTemp} \
    && mv $filePathBashHistoryArchiveTemp $filePathBashHistoryArchive

    #历史扩容
    if [[ -f $rFilePathXbashDBUser ]]; then
        bashHistorySize=$(ftIniGetValue  $rFilePathXbashDBUser xbash bashHistoryThresholdSize)
    else
        # user database 初始化
        [[ ! -d "${rDirPathXbashModuleUser}" ]] && mkdir $rDirPathXbashModuleUser > /dev/null
        [[ -f "$rFilePathXbashDBUserExcepmale" ]] && cp ${rFilePathXbashDBUserExcepmale} ${rFilePathXbashDBUser} \
        || echo -e "\033[1;31m用户独立配置初始化失败,模版不存在:\n${rFilePathXbashDBUserExcepmale}\033[0m"
    fi

    export HISTSIZE=$bashHistorySize
    export HISTFILESIZE=$bashHistorySize
}

ftDevAvailableSpace()
{
    local ftEffect=设备可用空间
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftDevAvailableSpace [dirPathTraget] [[isReturn]]
#    ftDevAvailableSpace /media/test
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPathTraget=$1 isReturn=$2
    local valCount=1 errorContent
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTraget" ] && errorContent="${errorContent}\\n[设备路径不存在]dirPathTraget=$dirPathTraget"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDevAvailableSpace -h && return

    #实现主体
     local devAvailableSIzeList=$(df -lh | awk '{print $4}')
     local devMountDirPathList=($(df -lh | awk '{print $6}'))
     local indexDevName=0
     local devMountDirPath
     for size in ${devAvailableSIzeList[*]} ; do
            devMountDirPath=${devMountDirPathList[indexDevName]}
            if [[ "$devMountDirPath" = "$dirPathTraget" ]]; then
                    if [[ $size == *T ]];then
                            size=${size//T/}
                            size=${size%.*}
                            ((size*=1024))
                            ((size*=1024))
                    elif [[ $size == *G ]];then
                            size=${size//G/}
                            size=${size%.*}
                            ((size*=1024))
                    else
                            size=${size//M/}
                    fi
                    echo $size|awk ' {print int ($0)} '
                    break
            fi
            ((indexDevName+=1))
    done
}

ftLanguageUtil()
{
    local ftEffect=语言缩写转换
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftLanguageUtil "ar_IL bn_BD my_MM zh_CN"
#    ftLanguageUtil "阿拉伯语 孟加拉语 缅甸语 简体中文"
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local ftLanguageContent="${1}" filePathDataBase=$rFilePathXbashDBBase
    local errorContent
    [ -z "$ftLanguageContent" ] && errorContent="${errorContent}\\n[语言信息为空]ftLanguageContent=$ftLanguageContent" ;
    [ ! -f "$filePathDataBase" ] && errorContent="${errorContent}\\n[语言转化配置文件不存在]filePathDataBase=$filePathDataBase"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftLanguageUtil -h && return

    #实现主体
    local returnVal
    local allList=($(ftIniGetValue $filePathDataBase languageList allList))
    local shortList=($(ftIniGetValue $filePathDataBase languageList shortList))

    local ftLanguageContent2=${ftLanguageContent//_/}
    ftLanguageContent2=${ftLanguageContent2// /}

    local sourceList=(${shortList[@]})
    local tragetList=(${allList[@]})
    if [[ ! "$ftLanguageContent2" =~  ^[a-zA-Z]+$ ]]; then
        sourceList=(${allList[@]})
        tragetList=(${shortList[@]})
    fi

    local orderIndex=0
    for lc in ${ftLanguageContent[@]} ; do
        title="参数[${lc}] 转换失败"
        index=0
        for base in ${sourceList[@]} ; do
            if [ $lc = $base ];then
                returnVal="${returnVal} ${tragetList[index]}"
                ((orderIndex+=1))
                break;
            elif [[ $base =~ "/" ]] && [[ $base =~ $lc ]]; then
                returnVal="${returnVal} [${lc}]>${tragetList[index]}>[${base}]"
                title=${lc}可能存在多种结果
            elif((${#sourceList[@]}==$(($index + 1)) ));then
                echo -n "base=${base}"
                ftEcho -e $title
            fi
            ((index+=1))
        done
    done
    echo ${returnVal[@]}
}

ftInitDevicesList()
{
    local ftEffect=初始化存储设备的列表
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local devMinAvailableSpace=0  # 设备最小可用空间，小于则视为无效.单位M
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftInitDevicesList [可用空间/单位默认为MB]
#    ftInitDevicesList 4096M
#========================================================="; return ;;
        # 变量参数解析部分==============
        -s )   devMinAvailableSpace="${arg2:-'0'}"
                devMinAvailableSpace=${devMinAvailableSpace,,}
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    local devMinAvailableSpaceTemp=$devMinAvailableSpace
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//g/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//m/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//k/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//b/}
    [ -z "$rDirPathXbash" ] && errorContent="${errorContent}\\n[默认用户名]rUserName=$rUserName"
    [ -z "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[默认用户的home目录]rDirPathUserHome=$rDirPathUserHome"
    ( ! echo -n $devMinAvailableSpaceTemp | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[可用空间限制]devMinAvailableSpace=$devMinAvailableSpace"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftInitDevicesList -h && return

    #实现主体
    local indexDevMount=0 indexDevName=0
    local dirPathHome=$rDirPathUserHome #(${rDirPathUserHome/$rUserName\//$rUserName})
    local sizeHome=$(ftDevAvailableSpace $dirPathHome)
    local devNameDirPathList=$(df -lh | awk '{print $1}')
    local devMountDirPathList=($(df -lh | awk '{print $6}'))

    devMinAvailableSpace=${devMinAvailableSpace//b/}
    if [[ $devMinAvailableSpace =~ "g" ]];then
            devMinAvailableSpace=${devMinAvailableSpace//g/}
            (( devMinAvailableSpace*=1024 ))
    elif [[ $devMinAvailableSpace =~ "m" ]];then
            devMinAvailableSpace=${devMinAvailableSpace//m/}
    elif [[ $devMinAvailableSpace =~ "k" ]];then
            devMinAvailableSpace=${devMinAvailableSpace//k/}
            ((devMinAvailableSpace/=1024))
    fi

    unset mXbashModuleDataDevicesList
    [ -n "$sizeHome" ] && (( $sizeHome>=$devMinAvailableSpace )) && mXbashModuleDataDevicesList=$dirPathHome && indexDevMount=1
    #开始记录设备文件
    for dir in ${devNameDirPathList[*]} ;do
            devMountDirPath=${devMountDirPathList[indexDevName]}
            if [[ $dir =~ "/dev/" ]] && [[ $devMountDirPath != "/" ]];then
                    sizeTemp=$(ftDevAvailableSpace $devMountDirPath)
                    [[ -z "sizeTemp" ]] && continue
                    # 确定目录已挂载,设备可用空间大小符合限制
                    if (( $devMinAvailableSpace==0 ))||(( $sizeTemp>$devMinAvailableSpace )); then
                        if mountpoint -q $devMountDirPath;then
                            mXbashModuleDataDevicesList[$indexDevMount]=$devMountDirPath
                            ((indexDevMount+=1))
                        fi
                    fi
            fi
            ((indexDevName+=1))
    done
    export mXbashModuleDataDevicesList #=${mXbashModuleDataDevicesList[*]}
}

_adb()
{
    local ftEffect=adb修正工具对应的参数补全实现
    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    case "${COMP_WORDS[1]}" in
                    -k)         COMPREPLY=( $(compgen -W 'home back menu down up lift right down  power' -- $curr_arg ) )
                                  ;;
                    install)  COMPREPLY=( $(compgen -W "-l -r -s" -- $curr_arg ) )
                                # case "${COMP_WORDS[2]}" in
                                #                 -l|-r|-s)  if [[ -n "$(ls -l |grep ".apk")" ]]; then
                                #                                     COMPREPLY=( $(compgen -o filenames -W "`ls *.apk`" -- ${cur}) );
                                #                                 fi ;;
                                # esac
                                ;;
                    shell)  COMPREPLY=( $(compgen -W 'am pm input screencap screenrecord getprop dumpsys start text setprop start stop' -- $curr_arg ) );
                                case "${COMP_WORDS[2]}" in
                                                dumpsys)  COMPREPLY=( $(compgen -W 'notification cpuinfo meminfo activity' -- $curr_arg ) ); ;;
                                                input)  COMPREPLY=( $(compgen -W 'keyevent text' -- $curr_arg ) ); ;;
                                esac
                                ;;
                    logcat)  COMPREPLY=( $(compgen -W ' \"*:E\"  ' -- $curr_arg ) )
                                ;;
                    *)  COMPREPLY=( $(compgen -W 'push pull sync shell emu logcat forward jdwp install uninstall bugreport backup restore help version wait-for-device start-server kill-server get-state get-serialno get-devpath status-window remount root usb reboot disable-verity' -- $curr_arg ) ); ;;
      esac
}
complete -F _adb -A file adb
adb()
{
    local ftEffect=adb修正工具

    local dirPathCode=$ANDROID_BUILD_TOP
    local filePathAdbNow=$(which adb)
    local filePathAdbLocal=/usr/bin/adb
    local filePathDataBase=$rFilePathXbashDBBase

    #环境校验
    # if [ -z "$filePathAdbNow" ]||[ ! -d "$ANDROID_SDK" ];then
    [ ! -d "$ANDROID_SDK" ] && echo -e "#===============[ ${ftEffect} ]的使用环境说明=============\n#    Android SDK 环境异常，请查看配置\n#=========================================================" && return

    if [[ -f "$filePathAdbNow" ]]; then
        local dirPathLocal=$(pwd)
        local  filePathAdb=${dirPathCode}/out/host/linux-x86/bin/adb
        if [[ "$dirPathLocal" = "$dirPathCode" ]] && [[ -f "$filePathAdb" ]]; then
            if [[ "$filePathAdbNow" != "$filePathAdb" ]]; then
                local pid=$(lsof -i:5037  |grep adb |awk '{print $2}')
                [[ -f "$filePathAdbLocal" ]] && echo $userPassword | sudo -p '' -S mv $filePathAdbLocal ${filePathAdbLocal}2
                ftRestartAdb
            fi
        fi
    else
        if [[ ! -f "${filePathAdbLocal}" ]]; then
            if [[ -f "${filePathAdbLocal}2" ]]; then
                echo $userPassword | sudo -p '' -S mv ${filePathAdbLocal}2 $filePathAdbLocal
            else
                local filePath=${ANDROID_SDK}/platform-tools/adb
                [[ ! -f "$filePath" ]] && ftEcho -e "Android SDK 配置 失败，文件不存在：$filePath" && return
                echo $userPassword | sudo  -p ''  -S ln -s  ${ANDROID_SDK}/platform-tools/adb $filePathAdbLocal
            fi
            ftRestartAdb
        fi
        filePathAdbNow=$filePathAdbLocal
    fi

    if [[ "$1" = "-k" ]]; then
        [ ! -f "$filePathDataBase" ] && ftEcho -e "数据库文件不存在]filePathDataBase=$filePathDataBase" && return

        local TagName=androidKeyCode
        local keyCode=$(ftIniGetValue $filePathDataBase androidKeyCode $2)

        [[ -z "$keyCode" ]] && ftEcho -e "未知配置,请查看:$filePathDataBase" && return
        $filePathAdbNow shell input keyevent $keyCode
        return
    fi

     $filePathAdbNow "$@"
}

ftCleanGarbage()
{
    local ftEffect=清空回收站
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    ftInitDevicesList
    local isAutoExit sleepTime
    local errorContent arg arg2 ;for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
     --exception) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    禁止在高权限下运行,转化普通用户后，再次尝试
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    自动退出
#    ftCleanGarbage -e
#    可简化 [ftCleanGarbage -e] 为 [xcg]
#
#    延时清理
#    ftCleanGarbage -t 时间
#========================================================="; return ;;
        # 变量参数解析部分==============
        -e ) isAutoExit=true
          ;;
        -t ) sleepTime="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #环境校验
    [[ "$(whoami)" != "$rUserName" ]]||[[ "$(whoami)" = "root" ]] && ftCleanGarbage --exception && return
    [ -z "$mXbashModuleDataDevicesList" ] && errorContent="${errorContent}\\n[被清空回收站的设备的目录列表]mXbashModuleDataDevicesList=${mXbashModuleDataDevicesList[@]}"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCleanGarbage -h  && return

    #实现主体
    local dirPathLocal=$(pwd)
    local baseList=($(ftIniGetValue $rFilePathXbashDBBase CleanGarbageInfo list))

    if [[ -n $sleepTime ]]; then
        tput sc
        for i in $(seq -w $sleepTime -1 1) ; do
            tput rc;tput ed
            echo -ne "\033[1;31m将在${i}秒后开始清理，ctrl+c 取消\033[0m"
            sleep 1
        done
    fi
    for dirDevPath in ${baseList[*]} ${mXbashModuleDataDevicesList[*]}  ${rDirPathUserHome}; do
        if [ -d ${dirDevPath}/.Trash-1000 ];then
            dirDevPath=${dirDevPath}/.Trash-1000
        elif [ -d ${dirDevPath}/.local/share/Trash ];then
            dirDevPath=${dirDevPath}/.local/share/Trash
        else
            continue
        fi

        cd $dirDevPath && trap '[ -d files ] && cd $dirPathLocal && exit' SIGINT

        [ ! -d empty ] && mkdir empty
        rsync --delete-before -d -a -H -v --progress --stats empty/ files/
        rm -rf files/*
        trap SIGINT
    done
    cd $dirPathLocal
    trap SIGINT
    [[ -n "$isAutoExit" ]] && exit
}

ftKillApplicationByPackageName()
{
    local ftEffect=kill掉包名为packageName的应用
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftKillApplicationByPackageName
#
#    ftKillApplicationByPackageName [packageName]
#    ftKillApplicationByPackageName com.android.settings
#
#    可简化 [ftKillApplicationByPackageName] 为 [xk] ,其他参数不变
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local packageName=$1
    local valCount=1 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$packageName" ] && errorContent="${errorContent}\\n[应用包名]packageName=$packageName"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftKillApplicationByPackageName -h && return

    #实现主体
    #adb连接状态检测
    ftAdbContect ; [[ -z "${autoTestDeviceId}" ]] && return
    local deviceId=${autoTestDeviceId}

    while true; do case "$packageName" in
        systemui)   packageName="com.android.systemui"  ;break;;
        launcher3|launcher) packageName="com.android.launcher3"  ;break;;
        monkey)     packageName="com.android.commands.monkey"  ;break;;
    * ) break;;esac;done

    if [[ -n "$(adb shell ps | grep $packageName | awk '{print $2}')" ]]; then
        adb -s $deviceId root > /dev/null
        adb -s $deviceId remount > /dev/null
        adb -s $deviceId shell am force-stop $packageName || ftEcho -e "am force-stop $packageName fail"
        for pid in $(adb -s $deviceId shell ps | grep $packageName | awk '{print $2}'); do adb -s $deviceId shell kill $pid&& ftEcho -s "kill pid ${pid}"  ;done
    elif [[ -z "$(adb -s $deviceId shell pm list packages|grep $packageName)" ]]; then
         ftEcho -e "包名[${packageName}]不存在，请确认"
    fi
}

ftLogcatApplicationByTag()
{
    local ftEffect=打印指定包名输出或包含TAG的log
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local tagContent=$1 vContent=$2 flagError packageName isUserPackageName
    local arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#     打印所有log
#    ftLogcatApplicationByTag
#
#     打印包名为 com.android.settings的应用输出的log
#    ftLogcatApplicationByTag -p com.android.settings
#
#     打印包含123456的log
#    ftLogcatApplicationByTag 123456
#
#     打印包含123456 不包含777  的log
#    ftLogcatApplicationByTag 123456 7777
#
#    可简化 [ftLogcatApplicationByTag] 为 [xl] ,其他参数不变
#
#     打印包含123456 不包含777  的错误 log
#    ftLogcatApplicationByTag -e 123456 7777
#    可简化 [ftLogcatApplicationByTag -e] 为 [xle] ,其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p ) packageName="${arg2}"
               vContent="${arg3}"
               isUserPackageName=true
          ;;
        -e ) flagError="*:E"
            if [[ -z "$packageName" ]]; then
                tagContent=$2
                vContent=$3
            fi
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #实现主体
    #adb连接状态检测
    ftAdbContect ; [[ -z "${autoTestDeviceId}" ]] && return
    local deviceId=${autoTestDeviceId}

    [ -z "${flagError}" ] && adb -s $deviceId logcat -c
    if [[ "$isUserPackageName" = "true" ]]; then
        while true; do case "$packageName" in
            systemui)   packageName="com.android.systemui"  ;break;;
            launcher) packageName="com.android.launcher3"  ;break;;
            launcher3) packageName="com.android.launcher3"  ;break;;
        * ) break;;esac;done
        local pid=$(adb -s $deviceId shell ps | grep $packageName | awk '{print $2}')
        [[ -z "$vContent" ]] && adb -s $deviceId logcat "${flagError}" |grep "${pid}"
        adb -s $deviceId logcat "${flagError}" |grep "${pid}" #|grep -v "${vContent}"
    elif [ -z "$tagContent" ];then
        adb -s $deviceId logcat "${flagError}"
    else
        [[ -z "$vContent" ]] && adb -s $deviceId logcat "${flagError}" |grep -i "${tagContent}" && return
        adb -s $deviceId logcat "${flagError}" |grep -i "${tagContent}" |grep -v "${vContent}"
    fi
}

ftRestartAdb()
{
    local ftEffect=重启adbSever
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftRestartAdb 可简化为 xr -a
#
#    ftRestartAdb [无参]
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$userPassword" ] && errorContent="${errorContent}\\n[默认用户密码]userPassword=$userPassword"
    if [ -n "$errorContent" ];then
            ftEcho -eax "$errorContent \\n请查看下面说明:"
            ftRestartAdb -h
            return
    fi
    #实现主体
    echo $userPassword | sudo  -p '' -S adb kill-server >/dev/null
    ftEcho -s "server kill ......"
    sleep 2
    echo $userPassword | sudo  -p '' -S adb start-server >/dev/null
    ftEcho -s "server start ......"
    adb devices
}

ftMtkFlashTool()
{
    local ftEffect=mtk下载工具
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftMtkFlashTool 可简化为 xd
#
#    ftMtkFlashTool 无参
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local flashToolPath="$(ftIniGetValue $rFilePathXbashDBUser MtkSpFlashToolVersion toolsPath)"
    local errorContent
    [ ! -f "$flashToolPath" ] && errorContent="${errorContent}\\n[mtk下载工具不存在]flashToolPath=$flashToolPath"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的出现错误:${errorContent}\\n" && return

    #实现主体
    echo "$(echo "$userPassword" | sudo -S -p '' echo " " > /dev/null)" >/dev/null
    sudo $flashToolPath
}

complete -W "create new" ftBootAnimation
ftBootAnimation()
{
    local ftEffect=生成开关机动画
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    请进入动画资源目录后执行xc bootanim xxx
#    ftBootAnimation [edittype] [path]
#
#    直接生成动画包，不做其他操作，不确认资源文件是否有效
#    ftBootAnimation create /home/xxxx/test/bootanimation2
#
#    初始化生成bootanimation2.zip所需要的东东，然后生成动画包
#    ftBootAnimation new /home/xxxx/test/bootanimation2
#========================================================="; return ;;
    * ) break;; esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local editType=$1 dirPathAnimation=$2 dirPathBase=$(pwd)
    local valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$dirPathAnimation" ] && errorContent="${errorContent}\\n[动画资源目录]dirPathAnimation=$dirPathAnimation"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBootAnimation -h && return

    #实现主体
    while true; do
    case "$editType" in
    create)
        #默认运行前提环境
        #所在文件夹为动画包解压生成的，也就是该参数默认只能重新打包
        local dirNamePackageName=${dirPathAnimation##*/}.zip
        local fileConfig=$(ls $dirPathAnimation|grep '.txt')

        ftEcho -r  "请输入动画包的包名(回车默认animation):"
        read customPackageName
        [ ${#customPackageName} != 0 ] && dirNamePackageName=${customPackageName}.zip

        if [ -z "$dirNamePackageName" ]||[ -z "$fileConfig" ];then
            ftEcho -e "函数[${ftEffect}]运行出现错误，请查看函数"
            echo dirNamePackageName=$dirNamePackageName
            echo fileConfig=$fileConfig
        fi

        cd $dirPathAnimation
        zip -r -0 ${dirNamePackageName} */* ${fileConfig} >/dev/null
        cd $dirPathBase

        while true; do
        ftEcho -y 已生成${dirNamePackageName}，是否清尾
        read -n 1 sel
        case "$sel" in
            y | Y )
                local filePath=/${rDirPathUserHome}/${dirNamePackageName}
                if [ -f $filePath ];then
                    while true; do
                    echo
                    ftEcho -y 有旧的${dirNamePackageName}，是否覆盖
                    read -n 1 sel
                    case "$sel" in
                        y | Y )    break;;
                        n | N)    mv $filePath /${rDirPathUserHome}/${dirNamePackageName/.zip/_old.zip};break;;
                        q |Q)    exit;;
                        * ) ftEcho -e 错误的选择：$sel
                            echo "输入q，离开" ;;
                    esac
                    done
                fi
                mv ${dirPathAnimation}/${dirNamePackageName} $filePath&&
                rm -rf $dirPathAnimation
                break;;
            n | N| q |Q)  exit;;
            * )    ftEcho -e 错误的选择：$sel
                echo "输入n，q，离开";;
        esac
        done
        break;;
    new)
        local dirNamePart0=part0 dirNamePart1=part1 fileNameDesc=desc.txt fileNameLast
        local dirNameAnimation=animation

        dirPathAnimationSourceRes=$dirPathAnimation
        cd $dirPathAnimationSourceRes

        if [[ -z $(ls $dirPathAnimationSourceRes) ]];then
            ftEcho -ex 空的动画资源，请确认[${dirPathAnimationSourceRes}]是否存在动画文件
        else
            filelist=$(ls $dirPathAnimationSourceRes)
            local dirPathLocal=$PWD
            cd $dirPathAnimationSourceRes && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT
            for file in ${filelist[@]} ; do [ ! -f "$file" ] && ftEcho -ex "动画资源包含错误类型的文件[${file}]，请确认" && break ;done
            cd $dirPathLocal
            trap SIGINT
        fi

        dirPathAnimationTraget=/${rDirPathUserHome}/${dirNameAnimation}

        if [ -d $dirPathAnimationTraget ]||[[ -n $(ls $dirPathAnimationTraget) ]] ;then
            while true; do
            ftEcho -y ${ftEffect}的目标文件[${dirPathAnimationTraget}]夹非空，是否删除重建
            read -n 1 sel
            case "$sel" in
                y|Y) rm -rf $dirPathAnimationTraget
                        break;;
                n|N|q|Q)  exit;;
                *) ftEcho -e 错误的选择：$sel
                    echo "输入n，q，离开";;
            esac
            done
        fi
        mkdir  -p ${dirPathAnimationTraget}/${dirNamePart0}
        mkdir      ${dirPathAnimationTraget}/${dirNamePart1}
        touch  ${dirPathAnimationTraget}/${fileNameDesc}

        #文件名去空格
        for loop in $(ls -1 | tr ' '  '#') ; do mv  "$(echo $loop | sed 's/#/ /g' )"  "$(echo $loop |sed 's/#//g')"  2> /dev/null ;done

        local file1=${filelist[0]} file1=${file1##*.}
        [ $file1 != "jpg" ] && [ $file1 != "png" ] && ftEcho -e 特殊格式[${file1}]动画资源文件，生成包大小可能异常

        #文件重命名
        index=0
        for file in $filelist ; do
            a=$((1000+$index))
            # 重命名图片，复制到part0
            fileNameLast=${a:1}.${file##*.}
            cp  $file  ${dirPathAnimationTraget}/${dirNamePart0}/${fileNameLast}
            ((index+=1))
        done
        # 复制最后一张图片到part1
        cp  ${dirPathAnimationTraget}/${dirNamePart0}/${fileNameLast} ${dirPathAnimationTraget}/${dirNamePart1}/${fileNameLast}

        # 图片的宽    图片的高   每秒显示的帧数
        # 标识符    循环的次数  阶段切换间隔时间 对应图片的目录
        # 标识符    循环的次数  阶段切换间隔时间 对应图片的目录
        # 480           250       15
        # p               1           0            part0
        # p               0           10          part1

        local resolutionWidth resolutionHeight frameRate
        local cycleCount0=1 cycleCount1=0
        while [ -z "$resolutionWidth" ] \
            ||[ -z "$resolutionHeight" ] \
            ||[ -z "$frameRate" ] \
            ||[ -z "$cycleCount0" ] \
            ||[ -z "$cycleCount1" ]; do
                if [ -z "$resolutionWidth" ];then
                    ftEcho -r  请输入动画的宽:
                    read resolutionWidth
                elif [ -z "$resolutionHeight" ]; then
                    ftEcho -r  请输入动画的高:
                    read resolutionHeight
                elif [ -z "$frameRate" ]; then
                    ftEcho -r  请输入动画的帧率:
                    read frameRate
                elif [ -z "$cycleCount0" ]; then
                    ftEcho -r  请输入part0的循环次数[0为无限次数][默认为1]:
                    read cycleCount0
                elif [ -z "$cycleCount1" ]; then
                    ftEcho -r  请输入part1的循环次数[0为无限次数][默认为0]:
                    read cycleCount1
                fi
        done

        #生成desc.txt
        local enterLine="\n"
        local  content="$resolutionWidth $resolutionHeight $frameRate"
        content=${content}${enterLine}"p $cycleCount0 0 part0"
        content=${content}${enterLine}"p $cycleCount1 0 part1"
        echo -e "${content}" >${dirPathAnimationTraget}/${fileNameDesc}

        # 生成动画包
        ftBootAnimation create $dirPathAnimationTraget
        break;;
     * )
        ftEcho -e "函数[${ftEffect}]参数错误，请查看函数使用示例"
        ftBootAnimation -h
        break;;
    esac
    done
}

ftGlobalization()
{
    local ftEffect=生成国际化所需的xml文件
    local isEnable=false

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftGlobalization 无参数
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[默认用户的home目录]rDirPathUserHome=$rDirPathUserHome"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGlobalization -h && return

    #实现主体
    local filePath=${rDirPathUserHome}/tools/xls2values/androidi18nBuilder.jar
    if [ -f $filePath ];then
        $filePath
    else
        ftEcho -e "[${ftEffect}]找不到[$filePath]"
    fi
}

ftPowerManagement()
{
    local ftEffect=延时免密码的做到关机重启注销
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   下面操作不指定时间默认都为10秒
#
#    延时免密码关机，
#    ftPowerManagement shutdown 时长[秒]
#    可简化 [ftPowerManagement shutdown] 为 [xs] ,其他参数不变
#
#    延时免密码重启
#    ftPowerManagement reboot 时长[秒]
#    可简化 [ftPowerManagement reboot] 为 [xss] ,其他参数不变
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local edittype=$1 timeLong=$2 filePathFlag=/tmp/xbashPowerManagementFlag
    timeLong=${timeLong:-$2}
    timeLong=${timeLong:-'10'}
    local errorContent
    [ -z "$userPassword" ] && errorContent="${errorContent}\\n[用户密码为空]userPassword=$userPassword"
    [ -z "$edittype" ] && errorContent="${errorContent}\\n[操作参数为空]edittype=$edittype"
    ( ! echo -n $timeLong | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[倒计时时长无效]timeLong=$timeLong"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPowerManagement -h && return

    #实现主体
    while true; do
    case "$edittype" in
        shutdown )
                touch $filePathFlag
                tput sc
                for i in $(seq -w $timeLong -1 1) ; do
                    tput rc;tput ed
                    echo -ne "\033[1;31m将在${i}秒后关机，ctrl+c 取消\033[0m"
                    sleep 1
                done
                echo $userPassword | sudo   -p '' -S shutdown -h now
                break;;
        reboot)
                touch $filePathFlag
                tput sc
                for i in $(seq -w $timeLong -1 1) ; do
                    tput rc;tput ed
                    echo -ne "\033[1;31m将在${i}秒后重启，ctrl+c 取消\033[0m";
                    sleep 1
                done
                echo $userPassword | sudo   -p '' -S reboot
                break;;
        logout)
                tput sc
                for i in $(seq -w $timeLong -1 1) ; do
                    tput rc;tput ed
                    echo -ne "\033[1;31m将在${i}秒后注销，ctrl+c 取消\033[0m";
                    sleep 1
                done
                /usr/bin/gnome-session-quit --logout --force
                break;;
        * ) ftEcho -e 错误的选择：$sel
            echo "输入q，离开"
            break;;
    esac
    done
}

ftReduceFileList()
{
    local ftEffect=精简动画帧文件
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftReduceFileList 保留的百分比 目录
#    ftReduceFileList 60 /home/xxxx/temp  #由于水平有限，实现对60%和50%之类的比例不敏感
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    if (( $#==2 ));then
        local percentage=$1 dirPathFileList=$2
    elif (( $#==1 ));then
        local dirPathFileList=$1 percentage=100
        ftEcho -r  "请输入保留的百分比:"
        read percentage
    fi
    local editType=del valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    if [ -z "$percentage" ]\
        ||( ! echo -n $percentage | grep -q -e "^[0-9][0-9]*$")\
        ||(( $percentage<0 ))\
        ||(( $percentage>100 ));then errorContent="${errorContent}\\n[百分比取值错误]percentage=$percentage" ;fi
    [ ! -d "$dirPathFileList" ] && errorContent="${errorContent}\\n[目标目录]dirPathFileList=$dirPathFileList"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftReduceFileList -h && return

    #实现主体
    [[ -z $(ls $dirPathFileList) ]] && ftEcho -ex 空的资源目录，请确认[${dirPathFileList}]是否存在资源文件

    (( $percentage>50 )) && percentage=$((100 - $percentage)) && editType=surplus
    continueThreshold=$((100 / ${percentage} ))

    local dirNameFileListBase=${dirPathFileList##*/}
    local dirNameFileListBackup=${dirNameFileListBase}_bakup
    local dirPathFileListBackup=${dirPathFileList%/*}/${dirNameFileListBackup}
    if [ ! -d $dirPathFileListBackup ];then
        mkdir $dirPathFileListBackup
        cp -rf ${dirPathFileList}/*  $dirPathFileListBackup
    fi

    fileList=$(ls $dirPathFileList)
    index=0
    for file in $fileList ; do
        ((index+=1))
        if (( $(expr $index % $continueThreshold)== 0 ));then
            [ $editType = "surplus" ] && continue
        elif [ $editType = "del" ];then
            continue;
        fi
        rm -f ${dirPathFileList}/$file
    done
}

complete -W "-h -d -l -ap -as -r -rs" ftReNameFile
ftReNameFile()
{
    local ftEffect=批量重命名文件
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local isAutoName isAddName dirPathFileList  fileNameAddPrefix fileNameAddSuffix fileTagBase fileTagNew fileSuffixTagBase fileSuffixTagNew startNumber
    local fileNameLength=4
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   使用固定长度的文件名，后缀名不变
#       ftReNameFile -d 目录 -l 修改后的文件长度
#
#   使用固定长度的文件名，后缀名不变,从xx开始计数
#       ftReNameFile -d 目录 -l 修改后的文件长度 -s xx
#
#   文件名加前缀
#        ftReNameFile -d 目录 -ap 前缀
#
#   文件名加后缀
#        ftReNameFile -d 目录 -as 后缀
#
#   替换文件名中指定字串，后缀名不变
#       ftReNameFile -d 目录 -r 原字串 新字串
#
#   替换后缀名中指定字串，文件名不变
#        ftReNameFile -d 目录 -rs 原字串 新字串
#========================================================="; return ;;
        # 变量参数解析部分==============
        -d ) dirPathFileList="${arg2}"
          ;;
        -l ) isAutoName=true
            fileNameLength="${arg2}"
          ;;
        -s ) startNumber="${arg2}"
          ;;
        -ap ) isAddName=true
                fileNameAddPrefix="${arg2}"
          ;;
        -as ) isAddName=true
                fileNameAddSuffix="${arg2}"
          ;;
        -r ) fileTagBase="${arg2}"
              fileTagNew="${arg3}"
          ;;
        -rs ) fileSuffixTagBase="${arg2}"
                fileSuffixTagNew="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ ! -d "$dirPathFileList" ]||[[ -z "$(ls $dirPathFileList)" ]] && errorContent="${errorContent}\\n[目标目录无效]$dirPathFileList"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftReNameFile -h && return

    #实现主体
    [[ -z $(ls $dirPathFileList) ]] && ftEcho -ex 空的资源目录，请确认[${dirPathFileList}]是否存在资源文件

    local index=0 fileName fileSuffixName itemNew
    local dirNameFileListRename=RenameFiles
    local dirPathFileListRename=${dirPathFileList}/${dirNameFileListRename}
    local dirPathLocal=$(pwd)

    [ -d $dirPathFileListRename ] && rm -rf $dirPathFileListRename
    mkdir $dirPathFileListRename
    cd "${dirPathFileList}"

    [[ -n "${startNumber}" ]] && index=$startNumber
    while read file ;do
        [ "$file" == "$dirNameFileListRename" ] && continue
        itemNew=$(echo ${file} |sed s/[[:space:]]/_/g)
        [[ "${file}" != "${itemNew}" ]] && mv "${dirPathFileList}/${file}" "${dirPathFileList}/${itemNew}" && file="${itemNew}"

        fileName=${file%.*}
        fileSuffixName=${file##*.}

        if [[ -n "${isAutoName}" ]]; then
            fileName="$(printf "%0${fileNameLength}d" "$index")"
            cp -rf "${dirPathFileList}/${file}" ${dirPathFileListRename}/${fileName}.${fileSuffixName}
            ((index+=1))
            continue
        fi

        [[ -n "${isAddName}" ]] && fileName=${fileNameAddPrefix}${fileName}${fileNameAddSuffix}
        [[ -n "${fileTagBase}" ]] && fileName="$(echo $fileName |sed s/$fileTagBase/$fileTagNew/g)"
        [[ -n "${fileSuffixTagBase}" ]] && fileSuffixName="$(echo $fileSuffixName |sed s/$fileSuffixTagBase/$fileSuffixTagNew/g)"
        cp -rf "${dirPathFileList}/${file}" ${dirPathFileListRename}/${fileName}.${fileSuffixName}
        ((index+=1))
    done < <(echo "$(ls $dirPathFileList)")
    cd "${dirPathLocal}"
}

complete -W "-b -r -s" ftMaintainSystem
ftMaintainSystem()
{
    local ftEffect=ubuntu系统维护
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local editType
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    当前用户权限过低，请转换为root 用户后重新运行
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    整理磁盘:
#    ftMaintainSystem -s
#    ftMaintainSystem --sd_finish
#
#    备份系统:
#    ftMaintainSystem -b
#    ftMaintainSystem --backup
#
#    还原备份:
#    ftMaintainSystem -r
#    ftMaintainSystem --restore
#
#    可简化 [ftMaintainSystem] 为 [xb] ,其他参数不变
#========================================================="; return ;;
    -c)
    local dirPathLocal=$2 dirPathStore=$3
    [ -d "$dirPathLocal" ] && cd $dirPathLocal
    [ -d "$dirPathStore" ] && rm -rf $dirPathStore
    ftIniDeleteTag -p $filePathVersionInfo -t $infoVersionName
    trap SIGINT
    return ;;
        # 变量参数解析部分==============
        -s )   editType=sdFinish    ;;
        -b )   editType=backup     ;;
        -r )   editType=restore      ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #环境校验
    [ "$(whoami)" != "root" ] && ftMaintainSystem --env && return
    [[ -z $(which pigz) ]] && ftMaintainSystem --rely "pigz" && return
    #变量校验
    local filePathMaintain=${rDirPathXbashModuleMaintain}/${rFileNameXbashModuleMaintain}
    [ -z "$editType" ] && errorContent="${errorContent}\\n[你想做啥哩]editType=$editType"
    [ ! -f "$filePathMaintain" ] && errorContent="${errorContent}\\n[维护脚本不存在]filePathMaintain=$filePathMaintain"
    [ -n "$errorContent" ] && ftEcho -ea "[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMaintainSystem -h && return

    #实现主体
    source $filePathMaintain
    local  filePathVersionInfoVersion=${rDirPathXbashModuleMaintain}/versionInfo.database
    local  filePathVersionInfoMaintain=${rDirPathXbashModuleMaintain}/maintain.database

    case "$editType" in
        backup )
                    local dirPathLocal=${PWD}
                    local filePathVersionInfo=$filePathVersionInfoVersion
                    local infoVersionName=backup_${rUserName}_$(date -d "today" +"%Y%m%d")
                    local fileNameVersion=${infoVersionName}.$(ftIniGetValue $filePathVersionInfoMaintain ubuntuMaintainConfigInfo backupPackageSuffixName)
                    # 进入根目录
                        cd /
                    #清理无效版本记录
                        ftCleanUpInvalidRecords -p $filePathVersionInfoVersion
                    #预写入版本信息
                        ftIniCreateFileOrTag -a -p $filePathVersionInfo -t $infoVersionName -l "\
                            fileName=$fileNameVersion \
                            backupType=null \
                            dirPathStore=null \
                            backupPackageNote=null \
                            MD5= \
                            hwCpu=null \
                            hwMainboard=null \
                            swSystemVersion=null \
                            swSystemType=null"
                        trap 'ftMaintainSystem -c $dirPathLocal $dirPathStore && exit' SIGINT
                    #选择存放备份包的设备
                        ftSetBackupDevDir -b -p $filePathVersionInfo -v $infoVersionName
                    #选择备份类型
                        ftSetBackupType -p $filePathVersionInfo -v $infoVersionName -pm $filePathVersionInfoMaintain
                    #记录备份包相关系统信息
                        ftSystemEnv -a -p $filePathVersionInfo -v $infoVersionName
                    #写入版本说明
                        ftMaintainInfoNote -a -p $filePathVersionInfo -v $infoVersionName
                    #显示当前配置信息
                        local dirPathStore=$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName  dirPathStore)
                        ftEcho -bh "备份关键信息"
                        ftEcho -s "生成的备份包：$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName fileName)"
                        ftEcho -s  "备份包的说明：$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName  backupPackageNote)"
                        ftEcho -s  "备份包保存路径：$dirPathStore"
                    #扫描设备,确认是否相同备份
                        # ftBackUpDevScanning -p $filePathVersionInfo -f $fileNameVersion -d "${mXbashModuleDataDevicesList[*]}"
                    #生成备份包
                        ftBackupOs -p $filePathVersionInfo -v $infoVersionName -pm $filePathVersionInfoMaintain
                    #记录备份包校验信息
                        local filePathStore=$dirPathStore/${fileNameVersion}
                        [ -f "$filePathStore" ] && ftMD5  -p $filePathVersionInfo -s $filePathStore && ftEcho -s "备份完成"
                    #版本信息备份
                    ftIniCreateFileOrTag -r -p ${dirPathStore}/version.info -t $infoVersionName -l "\
                            fileName=$fileNameVersion \
                            backupType=$(ftIniGetValue  $filePathVersionInfo $infoVersionName backupType) \
                            dirPathStore=$(ftIniGetValue  $filePathVersionInfo $infoVersionName dirPathStore) \
                            backupPackageNote=$(ftIniGetValue  $filePathVersionInfo $infoVersionName backupPackageNote) \
                            MD5=$(ftIniGetValue  $filePathVersionInfo $infoVersionName MD5) \
                            hwCpu=$(ftIniGetValue  $filePathVersionInfo $infoVersionName hwCpu) \
                            hwMainboard=$(ftIniGetValue  $filePathVersionInfo $infoVersionName hwMainboard) \
                            swSystemVersion=$(ftIniGetValue  $filePathVersionInfo $infoVersionName swSystemVersion) \
                            swSystemType=$(ftIniGetValue  $filePathVersionInfo $infoVersionName swSystemType)" && \
                    chmod 777 ${dirPathStore}/version.info
                    #把备份同步到不同设备上
                        # ftSynchronous -d "${mXbashModuleDataDevicesList[*]}" -s ".*\.tgz"
                    #清尾
                        cd $dirPathLocal
                        trap SIGINT
                    ;;
        restore )
                    local tagNaeMaintain=restoreConfigInfo
                    #清理无效版本记录
                        ftCleanUpInvalidRecords -p $filePathVersionInfoVersion
                    #预写入待还原版本信息
                        ftIniCreateFileOrTag -a -p $filePathVersionInfoMaintain -t $tagNaeMaintain -l "\
                                fileName=null \
                                dirPathStore=null \
                                dirPathRestoreExclude=null"
                        trap 'ftIniDeleteTag -p $filePathVersionInfoMaintain -t $tagNaeMaintain && exit' SIGINT
                    #选择存放备份包的设备
                        ftSetBackupDevDir -r -p $filePathVersionInfoMaintain -v $tagNaeMaintain
                    #选择备份包
                        ftRestoreChoiceSource -p $filePathVersionInfoVersion -pm $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #检查备份包和当前系统兼容程度
                        local fileName=$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain fileName)
                        ftSystemEnv -c -p $filePathVersionInfoVersion -v ${fileName%.*}
                    #检查备份包是否损坏
                        local dirPathStore=$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain dirPathStore)
                        ftMD5 -p $filePathVersionInfoVersion -c "${dirPathStore}/${fileName}"
                    #选择备份包覆盖的忽略路径
                        ftSetRestoreOverryList -pm $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #当前配置信息显示
                        local versionName=${fileName%.*}
                        ftEcho -bh "还原关键信息"
                        ftEcho -s  "使用的备份包：$fileName"
                        ftEcho -s  "备份包的说明：$(ftIniGetValue $filePathVersionInfoVersion $versionName backupPackageNote)"
                        ftEcho -s  "还原时将忽略目录：$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain  dirPathRestoreExclude)"
                    #执行还原操作
                        ftRestoreOperate -pm $filePathVersionInfoMaintain -t  $tagNaeMaintain -d "/"
                    #删除还原版本信息
                        ftIniDeleteTag -p $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #还原成功后重启生效
                        while true; do
                        ftEcho -y "是否重启 [回车重启]"
                        read -n 1 sel
                        [ -z "${sel}" ] && sel=y
                        case "$sel" in
                            y | Y )   ftPowerManagement reboot 5 ; break;;
                            n | q )  exit;;
                            * ) ftEcho -e 错误的选择：$sel
                                echo "输入n，q，离开";;
                        esac;done
                    #清尾
                        trap SIGINT
                    ;;
        sdFinish )
                    [[ -z $(which e4defrag) ]] && ftMaintainSystem --rely "e4defrag" && return

                    devNameDirPathList=$(df -lh | awk '{print $1}')
                    devMountDirPathList=($(df -lh | awk '{print $6}'))
                    indexDevName=0
                    indexDev=0
                    devPathList=
                    for dir in ${devNameDirPathList[*]} ; do
                            devMountDirPath=${devMountDirPathList[indexDevName]}
                            if [[ $dir =~ "/dev/" ]] && [[ $devMountDirPath != "/" ]];then
                                   printf " \e[33m %-2s \e[0m %-15s \n" [$indexDev] $dir
                                   devPathList[$indexDev]=$dir
                                   ((indexDev+=1))
                            fi
                            ((indexDevName+=1))
                    done

                    itemCount=${#devPathList[@]}
                    local num=$itemCount length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
                    ftEcho -r  "请输入对应的序号(回车默认0):"
                    read -n $length tIndex &&echo
                    #设定默认值
                    [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
                    (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return
                    e4defrag -v -c ${devPathList[$tIndex]}
                    return ;;
        * ) ftMaintainSystem -h ; return ;; esac
}

ftFind()
{
    local ftEffect=find的简单封装
    local isEnable=true
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return

    #参数解析
    local isSuffix nameAll
    local pathTarget="${1}" nameList="${2}" contentKey="${3}"
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#   使用后缀搜索
#   ftFind -s 路径 后缀列表  文件名内容[可选]
#   ftFind -s xx/xx \"java xml\" \"yyy\"
#
#   使用文件名搜索，只支持单文件名
#   ftFind 路径 文件名 文件名内容[可选]
#   ftFind xx/xx \"*.java\" \"yyy\"
#
#    可简化 [ftFind -s] 为 [xFind] ,其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -s ) isSuffix=true
              pathTarget="${2}"
              # [[ "${pathTarget}" = "./" ]] && pathTarget=$(pwd)
              nameList="${3}"
              contentKey="${4}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    [[ -z "$nameList" ]] && ftEcho -e "参数缺失，请确认" && ftFind -h && return

    if [[ -n "${isSuffix}" ]]; then
        (( $#<=3 )) && find "${pathTarget}" -name "${nameList}" && return
        nameAll=$(echo "${nameList}" | sed -e "s: :|:g")
        if [[ -n "${contentKey}" ]];then
            find "${pathTarget}" -regextype posix-extended -regex ".*\.(${nameAll})" | xargs grep -e "${contentKey}"
            return
        fi
        find "${pathTarget}" -regextype "posix-extended" -regex ".*\.(${nameAll})"
        return
    fi

    nameAll=$(echo "${nameList[@]}" | sed -e "s: ::g")
    if [[ -n "${contentKey}" ]];then
        find "${pathTarget}" ! -type d -name ${nameAll}| xargs grep -e "${contentKey}"
        return
    fi
    find "${pathTarget}" ! -type d -name ${nameAll}
}

complete -W "-p -d" ftPdfPasswordClear
ftPdfPasswordClear()
{
    local ftEffect=pdf密码批量清除
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local dirPathTarget passwordNum
    local valCount=4 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftPdfPasswordClear -d 目录或路径 -p 密码
#========================================================="; return ;;
        # 变量参数解析部分==============
        -d ) dirPathTarget="${arg2}"    ;;
        -p ) passwordNum="${arg2}"  ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which qpdf) ]] && ftPdfPasswordClear --rely "qpdf" && return
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTarget" ] && [ ! -f "$dirPathTarget" ] && errorContent="${errorContent}\\n[啥玩意]dirPathTarget=$dirPathTarget"
    [ -z "$passwordNum" ] && errorContent="${errorContent}\\n[密码不见了，帮忙找找]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPdfPasswordClear -h && return

    #实现主体
    local  itemNew
    while read item ;do
        itemNew=$(echo ${item} |sed s/[[:space:]]/_/g)
        [[ "${item}" != "${itemNew}" ]] && mv "${dirPathTarget}/${item}" "${dirPathTarget}/${itemNew}" && item="${itemNew}"
        local dirPathTemp="${dirPathTarget}/${item}"

        if [[ -d "$dirPathTemp" ]]; then
            ftPdfPasswordClear -d "${dirPathTemp}" -p "${passwordNum}"

        elif [[ -n $(echo $item |grep -i ".pdf") ]]; then
            local filePath="${dirPathTemp}"
            local filePathTemp="/tmp/temp_${item}"

            cp "${filePath}" "${filePathTemp}"
            [ ! -f "$filePath" ] && ftEcho -s "${filePath}  不存在" && continue
            qpdf --password="${passwordNum}" --decrypt "${filePathTemp}" "${filePath}" && ftEcho -s "[密码已清除] ${item}" || ftEcho -e "[密码清除失败] ${item}"
            rm "${filePathTemp}" > /dev/null

        fi
    done < <(echo "$(ls $dirPathTarget)")
}

complete -W "-f" ftApkSignature
ftApkSignature()
{
    local ftEffect=apk签名
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local filePathApk
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftApkSignature -f xxx.apk
#========================================================="; return ;;
       --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 环境未初始化
# 使用前,请先初始化
# source build/envsetup.sh && lunuch xxxxx
#========================================================="; return ;;
        # 变量参数解析部分==============
        -f ) filePathApk="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #环境校验
    local toolFilePathSignapk=out/host/linux-x86/framework/signapk.jar
    [ ! -f "$toolFilePathSignapk" ] && [ ! -d "$ANDROID_BUILD_TOP" ] && ftApkSignature --env && return
    [ -d "$ANDROID_BUILD_TOP" ] && cd $ANDROID_BUILD_TOP
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$JAVA_HOME" ] && errorContent="${errorContent}\\n[java环境未配置]缺失JAVA_HOME"
    [ ! -f "$toolFilePathSignapk" ] && errorContent="${errorContent}\\n[缺少有效的签名工具]${toolFilePathSignapk}不存在"
    [ ! -f "$filePathApk" ] && errorContent="${errorContent}\\n[你想干嘛]${filePathApk}不存在"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftApkSignature -h && return

    #实现主体
    local toolFilePathPlatformx509pem=build/target/product/security/platform.x509.pem
    local toolFilePathPlatformpk8=build/target/product/security/platform.pk8

    local fileNameApk=$(basename $filePathApk)
    local fileNameApkBase=${fileNameApk%.*}
    local fileNameApkEnd=${fileNameApk##*.}
    local fileNameApkNew=$(dirname $filePathApk)/${fileNameApkBase}_new${fileNameApkEnd}

    java -jar $toolFilePathSignapk $toolFilePathPlatformx509pem $toolFilePathPlatformpk8 $filePathApk $fileNameApkNew \
    && mv $fileNameApkNew $filePathApk&&ftEcho -s  "${filePathApk}  签名成功"|| ftEcho -s "${filePathApk}签名失败"
}

complete -W "-a -d -f -o" ftApkMergeOdex
ftApkMergeOdex()
{
    local ftEffect=合并odex和apk
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local isAutoPull fileNameApk filePathApk filePathOdex dirPathFramework
    local filePathToolResign=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/re-sign.jar
    local filePathToolSmali=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/smali-2.2.7.jar
    local filePathToolBaksmali=${DIR_PATH_ANDROID_DECOMPILE_TOOLS}/baksmali-2.2.7.jar
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    指定app名称，插上手机，执行pull和合并操作
#    ftApkMergeOdex -a xxxx
#    直接指定已存在包路径，执行合并操作
#    ftApkMergeOdex -d framework路径 -f apk路径 -o odex文件路径
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a ) fileNameApk="${arg2}"
               isAutoPull=true
          ;;
        -d ) dirPathFramework="${arg2}"
          ;;
        -f ) filePathApk="${arg2}"
          ;;
        -o ) filePathOdex="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #预处理
    if [[ "$isAutoPull" = "true" ]]; then
        [[ -z "${fileNameApk}" ]] && ftEcho -ea "函数[${ftEffect}]的参数错误,未指定app名\\n请查看下面说明:" && ftApkMergeOdex -h && return

        ftAdbContect
        [[ -z "${autoTestDeviceId}" ]] && return
        local deviceId=${autoTestDeviceId}

        local dirPathLocal=$(pwd) dirPathTarget=/tmp/mergeOdex
        [[ ! -d "$dirPathTarget" ]] && mkdir $dirPathTarget
        [[ ! -d "$dirPathTarget" ]] && ftEcho -e "初始化失败,无法新建临时目录:${dirPathTarget}" && return
        cd $dirPathTarget

        [[ "$fileNameApk" == *.apk* ]] && fileNameApk=$(echo $fileNameApk| sed -e "s:.apk::g")
        local dirPathDevices=system/app/${fileNameApk}
        [[ -n $(adb -s $deviceId shell ls system/priv-app|grep $fileNameApk) ]] && dirPathDevices=system/priv-app/${fileNameApk}

        filePathApk=${dirPathTarget}/${fileNameApk}/${fileNameApk}.apk
        filePathOdex=${dirPathTarget}/${fileNameApk}/oat/arm/${fileNameApk}.odex
        dirPathFramework=${dirPathTarget}/framework

        if [[ -n "$(ls ${dirPathFramework})" ]];then
            ftEcho -y "存在旧framework, 是否清理(回车默认清理)" && \
            read -n 1 sel && echo
            if [ -z "${sel}" ]||[[ "$sel" = "y" ]];then
             rm -rf $dirPathFramework && sel= ; else ftEcho -s "将使用旧framework" && sel=n ;fi
        fi
        if [ -z "${sel}" ]; then
            adb -s $deviceId pull $dirPathDevices ${dirPathTarget}&& ftEcho -s "pull ${fileNameApk} 完成"
            adb -s $deviceId pull system/framework/  ${dirPathTarget}&& ftEcho -s "pull framework 完成"
            cp -rf -v ${dirPathTarget}/framework/arm/* ${dirPathTarget}/framework && ftEcho -s "复制 framework/arm/* 到 framework 完成"
        fi
    fi
    #依赖校验
    [[ -z $(which zip) ]] && ftApkMergeOdex --rely "zip" && return
    #参数校验
    local errorContent
    [ -z "$JAVA_HOME" ] && errorContent="${errorContent}\\n[java环境未配置]缺失JAVA_HOME"
    [ ! -f "$filePathToolSmali" ] && errorContent="${errorContent}\\n[找不到 filePathToolSmali=${filePathToolSmali}]"
    # [ ! -f "$filePathToolResign" ] && errorContent="${errorContent}\\n[找不到 filePathToolResign=${filePathToolResign}]"
    [ ! -f "$filePathToolBaksmali" ] && errorContent="${errorContent}\\n[找不到 filePathToolBaksmali=${filePathToolBaksmali}]"

    [ ! -f "$filePathApk" ] && errorContent="${errorContent}\\n[找不到 filePathApk=${filePathApk}]"
    [ ! -f "$filePathOdex" ] && errorContent="${errorContent}\\n[找不到 filePathOdex=${filePathOdex}]"
    [ ! -d "$dirPathFramework" ] && errorContent="${errorContent}\\n[找不到 dirPathFramework=${dirPathFramework}]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftApkMergeOdex -h && return

    #实现主体
    cd $dirPathFramework

    if java -jar $filePathToolBaksmali deodex $filePathOdex ;then
        ftEcho -s "odex转smali 完成" ; else ftEcho -e "odex转smali失败" && return ;fi

    if java -jar $filePathToolSmali assemble out -o classes.dex ;then
        ftEcho -s "smali转dex 完成" ; else ftEcho -e "smali转dex失败" && return ;fi

    if zip -g $filePathApk classes.dex > /dev/null ;then
        ftEcho -s "classes.dex/apk合并 完成" ;else ftEcho -e "classes.dex/apk合并失败" && return ;fi

    if java -jar $filePathToolResign $filePathApk ;then
        ftEcho -s "apk签名 完成" ; else ftEcho -e "apk签名失败" && return ;fi

    ftEcho -s "${fileNameApk}的${ftEffect}操作成功"

    cd $dirPathLocal
}

complete -W "-h" ftDu
ftDu()
{
    local ftEffect=查找大文件
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftDu 文件数量
#    ftDu 目录 文件数量
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=2 errorContent fileCount=${1:-'10'} dirPathLocal=$(pwd) dirPathTarget=${dirPathLocal}
    (( $#>1 )) && dirPathTarget=$1 && fileCount=${2:-'$fileCount'}
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [[ ! -d "$dirPathTarget" ]] && errorContent="${errorContent}\\n目录[${dirPathLocal}]不存在"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDu -h && return

    #实现主体
    cd $dirPathTarget
    echo $userPassword | sudo  -p '' -S  du -hsx * | sort -rh | head -${fileCount}
    cd $dirPathLocal
}

complete -W "-h -f" ftAdbPush
ftAdbPush()
{
    local ftEffect=adbPush命令的简单封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local filePathSourceList fileNameSource isAutoReboot isTacitMode
    local errorContent arg  ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}}
    case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖 Android SDK
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   注意：-f 参数必须在最后使用
#
#   开启新终端,进行操作
#   ftAdbPush -c
#    可简化 [ftAdbPush -c -f] 为 [xpc] ,其他参数不变
#
#   自动push,用户选择操作
#   ftAdbPush -f 文件路径
#    可简化 [ftAdbPush -f] 为 [xp] ,其他参数不变
#
#   push完,自动重启
#   ftAdbPush -a -f 文件路径
#    可简化 [ftAdbPush -a -f] 为 [xpa] ,其他参数不变
#
#   push完,不重启
#   ftAdbPush -n -f 文件路径
#    可简化 [ftAdbPush -n -f] 为 [xpn] ,其他参数不变
#========================================================="; return ;;
       # 变量参数解析部分==============
       -c ) shift ;local valList=(${@})
             [[ ! -f "${rFilePathXbashModuleBaseAdbPush}" ]] && \
             ftEcho -s "脚本不存在:${rFilePathXbashModuleBaseAdbPush}" && return
             gnome-terminal -x bash -c "$rFilePathXbashModuleBaseAdbPush ${valList[*]}"
             return
            ;;
       -a ) isAutoReboot=true
            ;;
       -n ) isTacitMode=true
            ;;
       -f )
            local valIndex=$i
            while (( $valIndex>=0 )) ;do (( valIndex-=1 )) && shift ;done
            filePathSourceList=($@)
            ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which adb) ]] && ftAdbPush --rely "adb" && return
    #参数校验
    [ -z "$filePathSourceList" ] && errorContent="${errorContent}\\n[push的源路径不存在]filePathSourceList=$filePathSourceList"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAdbPush -h && return

    #实现主体
    #adb连接状态检测
    ftAdbContect ; [[ -z "${autoTestDeviceId}" ]] && return
    local deviceId=${autoTestDeviceId}
    adb -s $deviceId root || ( ftEcho -e "提权失败" && return )
    adb -s $deviceId remount || ( ftEcho -e "提权失败" && return )

    for filePath in ${filePathSourceList[@]}; do
            [[ ! -f "$filePath" ]] && ftEcho -e "找不到:${filePath}" && continue
            if [[ -n $(echo $filePath |grep system) ]] ;then
                fileNameSource=$(basename $filePath)
                dirPathTarget=$(echo /system${filePath#*system} | sed -e "s:/$fileNameSource::g")
                echo "push ${filePath} > ${dirPathTarget}"
                adb -s $deviceId push $filePath $dirPathTarget &&  ftEcho -s "${fileNameSource} push to [${dirPathTarget}] finish"
            else
                ftEcho -en "无法自动解析:";echo "${filePath}"
            fi
    done
    if [[ -z "$isTacitMode" ]]; then
        [[ -z "$isAutoReboot" ]] &&ftEcho -y "是否重启(回车默认重启)" && read -n 1 sel && echo
        if [ -z "${sel}" ]||[[ "$sel" = "y" ]];then adb -s $deviceId reboot && ftEcho -s "已重启设备:${deviceId} "; fi
    fi
}

complete -W "-h --help" ftUpdateSublimeSnippet
ftUpdateSublimeSnippet()
{
    local ftEffect=更新SublimetSnippet
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    无参
#    ftUpdateSublimeSnippet xxxx
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    [[ -z "$SUDO_USER" ]] && userName=$USER || userName=$SUDO_USER
    local dirPathSublimeSnippet=/home/${userName}/.config/sublime-text-3/Packages/User \
    dirPathConfigSource=/home/${userName}/xconfig/sublime_text/sublime-snippet

    [ ! -d "$dirPathConfigSource" ] && errorContent="${errorContent}\\n[配置文件不存在]dirPathConfigSource=$dirPathConfigSource"
    [ ! -d "$dirPathSublimeSnippet" ] && errorContent="${errorContent}\\n[配置文件存放位置不存在]dirPathSublimeSnippet=$dirPathSublimeSnippet"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftUpdateSublimeSnippet -h && return

    #实现主体
    local userName dirPathLocal=$(pwd)
    cd $dirPathSublimeSnippet

        while read item ;do
           ln -sf ${dirPathConfigSource}/${item}
        done < <(echo "$(ls $dirPathConfigSource)")

    cd $dirPathLocal
}

complete -W "-h --help --rely_install" ftOpenNemoTab
ftOpenNemoTab()
{
    local ftEffect=在nemo中打开新标签
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local dirPathTarget
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#     请尝试使用下面方法补全依赖
#     ftOpenNemoTab --rely_install
#========================================================="; return ;;
    --rely_install)
        ftEcho -s "开始补全依赖"
        sudo add-apt-repository ppa:webupd8team/nemo
        sudo apt-get update
        sudo apt-get install -y xclip wmctrl xdotool nemo nemo-fileroller
        sudo apt-get install -y nemo-compare nemo-media-columns nemo-pastebin nemo-seahorse nemo-share
        return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    自动补齐依赖
#    ftOpenNemoTab --rely_install
#
#    打开新标签
#    ftOpenNemoTab -p 路径
#========================================================="; return ;;
    # 变量参数解析部分==============
    -p ) dirPathTarget="${arg2}"
      ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    if [[ -z $(which xclip) ]] || [[ -z $(which wmctrl) ]] || [[ -z $(which xdotool) ]] || [[ -z $(which nemo) ]] ;then
        ftOpenNemoTab --rely ;return
    fi
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTarget" ] && errorContent="${errorContent}\\n[示例1]dirPathTarget=$dirPathTarget"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftOpenNemoTab -h && return

    #实现主体
    local windowId=$(wmctrl -xl | grep "nemo.Nemo"| awk '{print $1}')
    if [ -z "${windowId}" ]; then
        nemo "$dirPathTarget"
    else
        echo -n "$dirPathTarget" | xclip -i -sel clip
        if wmctrl -xF -R nemo.Nemo ;then
            xdotool windowfocus $windowId key ctrl+t
            sleep 0.7
            xdotool windowfocus $windowId key ctrl+l
            sleep 0.2
            xdotool windowfocus $windowId key ctrl+v
            sleep 0.1
            xdotool key enter Return
        fi
        echo -n "" | xclip -i -sel clip
    fi
}

_cdAospDirectory()
{
    local ftEffect=快速进入Aosp功能目录参数补全实现
    local isEnable=def

    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=( $(compgen -W 'app out frameworks' ) )
    case "${COMP_WORDS[1]}" in
                    app)         COMPREPLY=( $(compgen -W 'settings launcher dialer factorytest' -- $curr_arg ) )
                                  ;;
                    out)  COMPREPLY=( $(compgen -W "product productObj system commonObj " -- $curr_arg ) )
                                ;;
                    frameworks)  COMPREPLY=( $(compgen -W 'base opt ' ) );
                                case "${COMP_WORDS[2]}" in
                                                base)  COMPREPLY=( $(compgen -W 'cmd core data packages services' ) );
                                                            case "${COMP_WORDS[3]}" in
                                                                            packages)  COMPREPLY=( $(compgen -W 'systemui settingsprovider' -- $curr_arg ) ); ;;
                                                                            core)  COMPREPLY=( $(compgen -W 'java res' -- $curr_arg ) ); ;;
                                                            esac
                                                            ;;
                                esac
                                ;;
                    *)  COMPREPLY=( $(compgen -W 'app out frameworks settings launcher dialer factorytest product productObj system commonObj base opt cmd core data packages services systemui settingsprovider java res' -- $curr_arg ) ); ;;
      esac
}
complete -F _cdAospDirectory -A file ftCdAospDirectory
ftCdAospDirectory()
{
    local ftEffect=快速进入Aosp功能目录
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    [[ -n "${ANDROID_BUILD_TOP}" ]] && cd $ANDROID_BUILD_TOP || \
    if [[ ! -d "alps" ]] && [ ! -d "idh" ]; then
        if [[ ! -d "build" ]] && [[ ! -d "frameworks" ]] && [[ ! -d "ndk" ]] && [[ ! -d "dalvik" ]] && [[ ! -d "vendor" ]];then
            ftCdAospDirectory --env&& return
        fi
    fi

    local isUserFileManager dirPathTarget
    local valCount=1 errorContent arg arg2 arg3  arg4 argVal ; for ((i=1;i<=$#;i++)) ; do
    eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; eval arg4=\${$((i+3))} ; case "${arg}" in
    # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    切换终端路径
#    ftCdAospDirectory xxx xxx xxxx
#
#    在文件管理器中打开
#    ftCdAospDirectory -fm xxx xxx xxxx
#
#    可简化 [ftCdAospDirectory] 为 [xca] ,其他参数不变
#
#    xxx 说明
#    树位置代表参数自动适配顺序，函数行为以最后一个参数为准
#    在最后一个参数不存在重复时，可以直接使用最后一个参数
        ├──app
        │   └── settings / launcher / dialer / factorytest
        ├──frameworks
        │   ├── base
        │   │    ├── cmd / data / services
        │   │    ├── packages
        │   │    │     └── systemui / settingsprovider
        │   │    └── core
        │   │          └── res/ java
        │   └── opt
        └── out
             └──  commonObj / product / productObj / system
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 当前非有效AOSP目录，请确认
# 可以尝试使用 ftCdAospProject 快速进入项目
#========================================================="; return ;;
        # 变量参数解析部分==============
        -fm ) isUserFileManager=true ;;
        settings | launcher |dialer | factorytest | base | opt |cmd | core | java | res |data|\
        packages | systemui | settingsprovider | services | commonObj ) argVal="${arg}" ;;
        product |system |productObj )
                        local dirPathProduct="out/target/product"
                        while read item ;do
                           [[ -f "${dirPathProduct}/${item}/system.img" ]] && dirPathProduct=${dirPathProduct}/${item} && break
                        done < <(echo "$(ls $dirPathProduct)")

                        [[ "${arg}" = "system" ]] && dirPathTarget="${dirPathProduct}/system"
                        [[ "${arg}" = "productObj" ]] && dirPathTarget="${dirPathProduct}/obj"
                        [[ -z "$dirPathTarget" ]]  && dirPathTarget="${dirPathProduct}"
        ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #实现主体
    [[ -z "$dirPathTarget" ]] && dirPathTarget=$(ftIniGetValue $rFilePathXbashDBBase ftCdAospDirectoryInfo ${argVal})
    if [[ ! -d "$dirPathTarget" ]];then
        if [[ -d "alps/${dirPathTarget}" ]];then
            dirPathTarget=alps/${dirPathTarget}
        elif [[ -d "idh/${dirPathTarget}" ]];then
            dirPathTarget=idh/${dirPathTarget}
        else
            ftEcho -e "找不到${dirPathTarget}" && return
    fi ;fi
    if [[ -z "$isUserFileManager" ]];then
        local dirPathLocal=$(pwd)
        cd $dirPathTarget && [[ -z "${ANDROID_BUILD_TOP}" ]] && export ANDROID_BUILD_TOP=$dirPathLocal
        return
    fi
    ftOpenNemoTab -p $(pwd)/${dirPathTarget}
}

_cdAospProject()
{
    local ftEffect=快速进入不同Aosp项目参数补全实现
    local isEnable=def

    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    local mAospProjectNameList="$(ftIniGetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectNameList)"
    COMPREPLY=( $(compgen -W "${mAospProjectNameList}" -- $curr_arg ) )
}
complete -F _cdAospProject -A file ftCdAospProject
ftCdAospProject()
{
    local ftEffect=快速进入不同Aosp项目
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local valCount=1 errorContent arg arg2  arg3  arg4
    local isUserFileManager itemCount mAospProjectName mAospProjectStoragePathEffective
    local mAospProjectStoragePathList="$(ftIniGetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectStoragePathList)"

    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    eval arg3=\${$((i+2))} ; eval arg4=\${$((i+3))}
    case "${arg}" in
    # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    自动更新项目列表
#    ftCdAospProject -u
#
#    切换终端路径
#    ftCdAospProject -n 项目名
#
#    在文件管理器中打开
#    ftCdAospProject -fm 项目名
#
#    可简化 [ftCdAospProject] 为 [xcd] ,其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -fm ) isUserFileManager=true
                mAospProjectName="${arg2}"
         ;;
        -n ) mAospProjectName="${arg2}"
         ;;
        -u | --update ) #更新数据库
                local mAospProjectNameIgnoreList="$(ftIniGetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectNameIgnoreList)"
                local mAospProjectNameListUpdate
                for path in ${mAospProjectStoragePathList[@]}; do
                    while read projectName ;do
                        [[ -n $(echo ${mAospProjectNameIgnoreList[@]} |grep ${projectName}) ]] && continue
                        mAospProjectNameListUpdate=(${mAospProjectNameListUpdate[@]} ${projectName})
                    done < <(echo "$(ls ${path})")
                done
                ftIniSetValue $rFilePathXbashDBUser AospProjectsInfo AospProjectNameList -l "${mAospProjectNameListUpdate[*]}"
                complete -F _cdAospProject -A file ftCdAospProject
                ftEcho -s "Aosp项目列表更新完成"
                return;;
        settings ) dirPathTarget="packages/apps/Settings" ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ -z "$mAospProjectStoragePathList" ] && errorContent="${errorContent}\\n[Aosp项目存放路径列表为空]"
    [ -z "$mAospProjectName" ] && errorContent="${errorContent}\\n[未指定Aosp项目名]"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCdAospProject -h && return

    #实现主体
    local mAospProjectStoragePathEffectiveList pathAll
    for path in ${mAospProjectStoragePathList[@]}; do
        pathAll=${path}/${mAospProjectName}/alps
        [[ -d "$pathAll" ]] && mAospProjectStoragePathEffectiveList=("${mAospProjectStoragePathEffectiveList[@]} $pathAll")
    done
    [ -z "$mAospProjectStoragePathEffectiveList" ] && ftEcho -e "找不到${mAospProjectName}对应的Aosp项目有效存放路径" && return

    mAospProjectStoragePathEffectiveList=($(echo "${mAospProjectStoragePathEffectiveList}"| sed -e "s: ^::g"))
    mAospProjectStoragePathEffective=$mAospProjectStoragePathEffectiveList
    itemCount=${#mAospProjectStoragePathEffectiveList[@]}
    if (( $itemCount>1 ));then
        ftEcho -s 对应多个Aosp项目存放位置,请选择
        local index=0
        for item in ${mAospProjectStoragePathEffectiveList[@]} ; do
            printf "%-4s %-4s\n" [$index] $item
            ((index+=1))
        done

        local num=$itemCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
        ftEcho -r  "请输入对应的序号(回车默认0):"
        read -n $length tIndex &&echo
        #设定默认值
        [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
        (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return
        mAospProjectStoragePathEffective=${mAospProjectStoragePathEffectiveList[$tIndex]}
    fi

    [[ -z "$isUserFileManager" ]] && cd $mAospProjectStoragePathEffective && return
    ftOpenNemoTab -p $mAospProjectStoragePathEffective
}

complete -W "-h --help --rely_install" ftCheckCcache
ftCheckCcache()
{
    local ftEffect=ccache空间溢出校验
    local isEnable=$isUseBuildCcache

    # 说明参数解析部分
    while true; do case "$1" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install ccache
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    补全依赖
#    ftCheckCcache --rely_install
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" != "true" ]] && return #&& ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #依赖校验
    [[ -z $(which ccache) ]] && ftCheckCcache --rely "ccache" && return
    #解参验耦
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCheckCcache -h && return

    #实现主体
    local keyCacheSizeNow="cache size"
    local keyCacheSizeMax="max cache size"
    local UnitMb="Mbytes" UnitGb="Gbytes"
    local cacheSizeNow=$(ccache -s |grep "$keyCacheSizeNow"| awk '{print $3}' | tr -d "a-zA-Z"|sed s/[[:space:]]//g)
    local cacheSizeNowUnit=$(ccache -s |grep "$keyCacheSizeNow"| awk '{print $4}')
    local cacheSizeMax=$(ccache -s |grep "$keyCacheSizeMax" | tr -d "a-zA-Z"|sed s/[[:space:]]//g)
    local cacheSizeMaxUnit=$(ccache -s |grep "$keyCacheSizeMax"| awk '{print $4}')


    if [[ -n $(echo $cacheSizeMaxUnit |grep $UnitMb) ]];then
        ftEcho -e "ccache 空间有限,请及时使用ccache -M xxG处理"
        return
    elif (( $(echo "$cacheSizeMax < 20"|bc) == 1 )) ;then
        ftEcho -e "ccache 空间有限,请及时使用ccache -M xxG处理"
        return
    fi

    [[ -n $(echo $cacheSizeNow |grep $UnitMb) ]] && cacheSizeNow=$(($cacheSizeNow/1024))

    [[ -z "${cacheSizeNow}" ]] \
    || (( $(echo "$cacheSizeNow <= 0"|bc) == 1 )) \
    || (( $(echo "$cacheSizeMax == 1"|bc) == 1 )) && return
    local proportionSize="0$(echo "scale=5; $cacheSizeNow / $cacheSizeMax" | bc)"
    local remainingSize="$(echo "scale=5; $cacheSizeMax - $cacheSizeNow" | bc)"
    local proportionThresholdSize=0.855
    local remainingThresholdSize=10.0 #10GB/基本满足单次新工程的缓存空间要求

    if (( $(echo "$proportionThresholdSize < ${proportionSize}"|bc) == 1 )) \
        &&(( $(echo "$remainingSize < ${remainingThresholdSize}"|bc) == 1 )) ;then
        ftEcho -e "ccache 剩余空间有限,即将溢出,请及时处理"
    fi
}

complete -W "--help --stop --clearn -h -s -sp -c -p" ftMtkLog
ftMtkLog()
{
    local ftEffect=MTK的log相关操作封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local isPull isCheck isSeparation isClearn isStop isPullMini deviceIdLocal
    local filePathLog pathLog dirPathLogStorge fileSizeBaseMillionByte
    local valCount=3 errorContent arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ;case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    指定设备ID
#    ftMtkLog -s 设备ID
#
#    导出log文件
#    ftMtkLog -p  log存放路径
#
#    导出精简版log文件
#    ftMtkLog -pm  log存放路径
#    可简化 [ftMtkLog -p  log存放路径] 为 [xpml] ,其他参数不变
#
#    分析log
#    ftMtkLog -c log文件路径或log目录
#
#    分割log文件
#    ftMtkLog -sp  log文件路径
#    ftMtkLog -sp  log文件路径 分割的大小[MB],默认为2
#    ftMtkLog -sp  /xx/xx.log 3M
#
#    停止mtk的log抓取
#    ftMtkLog --stop
#
#    清理设备log文件
#    ftMtkLog --clearn
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;
        # 变量参数解析部分==============
        --clearn) isClearn=true ; ;;
        --stop) isStop=true ; ;;
        -s ) deviceIdLocal="${arg2}"
             ;;
        -p ) isPull=true
             [ -d "${arg2}" ] && dirPathLogStorge="${arg2}"
             ;;
        -pm ) isPull=true
             isPullMini=true
             [ -d "${arg2}" ] && dirPathLogStorge="${arg2}"
             ;;
        -c ) isCheck=true
              pathLog="${arg2}"
             ;;
        -sp ) isSeparation=true
             [ -f "${arg2}" ] && filePathLog="${arg2}"
             fileSizeBaseMillionByte="${arg3}"
             fileSizeBaseMillionByte=${fileSizeBaseMillionByte:-'2M'}
             ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which adb) ]] && ftEcho -e "依赖Android的SDK中的adb,请确认是否可用" && return
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ "$isPull" = "true" ] && [ -z "${dirPathLogStorge}" ] && errorContent="${errorContent}\\n无法导出log,不知道放哪里"
    [ "$isCheck" = "true" ] && [ ! -d "${pathLog}" ] && [ ! -f "${pathLog}" ] && errorContent="${errorContent}\\n无法分析,没有目标log"
    [ "$isSeparation" = "true" ] && [ -z "${filePathLog}" ] && errorContent="${errorContent}\\n无法分割,没有目标log"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMtkLog -h && return

    #实现主体
    if [ "$isPull" = "true" ] \
        || [ "$isClearn" = "true" ] \
        || [ "$isStop" = "true" ];then
        #adb连接状态检测
        if [[ -z "${deviceIdLocal}" ]];then
            ftAdbContect
            [[ -z "${autoTestDeviceId}" ]] && return
            local deviceId=${autoTestDeviceId}
        fi
    fi

    if [ "$isPull" = "true" ];then
        local dirNameMtkLog=mtklog
        local dirPathLogDevice=/sdcard/mtklog
        local dirPathBuildpropDevice=/system/build.prop
        local editFlag=$(date -d "today" +"%y%m%d%H%M%S")
        local dirPathLogStorgeAll=$(ftPath $dirPathLogStorge)/${dirNameMtkLog}/${editFlag}_${deviceId}

        if [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDevice ]&&echo exit") ]]; then

            ftEcho -y "是否存在测试设备编号,没有请按除y之外的任意键跳过"
            read -n 1 sel
            [ -z "${sel}" ] && sel=n
            while true; do case "$sel" in
                    y | Y )
                        read -n deviceTestId
                        dirPathLogStorgeAll=$(ftPath $dirPathLogStorge)/${dirNameMtkLog}/${editFlag}_${deviceTestId}
                        break ; ;;
                    * ) break ; ;;
            esac;done
            [[ ! -d "${dirPathLogStorgeAll}" ]] && mkdir -p ${dirPathLogStorgeAll}

            # 全部mtklog
            if [[ -z "${isPullMini}" ]]; then

                ftEcho -s "正在导出mtklog 到 ${dirPathLogStorge}"

                adb -s $deviceId shell ls ${dirPathLogDevice} | while read dirNameLog;do
                    dirNameLog=$(echo $dirNameLog |sed s/[[:space:]]//g)
                    dirPathLog=${dirPathLogStorgeAll}/${dirNameLog}
                    [[ ! -d "${dirPathLog}" ]] && mkdir -p ${dirPathLog}
                    adb -s $deviceId pull ${dirPathLogDevice}/${dirNameLog} ${dirPathLog}
                done

                ftEcho -y "是否对设备的mtklog添加已导出标示(回车默认y)"
                read -n 1 sel
                [ -z "${sel}" ] && sel=y
                while true; do case "$sel" in
                        y | Y )
                            local pullFlag=pull_${editFlag}
                            adb -s $deviceId shell mv ${dirPathLogDevice} ${dirPathLogDevice}_${pullFlag}
                            break ; ;;
                        * ) break ; ;;
                esac;done

            # 部分 mtklog
            else
                local dirPathLog
                ftEcho -s "正在导出部分mtklog 到 ${dirPathLogStorge}"
                adb -s $deviceId pull ${dirPathLogDevice}/aee_exp ${dirPathLogStorgeAll}/aee_exp
                adb -s $deviceId shell ls ${dirPathLogDevice}/mobilelog | while read dirNameLog;do
                    dirPathLog=${dirPathLogStorgeAll}/mobilelog/$(echo $dirNameLog |sed s/[[:space:]]//g)
                    [[ ! -d "${dirPathLog}" ]] && mkdir -p $dirPathLog
                    adb -s $deviceId pull ${dirPathLogDevice}/mobilelog/${dirNameLog}/crash_log ${dirPathLog}
                done
                adb -s $deviceId pull ${dirPathBuildpropDevice} ${dirPathLogStorgeAll}
            fi
        else
            ftEcho -e "设备不存在${dirNameMtkLog},请确认设备的${dirNameMtkLog}是否存在[${dirPathLogDevice}]"
        fi

        local dirNameOtherLog=other_log
        dirPathLogStorge=${dirPathLogStorgeAll}/${dirNameOtherLog}
        [[ ! -d ${dirPathLogStorge} ]] && mkdir -p ${dirPathLogStorge}

        local dirPathLogDeviceAEE=/data/aee_exp
        [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDeviceAEE ]&&echo exit") ]] && \
        ftEcho -s "正在导出 aee_exp log 到 ${dirPathLogStorge}" && \
        adb -s $deviceId pull ${dirPathLogDeviceAEE} ${dirPathLogStorge}

        local dirPathLogDeviceANR=/data/anr
        [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDeviceANR ]&&echo exit") ]] && \
        ftEcho -s "正在导出 anr log 到 ${dirPathLogStorge}" && \
        adb -s $deviceId pull ${dirPathLogDeviceANR} ${dirPathLogStorge}

    fi

    # 停止mtklog
    [ "$isStop" = "true" ] && ftEcho -s "正在停止抓取mtklog" && ftKillApplicationByPackageName "com.mediatek.mtklogger" > /dev/null

    # 清理mtklog
    [ "$isClearn" = "true" ] && [[ -n $(adb -s $deviceId shell ls ${dirPathDevicesTarget}/mtklog) ]] && \
    ftEcho -s "正在清理mtklog" && adb -s $deviceId shell rm -rf /sdcard/mtklog

    #分割log
    if [ "$isSeparation" = "true" ];then
        [[ ! -f "${filePathLog}" ]] && ftEcho -e "找不到分割的文件: ${filePathLog}" && return

        local fileName=$(basename $filePathLog)
        local dirPathLog=$(dirname $filePathLog)
        local fileNameBase=${fileName%.*}
        local fileNameEnd=${fileName##*.}
        local fileSizeBaseByte=2097152
        local filePathLogSize=$(stat -c "%s" $filePathLog) #B
        local dirPathLocal=$(pwd)

        cd $dirPathLog
        [[ "${fileNameBase}" = "${fileNameEnd}" ]] || [[ -z "${fileNameEnd}" ]] && fileNameEnd="log"
        (( $filePathLogSize <= $fileSizeBaseByte )) && ftEcho -s "${fileName} 文件无需分割" && return
        [[ -n "${fileNameEnd}" ]] && split --verbose -b $fileSizeBaseMillionByte "$filePathLog" -d -a 4 --additional-suffix=.${fileNameEnd} $fileNameBase
        ftEcho -s "${fileName} 分割完成"
        cd $dirPathLocal
    fi

    #分析log
    if [ "$isCheck" = "true" ];then
        local pathLogTemp=/tmp/log.tmp \
                 index=0 checkIndex=10 \
                 replaceVal="" \
                 fileNameCheck="ck"
        local lengthReplace
        local filePathListCheck=($(find $pathLog -name "*.${fileNameCheck}" -type f))

        if [[ -n "${filePathListCheck[@]}" ]];then
            ftEcho -y "存在旧的分析文件,是否开始重新分析(回车默认y)"
            read -n 1 sel && echo
            [ -z "${sel}" ] && sel=y
            [[ "$sel" != "y" ]] && return
            for index in "${!filePathListCheck[@]}"; do
               rm -v ${filePathListCheck[$index]}
            done && echo
        fi

        ftEcho -s "开始分析: ${pathLog},请稍等"
        local dirNameCheckLog="LogSummary"
        local dirPathCheckLog=${pathLog}/${dirNameCheckLog}
        [[ ! -d $dirPathCheckLog ]] && mkdir -p $dirPathCheckLog
        local key="AndroidRuntime" \
                Key2="AEE/DEBUG"
        grep -Ersl "${key}|${Key2}" $pathLog | while read filePath;do
            [[ ${filePath##*.} = ${fileNameCheck} ]] && break
            # [[ $(basename $filePath) = "crash_log" ]] && continue
            echo filePath=${filePath}

            echo "" > $pathLogTemp
            grep -rs "${key}" $filePath | grep -v "PID:" | while read line;do
                (( $checkIndex <= $index ))||[[ -z "${lengthReplace}" ]] && lengthReplace=$(expr index "${line}" ${key}) && (( lengthReplace-=5 )) && index=0
                 echo ${line:$lengthReplace} >> $pathLogTemp
                ((index+=1))
            done

            # lengthReplace=0
            grep -rs "${Key2}" $filePath | grep -v "PID:" | while read line;do
                # (( $checkIndex <= $index ))||[[ -z "${lengthReplace}" ]] && lengthReplace=$(expr index "${line}" ${Key2}) && (( lengthReplace-=5 )) && index=0
                 echo ${line} >> $pathLogTemp
                # ((index+=1))
            done

            local filePathCheck=${filePath}.${fileNameCheck}
            local fileNameCheckAll=$(basename ${filePathCheck})
            cat $pathLogTemp \
            | sort -rn \
            | uniq -c \
            | sort -u \
            > ${filePathCheck} && \
            mv $filePathCheck ${dirPathCheckLog}/${fileNameCheckAll} && \
            ftEcho -s "生成分析文件:${fileNameCheckAll} 到${dirPathCheckLog}"
        done
    fi
}

complete -W "-h --help -w --wifi -u" ftAdbContect
ftAdbContect()
{
    local ftEffect=adb多设备连接处理
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local isUseWifi isUpdateDeviceId
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftAdbContect 无参
#
#    使用wifi调试
#    ftAdbContect -w / --wifi
#
#    更新adb的设备ID
#    ftAdbContect -u
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#
# 依赖Android的SDK中的adb,请确认是否可用
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -w | --wifi ) isUseWifi=true
          ;;
        -u ) isUpdateDeviceId=true
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAdbContect -h && return
    [[ -z $(which adb) ]] && ftAdbContect --env && return
    [[ ! -d ${ANDROID_SDK} ]] && ftAdbContect --env && return
    #环境性校验
    [[ -n "$ANDROID_BUILD_TOP" ]] && ftEcho -s "当前终端已初始化Android编译环境,此功能不可用" \
    && export autoTestDeviceId= && return

    #实现主体
    local deviceIdDefault=0123456789ABCDEF
    local deviceId=${deviceIdDefault}
    local deviceIdTarget=$(date -d "today" +"%y%m%d%H%M%S")
    local deviceIdList=($(adb devices |grep -v "List of devices attached" |awk '{print $1}'))
    local deviceIdListUniq=($(echo "${deviceIdList[@]}"  | sed 's/ /\n/g' |sort |uniq))
    local deviceCount=${#deviceIdList[@]}
    local deviceCountUniq=${#deviceIdListUniq[@]}
    local deviceIdold=$autoTestDeviceId

    (( $deviceCount != 0 )) && (( $deviceCountUniq != 0 ))  && (( $deviceCount != $deviceCountUniq )) && \
        ftEcho -s "存在多个同ID设备,请手动移除设备"&& adb devices && return
    export autoTestDeviceCounts=$deviceCount

    if (( $deviceCount <=1 ));then
        ftEcho -sn "等待设备连接>"
        adb wait-for-device
        deviceId=$(adb get-serialno)
    elif [[ -n "${deviceIdold}" ]]&&[[ -n $(echo ${deviceIdList[@]} |grep $autoTestDeviceId ) ]]; then
        ftEcho -sn "等待设备连接>"
        deviceId=$deviceIdold
    else
        if [[ -n "${deviceIdold}" ]]; then
            ftEcho -y "存在旧的设备ID,是否更新(回车默认y)"
            read -n 1 sel && [ -z "${sel}" ] && sel=y
            while true; do case "$sel" in
                    y | Y ) export autoTestDeviceId=; break; ;;
                    n | q ) return ; ;;
                    * ) ftEcho -e "错误的选择：$sel"
                        echo "输入n，q，离开";;
            esac;done ;
        fi
        if [[ -n ${isUseWifi} ]]; then
            ftEcho -y "需要断开其他wifi调试连接是否继续" ; read -n 1 sel ; [ -z "${sel}" ] && sel=y
            [[ "${sel}" != "y" ]] && return
            adb disconnect
        fi

        if [[ -n "$isUpdateDeviceId" ]] || [[ -z $(echo ${deviceIdList[@]} |grep $deviceIdDefault ) ]] ;then
            ftEcho -s "存在多个设备,请选择"
            local index=0
            for deviceId in ${deviceIdList[@]} ; do
                printf "%-4s %-4s\n" [$index] $deviceId
                ((index+=1))
            done

            local num=$deviceCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
            ftEcho -r  "请输入对应的序号(回车默认0):"
            read -n $length tIndex &&echo
            #设定默认值
            [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
            (( $deviceCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return
            deviceId=${deviceIdList[$tIndex]}
            ftEcho -sn "等待设备连接>"

        elif [[ -n $(echo ${deviceIdList[@]} |grep $deviceIdDefault ) ]]\
                &&[[ "${deviceId}" != "${deviceIdTarget}" ]];then # 对默认deviceID进行修改
            ftEcho -sn "等待设备连接>" && adb -s $deviceId wait-for-device
            if adb -s $deviceId shell "echo $deviceIdTarget > /sys/class/android_usb/android0/iSerial"; then
                ftEcho -sn "请重新插拔usb设备>"
                deviceId=$deviceIdTarget
            else
                ftEcho -en "更新deviceId失败,缺少必要权限,将使用默认ID" ; ftEcho -sn ">"
            fi

        fi
    fi

    adb -s $deviceId wait-for-device
    local adbStatus=$(adb -s $deviceId get-state)
    [ "$adbStatus" != "device" ] && ftEcho -e "adb连接状态[$adbStatus]异常,请重新尝试" && return
    ftEcho -s "连接设备成功"

    export autoTestDeviceId=$deviceId
    [[ -n "${deviceIdold}" ]]&&[[ "${deviceId}" != "${autoTestDeviceId}" ]] && echo -en "设备ID更新:" && ftEcho -s "${autoTestDeviceId} > ${deviceId}"

    if [[ -n ${isUseWifi} ]]; then
        local ipAddressList portNum \
                 ipAddressInfoList=($(adb shell ifconfig wlan0 |grep inet)) \
                 key="addr:"

        for ip in ${ipAddressInfoList[@]}; do
            [[ "${ip}" != ${key}* ]] && continue
            ip=${ip//$key/}
            [[ -z "${ip}" ]] && continue
            ipAddressList=(${ipAddressList[@]} ${ip})
        done
        ipConunt=${#ipAddressList[@]}
        [[ -z ${ipConunt[@]} ]]||(( $ipConunt==0 )) && ftEcho -e "无法获取设备wifi相关IP地址,请确认设备是否连接wifi" && return

        ftEcho -sn "请设定wifi调试端口号(5555-5585)(回车默认5555):"
        read -n 4 portNum ;[ -z "${portNum}" ] && portNum=5555
        adb -s ${deviceId} tcpip ${portNum}
        for ipAddress in ${ipAddressList[*]}; do
            adb -s $deviceId connect ${ipAddress}:${portNum}
        done
    fi
}

complete -W "-h --help --rely_install -c" ftPigz
ftPigz()
{
    local ftEffect=pigz压缩的相关封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local contentTarget filrPathTarget dirPathTarget dirPathLocal=$(pwd)
    local valCount=2 errorContent arg arg2 ;for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftPigz -c 文件路径/目录
#    可简化 [ftPigz -c] 为 [xtgz] ,其他参数不变
#========================================================="; return ;;
    # 变量参数解析部分==============
    -c ) contentTarget="${arg2}"
      ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which pigz) ]] && ftPigz --rely "pigz" && return
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [[ ! -d "${contentTarget}" ]]&&[[ ! -f "${contentTarget}" ]] && errorContent="${errorContent}\\n[文件或目录不存在]:${contentTarget}"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPigz -h && return

    #实现主体
    filrPathTarget=${contentTarget}.tgz
    dirPathTarget=$(dirname $contentTarget)
    cd $dirPathTarget
    tar --use-compress-program=pigz -cvPf $filrPathTarget ${contentTarget}
    cd $dirPathLocal
}

complete -W "-h --help --rely -o -f" ftDex2Jar
ftDex2Jar()
{
    local ftEffect=dex转jar
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #参数解析
    local filePathDex filePathJar
    local dirPathToolResign=${DIR_PATH_ANDROID_DECOMPILE}/dex2jar-2.0
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    指定dex路径
#    ftDex2Jar -f dex路径
#    指定生成路径
#    ftDex2Jar -o 生成目录/文件名.jar
#========================================================="; return ;;
        # 变量参数解析部分==============
        -o ) filePathJar="${arg2}" ; ;;
        -f ) filePathDex="${arg2}" ; ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #预处理
    local errorContent
    [[ ! -f "$filePathDex" ]] && errorContent="${errorContent}\\n找不到dex文件:${filePathDex}"
    [[ ! -d "$dirPathToolResign" ]] && errorContent="${errorContent}\\n找不到dex2jar工具:${dirPathToolResign}"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDex2Jar -h && return

    #实现主体
    if [[ -z "${filePathJar}" ]];then
        local fileNameDex=$(basename $filePathDex)
        filePathJar=$(dirname $filePathDex)/${fileNameDex%.*}.jar
    fi

    for libPath in ${dirPathToolResign}/lib/*.jar ;do _classpath="${_classpath}:${libPath}" ;done

    java -Xms512m -Xmx1024m -classpath "${_classpath}" \
                                                      com.googlecode.dex2jar.tools.Dex2jarCmd ${filePathDex} \
                                                      -o ${filePathJar} \
    && ftEcho -s "生成${filePathJar}"
}

ftMD5()
{
    local ftEffect=记录和校验文件的MD5

    #参数解析
    local editType filePathVersion filePathInfo
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   获取文件的MD5
#    ftMD5 -a 文件路径
#
#   获取文件的MD5,校验文件是否一致
#    ftMD5 -p MD5信息保存路径 -c 文件路径
#
#   保存文件的MD5信息
#    ftMD5 -p MD5信息保存路径 -s 文件路径
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a )   filePathVersion="${arg2}"
                editType=onlyCreate
           ;;
        -c )   filePathVersion="${arg2}"
                editType=checkMd5
           ;;
        -s )   filePathVersion="${arg2}"
                editType=setMd5
           ;;
        -p )   filePathInfo="${arg2}"
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$editType" ] && errorContent="${errorContent}\\n[不知道要干啥]editType=$editType"
    [ "${editType}" != "onlyCreate" ] && [ ! -f "$filePathInfo" ] && errorContent="${errorContent}\\n[没有相关版本信息文件]filePathInfo=$filePathInfo"
    [ ! -f "$filePathVersion" ] && errorContent="${errorContent}\\n[目标文件不存在]filePathVersion=$filePathVersion"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMD5 -h && return

    #实现主体
    local fileNameVersion=$(basename $filePathVersion)
    local versionName=${fileNameVersion%.*}

    while true; do case "${editType}" in
        onlyCreate )
                    export ftMD5Info=
                    ftEcho -s "生成文件:[$(basename ${filePathVersion})]的MD5"
                    export ftMD5Info=$(md5sum $filePathVersion | awk '{print $1}')
                    return;;
        setMd5 )
                    ftEcho -s "文件 : ${fileNameVersion} MD5信息正在生成，请稍等"
                    local md5Code=$(md5sum $filePathVersion | awk '{print $1}')
                    ftIniSetValue $filePathInfo $versionName MD5 $md5Code
                    ftEcho -s "文件 : ${fileNameVersion} MD5信息已生成"
                    return;;
        checkMd5 )
                    ftEcho -bh "文件 : ${versionName} MD5检验开始"
                    local Md5Code=$(ftIniGetValue $filePathInfo $versionName MD5)
                    [[ -z "$Md5Code" ]] && ftEcho -e "文件 : ${versionName}  原始MD5未找到" && exit
                    local Md5CodeNow=$(md5sum $filePathVersion | awk '{print $1}')
                    [ "$Md5CodeNow"x != "$Md5Code"x ] && ftEcho -e "文件 : ${versionName} MD5检验失败" && exit

                    ftEcho -s "文件 : ${versionName} MD5检验成功"
                    return;;
    * ) break;;esac;done
}