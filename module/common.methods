#!/bin/bash
##################################################
##                                              ##
##             框架通用实现                      ##
##                                              ##
##################################################
_ftMainVal()
{
    local ftEffect=bash内建命令和xbash扩展封装对应的参数补全实现
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    case "${COMP_WORDS[1]}" in
        -)
                COMP_WORDS[1]="-h"
                export COMP_WORDS=${COMP_WORDS[@]}; ;;
        *)  COMPREPLY=( $(compgen -W '-h -hb -hc --help -t test  -v --version -ft' -- $curr_arg ) ); ;;
      esac
}
ftMain()
{
    local ftEffect=早期工具主入口
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

    while true; do case $1 in
    -v | --version )
                local dirPathLocal=$(pwd) flag="-v beta"
                cd $rDirPathXbash
                local branchNameNow=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
                [[ "$branchNameNow" = "master" ]] && flag="-i beta"
                local tagList=($(git tag |grep ${flag} ))
                local length=${#tagList[@]}
                ((length-=1))
                echo -n \"Xrnsd extensions to bash\" && ftEcho -s " ${tagList[$length]}"
                cd "${dirPathLocal}"
                break;;
    -t | test )
                ftTest "$@"
                break;;
    -h | --help )
                ftEcho -s "xbash -h    #查看所有说明\nxbash -hb   #bash命令封装和xbash扩展封装的说明\nxbash -ft   #xbash的扩展实现说明" && 
                echo && ftMain -ft && echo && ftMain -hb
                break;;
    -ha )
                ftEcho -s "xbash -h    #查看所有说明\nxbash -hb   #bash命令封装和xbash扩展封装的说明\nxbash -ft   #xbash的扩展实现说明" && 
                echo && ftReadAllAlias && echo && ftReadAllFt -a
                break;;
    -hb )
                ftReadAllAlias
                break;;
    -ft )
                ftReadAllFt
                break;;
    -sc )
                sensors |grep °C | awk '{print $3}'|grep °C|awk '{sum+=$1} END {printf("CPU %s °C \n",sum/NR)}'
                break;;
    -scc )
                sensors |grep °C | awk '{print $3}'|grep °C
                break;;
    *) ftMain -h && return;; esac;done
}

ftClearTail()
{
    local ftEffect=清尾
    local isEnable=def

    local dirPathLocal=$1
    [[ -n $dirPathLocal ]] && cd $dirPathLocal
    trap SIGINT
}

complete -W "-a --adb -h --help -j -s" ftResetXbash
ftResetXbash()
{
    local ftEffect=更新xbash配置
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    export isResetJdk= isResetGcc= isResetCcache= isResetXbash=true targetSdkVersionForce=
    local dirPathCode dirPathLocal=$(pwd)  filePathHomeBash=~/.bashrc
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}}  ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    可简化 [ftResetXbash] 为 [xr] ,其他参数不变
#    以下[参数对]无先后顺序可任意组合
#
#    更新xbash默认配置
#    ftResetXbash
#
#    重启adb服务
#    ftResetXbash -a/--adb
#
#    更新 jdk配置 / gcc配置 / jdk和gcc配置 / jdk和gcc和ccache配置
#    ftResetXbash -j / -c / -jc / -jcc
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a |--adb) ftAdbConnect -r && return
          ;;
        -j ) export isResetJdk=true
            targetSdkVersionForce="${arg2}"
            [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return $resultFail
          ;;
        -c ) export isResetGcc=true
            targetSdkVersionForce="${arg2}"
            [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return $resultFail
          ;;
        -cj | -jc |-jcc)
            [[ -n "${arg2}" ]] && export targetSdkVersionForce="${arg2}"
            [[ -z "$isUseCustomAndroidDevEnvConfig" ]] && ftEcho -e "xbash定义的Android开发环境基础配置,未启用" && return $resultFail
            [ -d "${dirPathLocal}/alps" ] && dirPathCode=${dirPathLocal}/alps
            [ -d "${dirPathLocal}/idh" ] && dirPathCode=${dirPathLocal}/idh
            [ -n "${dirPathCode}" ] && cd $dirPathCode

            [[ -n "$isUseBuildCcache" ]] && [ "${arg}" = "-jcc" ] && export isResetCcache=true
            export isResetGcc=true
            export isResetJdk=true
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -f "$filePathXbashTragetBashrcConfigProfile" ] && errorContent="${errorContent}\\n[配置文件不存在]filePathXbashTragetBashrcConfigProfile=$filePathXbashTragetBashrcConfigProfile"
    [ ! -f "$filePathHomeBash" ] && errorContent="${errorContent}\\n[bash入口文件不存在]filePathHomeBash=$filePathHomeBash"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftResetXbash -h && return $resultFail

    #实现主体
    #source $filePathXbashTragetBashrcConfigProfile
    source $filePathHomeBash
    export isResetXbash=
    cd ${dirPathLocal}
}

ftReadAllAlias()
{
        local ftEffect=bash命令封装和xbash扩展封装的说明
        local isEnable=def

        #可用性校验
        [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
        #解参验耦
        [[ ! -f $rFilePathXbashPackagingUser ]] && ftEcho -e "xbash配置不存在:$rFilePathXbashPackagingUser" && return $resultFail

        local cmdName cmdContent intervalSize=24

        ftEcho -s "$ftEffect"
        echo -e "========================================================="
        printf "%s  %${intervalSize}s \n" 命令 说明
        echo -e "========================================================"
        cat $rFilePathXbashPackagingUser $rFilePathXbashModuleUser|grep alias | sort | while read line; do
                cmdName=$(echo $line | awk '{split($2,b,"=");print  b[1] }')
                cmdContent=$(echo $line | awk '{split($2,b,"=");print  b[3]}'| awk '{split($0,b,";");print  b[1]}')
                [[ -n "$cmdContent" ]] && printf "%${intervalSize}s  %s\n" ${cmdName} ${cmdContent}
        done | column -t
}

ftReadAllFt()
{
        local ftEffect=xbash的扩展实现说明
        local isEnable=def

        #isEnable设为 def 时将不在说明中显示
        #可用性校验
        [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

        local isEchoDefFt isEchoSubF effectDescription effectDescriptionEnable
        local key="local ftEffect=" keyEnable="local isEnable=" intervalSize=40

        if [[ "$1" = "-a" ]]; then
            #isEchoDefFt=true
            isEchoSubF=true
        fi

        ftEcho -s "$ftEffect"
        echo -e "========================================================="
        printf "%s%${intervalSize}s" 命令 说明 && ftEcho -s " [ 查看对应命令的具体说明: 命令 -h ]"
        echo -e "========================================================"
        for effectName in $(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto  $rFilePathXbashModuleGit $rFilePathXbashModuleUser| grep '^ft'  |grep "()"| sort) ; do
            effectDescription=$(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto $rFilePathXbashModuleGit|grep  -C 3 $effectName|grep "$key")
            effectDescription=${effectDescription//$key/}
            effectDescription=${effectDescription// /}

            effectDescriptionEnable=$(cat $rFilePathXbashModuleCommon $rFilePathXbashModuleAuto $rFilePathXbashModuleGit|grep  -C 3 $effectName|grep "$keyEnable")
            effectDescriptionEnable=${effectDescriptionEnable//$keyEnable/}
            effectDescriptionEnable=${effectDescriptionEnable// /}

            [[ -z "${effectDescription}" ]] && continue #用户添加非标准方法
            [[ -z "${isEchoDefFt}" ]] && [[ "$effectDescriptionEnable" = "def" ]] && continue #内部流程方法
            [[ -z "${isEchoSubF}" ]] && [[ "$effectDescriptionEnable" = "sub" ]] && continue #内部工具方法,不适合独立被外部调用

            printf "%${intervalSize}s  " ${effectName//()/}
            [[ "$effectDescriptionEnable" = "false" ]] && ftEcho -s "[暂时关闭]" && continue
            echo ${effectDescription}
        done | column -t
}

ftTest()
{
    local ftEffect=调试
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftTest 任意参数
#    ftTest -j 或 -java
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    if [[ ! -f "$rFilePathXbashModuleTest" ]] && [[ -f $rFilePathXbashModuleTestExpmale ]]; then
       cp $rFilePathXbashModuleTestExpmale $rFilePathXbashModuleTest
       echo $userPassword | sudo -p '' -S chmod a+x $rFilePathXbashModuleTest
       [[ -z $(cat ${rDirPathXbash}/.gitignore |grep $rFileNameXbashModuleTestBase) ]] && \
       echo $(echo $rFilePathXbashModuleTest | sed -e "s:${rDirPathXbash}/::g") >> ${rDirPathXbash}/.gitignore
    fi
    local valCount=1 errorContent
    [ ! -d "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[用户路径为空]rDirPathUserHome=$rDirPathUserHome"
    [ ! -f "$rFilePathXbashModuleTest" ] && errorContent="${errorContent}\\n[测试模块不存在]filePathXbashModuleTest=$rFilePathXbashModuleTest"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftTest -h && return $resultFail

    #实现主体
    local dirPathLocal=$PWD dirPathTemp=${rDirPathUserHome}/.temp
    if [[ $2 == "-java" ]]; then
        local toolFilePath="$(ftXbGetValue JavaTestTool toolsFilePath)"
        [ ! -f "$toolFilePath" ] && ftEcho -e "java文件不存在:${toolFilePath}" && return
        # XMODIFIERS=@im=fcitx GTK_IM_MODULE=xim gedit -s $toolFilePath
        local dirName=$(dirname $toolFilePath) 
        local fileName=$(basename $toolFilePath)
        local fileNameBasic=${fileName%.*}
        javac "${toolFilePath}"
        cd "${dirName}"
        java "${fileNameBasic}"
        cd "${dirPathLocal}"
        return
    fi
    [[ ! -d "${dirPathTemp}" ]] && mkdir $dirPathTemp
    [[ ! -f ${dirPathLocal}/Makefile ]] && [[ -z "$ANDROID_BUILD_TOP" ]] && cd $dirPathTemp && trap '[ -d $dirPathLocal ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT

    ftTimeConsuming -i
    shift&&$rFilePathXbashModuleTest "$@"
    ftTimeConsuming -r $ftEffect
    cd $dirPathLocal
    trap SIGINT
}

complete -W " --rely_install -h --help" ftGitUpdateVersion
ftGitUpdateVersion()
{
    local ftEffect=xbash自动更新
    local isEnable=false

    #可用性校验
    [[ -n "$isAutoUpdate" ]] && isEnable=$isAutoUpdate
    [[ "$isEnable" != "true" ]] && return
    #依赖校验
    [[ -z $(which git) ]] && return $resultFail
    #解参验耦
    local dirPathLocal=$(pwd) checkUpdateDateNow=$(date -d "today" +"%Y%m%d")
    local tagName=xbashUpdateVersionConfig keyName=checkUpdateDate checkUpdateDateOld=$(ftXbGetValue $tagName $keyName)
    [[ -z "${checkUpdateDateOld}" ]] && ftIniCreateFileOrTag  -a -p $rFilePathXbashDBUser -t $tagName -l "${keyName}=${checkUpdateDateNow}" || \
    [[ "${checkUpdateDateOld}" = "${checkUpdateDateNow}" ]] && return $resultFail
    [[ -n "${rDirPathXbash}" ]] && cd $rDirPathXbash

    local branchNameMaster="master" branchNameLocal=$(git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/\1/')
    #实现主体
    [ -z "$branchNameLocal" ] || [ "$branchNameLocal" = "$branchNameMaster" ] && cd "${dirPathLocal}" && return $resultFail
    echo "$(git pull > /dev/null &)" > /dev/null
    cd "${dirPathLocal}"
    ftIniSetValue $rFilePathXbashDBUser $tagName $keyName $checkUpdateDateNow
}

ftEcho()
{
    local ftEffect=工具信息提示
    local isEnable=def

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local title content option=$1 valList=$@
    option=${option:-'未制定显示信息'}
        if [ ${#valList[@]} -eq 2 ];then
        content=$(echo $content |sed s/[[:space:]]//g)
    else
        #除第一个参数外的所有参数列表，可正常打印数组
        content="${valList[@]/$option/}"
        content=${content/ /}
    fi

    local arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftEcho          内容       # 直接显示内容
#    ftEcho    -b    内容       # 标题，不换行，对字符串的缩进敏感
#    ftEcho    -bh   内容       # 标题，换行，对字符串的缩进敏感
#    ftEcho    -e    内容       # 错误信息显示，对字符串的缩进敏感
#    ftEcho    -en   内容       # 错误信息显示，对字符串的缩进敏感
#    ftEcho    -ex   内容       # 错误信息显示，显示完退出，对字符串的缩进敏感
#    ftEcho    -ea   内容       # 错误信息多行显示，对字符串的缩进不敏感，包含内置数组会显示不正常
#    ftEcho    -eax  内容       # 错误信息多行显示，对字符串的缩进不敏感，包含内置数组会显示不正常，显示完退出
#    ftEcho    -y    内容       # 特定信息显示，y/n，对字符串的缩进敏感
#    ftEcho    -s    内容       # 执行信息，对字符串的缩进敏感
#    ftEcho    -sn   内容       # 执行信息，不换行，对字符串的缩进敏感
#    ftEcho    -snw  内容       # 执行信息，不换行，对字符串的缩进敏感,循环显示省略号
#    ftEcho    -rc   内容       # xbash函数的说明显示，对字符串的缩进敏感
#    ftEcho    -w    标题  内容  # 弹窗提示
#    ftEcho    -iow  标题  内容  # 弹窗交互
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -w|-iow )
            if [[ -z $arg3 ]]; then
                title="提示"
                content="${arg2}"
            else
                title="${arg2}"
                content="${arg3}"
            fi
            ;;
    * ) break;;esac;done

    while true; do case $option in
        -e )     echo -e "\033[1;31m$content\033[0m"; break;;
        -en )    echo -en "\033[1;31m$content\033[0m"; break;;
        -ex )    echo -e "\033[1;31m$content\033[0m" ; [ "$XMODULE" = "env" ] && return ; exit;;
        -s )     echo -e "\033[1;33m$content\033[0m"; break;;
        -sn )    echo -en "\033[1;33m$content\033[0m"; break;;
        -snw )
                [[ -z $mWaitForPromptSymbol ]] || [[ "$mWaitForPromptSymbol" = "...." ]] && mWaitForPromptSymbol="."
                echo -en "\033[1;33m$content ${mWaitForPromptSymbol}\033[0m"
                mWaitForPromptSymbol="${mWaitForPromptSymbol}."; break;;
        -sh )    echo;echo -e "\033[1;33m$content\033[0m";echo; break;;
        -w )    notify-send ["${title}"] "${content}" ; break;;
        -iow )  zenity --entry --title "${title}" --text "${content}" ; break;;
        -b )     echo -e "\e[41;33;1m =========== $content ============= \e[0m"; break;;
        -bh )    echo;echo -e "\e[41;33;1m =========== $content ============= \e[0m";echo; break;;
        -y )     echo;echo -en "${content}[y/n]"; break;;
        -yn )    echo -en "${content}[y/n]"; break;;
        -ye )    echo -en "${content}[y/n]"; break;;
        -r )     echo;echo -en "${content}"; break;;
        -ea )    for val in ${content[@]} ; do echo -e "\033[1;31m$val\033[0m"; done; break;;
        -eax )   for val in ${content[@]} ; do echo -e "\033[1;31m$val\033[0m"; done; exit;;
        -rc )    echo -en "\033[1;33m${2}\033[0m";echo "${3}";echo -e "${4}" ; break;;
    * )    echo $option ;break;; esac ;done
}

ftTimeConsuming()
{
    local ftEffect=脚本操作耗时记录
    local isEnable=def

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local contentName=本次骚操作 arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        -r ) contentName="${arg2:-"$contentName"}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ -z "$mTimingStart" ]||[ "$1" = "-i" ] && mTimingStart=$(date +%s -d $(date +"%H:%M:%S")) && return 0

    local content timeNow=$(date +%s -d $(date +"%H:%M:%S"))
    local time3=$(((timeNow-mTimingStart)%60))
    local time5=$(((timeNow-mTimingStart)/3600))
    local time4=$((((timeNow-mTimingStart)-time5*3600)/60))
    mTimingStart=

    (($time3==0)) && (($time4==0)) && (($time5==0)) && return $resultFail
    (($time5!=0)) && content="${content}${time5} 时"
    (($time4!=0)) && content="${content}${time4} 分"
    (($time3!=0)) && content="${content}${time3} 秒"
    ftEcho -s "${contentName}耗时 ${content}!"
}

ftPath()
{
    local ftEffect=路径处理
    local isEnable=def

    #可用性校验
    [[ "$isEnable" = "false" ]] && returnn
    #参数解析
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftPath 路径       #去掉最后的斜杠
#    ftPath 路径 文件[夹]  #正确拼接路径
#========================================================="; return ;;
    * ) break;;esac;done
    #解参验耦
    local valCount=2 dirPath=$1 fileOrDirName=$2
    (( $#>$valCount )) && return $resultFail
    #实现主体
    [[ "${dirPath: -1}" = "/" ]] && dirPath=${dirPath%/*}
    [[ -z "$fileOrDirecoryName" ]] && echo $dirPath || echo ${dirPath}/${fileOrDirecoryName}
}

ftVersionComparison()
{
    local ftEffect=版本号大小对比
    local isEnable=def

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftVersionComparison -h    #查看帮助
#
#    只能比对xx.xx格式的版本号
#    echo \$(ftVersionComparison 版本1 版本2)   #比对版本1和2大小
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftVersionComparison -h && return $resultFail

    #实现主体
    [[ "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" != "$1" ]] && echo ">" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" != "$1" ]] && echo "<" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -V | head -n 1)" == "$1" ]] && echo "<=" && return
    [[ "$(echo "$@" | tr " " "\n" | sort -rV | head -n 1)" == "$1" ]] && echo ">=" && return
}

ftCheckUserConfig()
{
    local ftEffect=校验用户配置和模版版本一致性
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #实现主体
    [[ ! -f ${rFilePathXbashConfigExample}  ]] && return $resultFail
    [[ ! -f ${rFilePathXbashConfigUser}  ]] && return $resultFail

    local title="用户配置" key="versionNum="
    local versionNumExcepmale=$(cat $rFilePathXbashConfigExample |grep $key)
    local versionNumUser=$(cat $rFilePathXbashConfigUser |grep $key)

    versionNumExcepmale=${versionNumExcepmale//$key/}
    versionNumUser=${versionNumUser//$key/}

    [[ -z "${versionNumUser}" ]] && ftEcho -e "建议更新${title}到:${versionNumExcepmale}" && return
    [[ -z "${versionNumExcepmale}" ]] || [[ $(ftVersionComparison $versionNumUser $versionNumExcepmale) != "<"  ]] && return

    ftEcho -e "${title}已升级，建议更新: ${versionNumUser} > ${versionNumExcepmale}"
    echo -n "请更新" ; ftEcho -s "：$rFilePathXbashConfigUser"
    echo -n "请参考" ; ftEcho -s "：$rFilePathXbashConfigExample"
}

ftCheckUserDatabase()
{
    local ftEffect=校验用户数据库和模版版本一致性
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #实现主体
    [[ ! -f ${rFilePathXbashDBUserExcepmale}  ]] && return $resultFail
    [[ ! -f ${rFilePathXbashDBUser}  ]] && return $resultFail

    local title="用户数据库" tag=informationInThisDb key="versionNum"
    local versionNumExcepmale=$(ftIniGetValue $rFilePathXbashDBUserExcepmale $tag $key)
    local versionNumUser=$(ftIniGetValue $rFilePathXbashDBUser $tag $key)

    if [[ -z "${versionNumUser}" ]];then
        ftEcho -e "建议更新${title}配置到:${versionNumExcepmale}"
        echo -n "请参考"; ftEcho -s "：$rFilePathXbashDBUserExcepmale"
    elif [[ -n "${versionNumExcepmale}" ]];then
        local val=$(ftVersionComparison $versionNumUser $versionNumExcepmale)
        if [[ ${val} = "<"  ]];then
            ftEcho -e "建议更新${title}配置: ${versionNumUser} > ${versionNumExcepmale}"
            echo -n "请参考" && ftEcho -s "：$rFilePathXbashDBUserExcepmale"
            echo -n "请更新" ; ftEcho -s "：$rFilePathXbashDBUser"
            return
        elif [[ ${val} = ">"  ]]; then
            ftEcho -e "${title}版本出现变化，建议查看: "
            echo -n "文件" ; ftEcho -s "：$rFilePathXbashDBUser"
            echo -n "模版" && ftEcho -s "：$rFilePathXbashDBUserExcepmale"
        fi
    fi
}

ftCheckUserPackaging()
{
    local ftEffect=校验用户配置和模版版本一致性
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #实现主体
    [[ ! -f ${rFilePathXbashPackagingUserExample}  ]] && return $resultFail
    [[ ! -f ${rFilePathXbashPackagingUser}  ]] && return $resultFail

    local title="用户扩展" key="versionNum="
    local versionNumExcepmale=$(cat $rFilePathXbashPackagingUserExample |grep $key)
    local versionNumUser=$(cat $rFilePathXbashPackagingUser |grep $key)

    versionNumExcepmale=${versionNumExcepmale//$key/}
    versionNumUser=${versionNumUser//$key/}

    [[ -z "${versionNumUser}" ]] && ftEcho -e "建议更新${title}到:${versionNumExcepmale}" && return
    [[ -z "${versionNumExcepmale}" ]] || [[ $(ftVersionComparison $versionNumUser $versionNumExcepmale) != "<"  ]] && return

    ftEcho -e "${title}已升级，建议更新: ${versionNumUser} > ${versionNumExcepmale}"
    echo -n "请更新" ; ftEcho -s "：$rFilePathXbashPackagingUser"
    echo -n "请参考" ; ftEcho -s "：$rFilePathXbashPackagingUserExample"
}

ftIniCreateFileOrTag()
{
    local ftEffect=创建ini文件,添加TAG
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local filePathIni editType contentTagName contentTagKeyValList
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    添加内容
#    ftIniCreateFileOrTag  -a -p 文件路径 -t 块名 -l 块对应的键值对列表
#    ftIniCreateFileOrTag  -a -p aa/bb/cc.dd -t EEE -l \"xxx=yyy aaa=bbb\"
#    ftIniCreateFileOrTag  -a -p aa/bb/cc.dd -t EEE -l \"#item xxx xxx=yyy #item aaa aaa=bbb\"
#
#    覆盖文件
#    ftIniCreateFileOrTag  -r -p 文件路径 -t 块名 -l 块对应的键值对列表
#    ftIniCreateFileOrTag  -r -p aa/bb/cc.dd -t EEE -l \"xxx=yyy aaa=bbb\"
#    ftIniCreateFileOrTag  -r -p aa/bb/cc.dd -t EEE -l \"#item xxx xxx=yyy #item aaa aaa=bbb\"
#========================================================="; return ;;
        # 变量参数解析部分==============
        -a )   editType=add                                   ;;
        -r )   editType=replace                               ;;
        -p )   filePathIni="$arg2"                            ;;
        -t )   contentTagName="$arg2"                 ;;
        -l )   contentTagKeyValList="${arg2[@]}" ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$filePathIni" ] && errorContent="${errorContent}\\n[不知道要去那，请使用-p制定文件路径]"
    [ -z "$contentTagName" ] && errorContent="${errorContent}\\n[块名为空]contentTagName=$contentTagName"
    [ -z "$contentTagKeyValList" ] && errorContent="${errorContent}\\n[块对应的列表为空]contentTagKeyValList=$contentTagKeyValList"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniCreateFileOrTag -h && return $resultFail

    #实现主体
    local content enterLine="\n"
    #added TAG
    content=${enterLine}"[$contentTagName]"
    #add List
    for item in ${contentTagKeyValList[*]} ; do
        # [[ ${item} != *=* ]] 处理item带空格时正常拼接
        # [[ ${item:0:1} != "#" ]] 处理注释时正常添加换行
        [[ ${item} != *=* ]] && [[ ${item:0:1} != "#" ]] && content=${content}" $item" && continue
        content=${content}${enterLine}"$item"
    done
    content=${content}${enterLine}

    if [[ ! -f "$filePathIni" ]]||[ "$editType" = "replace" ]; then
        localContent="#ini"
        localContent=${localContent}${enterLine}"#文件由ftIniCreateFileOrTag自动创建，请避免手动编辑造成解析失败"
        localContent=${localContent}${enterLine}
        echo -e ${localContent} > $filePathIni
    fi

    if [ -n "$(cat $filePathIni |grep  $contentTagName)" ];then
        ftEcho -y "存在旧TAG，是否删除(回车默认y)"
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )echo
                    while [ -n "$(cat $filePathIni |grep  $contentTagName)" ]; do
                        ftIniDeleteTag -p $filePathIni -t $contentTagName
                    done; break;;
                n | q )  echo ; exit ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
    esac;done ; fi
    echo  -e "${content}" >> $filePathIni
}

ftIniDeleteTag()
{
    local ftEffect=删除ini文件中对应TAG块
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local tagName filePathIni
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniDeleteTag -p ini文件路径 -t TAG块名
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t )   tagName="${arg2}"        ;;
        -p )   filePathIni="${arg2}"     ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteTag -h && return $resultFail

    #实现主体
    local index=1 indexEnd indexStart lineCount=$(cat $filePathIni|wc -l)
    while read -r line ; do
        if [[ "$line" = "[${tagName}]" ]]||[[ -n "$indexStart" ]]; then
            [[ -z "$indexStart" ]] && indexStart=$index
            (($index==$lineCount)) && ((index+=1)) && line=

            if [[ -z "$line" ]]; then
                indexEnd=$index
                local lineRange="${indexStart},${indexEnd}d"
                sed -i $lineRange $filePathIni
                break
            fi
        fi
        ((index+=1))
    done < $filePathIni
}

ftIniAddItem()
{
    local ftEffect=在ini文件对应TAG中添加指定item
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local filePathIni tagName itemName itemContent
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniAddItem -p ini文件路径 -t TAG块名  -i item名 -l 块对应的键值对列表
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p )   filePathIni="${arg2}"    ;;
        -t )   tagName="${arg2}"        ;;
        -i )   itemName="${arg2}"       ;;
        -l )   itemContent="${arg2}"    ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$itemContent" ] && errorContent="${errorContent}\\n[缺少必要参数]itemContent=$itemContent"
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ -z "$itemName" ] && errorContent="${errorContent}\\n[缺少必要参数]itemName=$itemName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniAddItem -h && return $resultFail

    #实现主体
    local indexStart=$(sed -n "/\[${tagName}\]/=" $filePathIni)
    
    ((indexStart+=1))
    itemName="${itemName}="
    sed  -i "${indexStart}i ${itemName}${itemContent[@]}" $filePathIni

}

ftIniDeleteItem()
{
    local ftEffect=在ini文件对应TAG中删除指定item
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local tagName itemName filePathIni
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniDeleteItem -p ini文件路径 -t TAG块名 -i item名
#========================================================="; return ;;
        # 变量参数解析部分==============
        -t )   tagName="${arg2}"            ;;
        -i )   itemName="${arg2}"           ;;
        -p )   filePathIni="${arg2}"        ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$itemName" ] && errorContent="${errorContent}\\n[缺少必要参数]itemName=$itemName"
    [ -z "$tagName" ] && errorContent="${errorContent}\\n[缺少必要参数]tagName=$tagName"
    [ ! -f "$filePathIni" ] && errorContent="${errorContent}\\n[文件不存在]filePathIni=$filePathIni"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteItem -h && return $resultFail

    #实现主体
    local indexStart indexEnd index=0
    cat $filePathIni | while read line ;do
        if [[ "$line" = "[${tagName}]" ]]||[[ -n "$indexStart" ]]; then
            [[ -z "$indexStart" ]] && indexStart=$index && ((indexStart+=1))
            if [[ "$line" =~ ^${itemName}* ]]; then
                ((index+=1))
                sed -i "${index}d" $filePathIni
                break
            fi
            [[ -z "$line" ]] && indexEnd=$index && break
        fi
        ((index+=1))
    done
}

ftIniGetValue()
{
    local ftEffect=在ini文件对应TAG中读取指定item
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local filePath=$1 blockName=$2 keyName=$3 isReadSilence
    local valCount=3 errorContent ; for ((i=1;i<=$#;i++)) ; do case "$1" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    #默认不输出异常信息
#    ftIniGetValue 文件路径 目标块TAG 键名
#    value=\$(ftIniGetValue 文件路径 目标块TAG 键名)
#    value表示key对应的值
#
#    #输出异常信息
#    ftIniGetValue -f [文件路径] [目标块TAG] [键名]
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -f ) filePath=$2
            blockName=$3
            keyName=$4
            isReadSilence=true
            ;;
    * ) break;;esac;done

    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    if [ ! -f "$filePath" ];then    errorContent="${errorContent}\\n[文件不存在]filePath=$filePath"
    else
        [ -z "${blockName}" ] && errorContent="${errorContent}\\n[目标块TAG为空]blockName=$blockName"
        [ -z "$(cat $filePath|grep $blockName)" ] && errorContent="${errorContent}\\n[目标块TAG不存在]blockName=$blockName"
        [ -z "$keyName" ] && errorContent="${errorContent}\\n[目标块TAG为空]keyName=$keyName"
        [ -z "$(cat $filePath|grep $keyName)" ] && errorContent="${errorContent}\\n[目标块TAG不存在]keyName=$keyName"
    fi
    [ -n "${isReadSilence}" ]&&[ -n "$errorContent" ] && ftEcho -ea "$errorContent \\n请查看下面说明:" && ftIniGetValue -h && return $resultFail

    #实现主体
    local begin_block=0 end_block=0
    cat $filePath | while read line ; do
        [ "X$line" = "X[$blockName]" ] && begin_block=1 && continue
        (( $begin_block!=1 )) && continue

        (( $(echo $line | awk 'BEGIN{ret=0} /^\[.*\]$/{ret=1} END{print ret}')==1 )) && break
        (( $(echo $line | awk 'BEGIN{ret=0} /^#/{ret=1} /^$/{ret=1} END{print ret}')==1 )) && continue

        key=$(echo $line | awk -F= '{gsub(" |\t","",$1); print $1}')
        [ "X$keyName" = "X$key" ] && echo $(echo $line | awk -F= '{gsub("\t","",$2); print $2}') && break
    done
}

ftIniSetValue()
{
    local ftEffect=在ini文件对应TAG中修改指定item
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isListValue filePath=$1 blockName=$2 keyName=$3 keyValue=$4
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftIniSetValue [文件路径] [目标块TAG] [键名] [键对应的值]
#    ftIniSetValue /temp/odbcinst.ini PostgreSQL Setup 1232
#    ftIniSetValue /temp/odbcinst.ini PostgreSQL Setup -l \"${xxx[*]}\"  #写入数组
#========================================================="; return ;;
        # 变量参数解析部分==============
        -l )    keyValue="${arg2}"
                isListValue=true
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    if [ ! -f "$filePath" ];then    errorContent="${errorContent}\\n[目标ini文件不存在]filePath=$filePath"
    else
        if [ -z "$blockName" ];then    errorContent="${errorContent}\\n[目标块TAG为空]blockName=$blockName"
        elif [ -z "$(cat $filePath|grep $blockName)" ];then    errorContent="${errorContent}\\n[目标块TAG不存在]blockName=$blockName" ; fi
        if [ -z "$keyName" ];then    errorContent="${errorContent}\\n[目标Key为空]keyName=$keyName"
        elif [ -z "$(cat $filePath|grep $keyName)" ];then    errorContent="${errorContent}\\n[目标Key不存在]keyName=$keyName" ; fi
        [ -z "$keyValue" ] && errorContent="${errorContent}\\n[目标Key对应的Value为空]keyValue=$keyValue"
    fi
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniSetValue -h && return $resultFail

    #实现主体
    [[ "$isListValue" = "true" ]] && return`sed -i "/^\[$blockName\]/,/^\[/ {/^\[$blockName\]/b;/^\[/b;s:^$keyName*=.*:$keyName=$keyValue:g;}" $filePath`
    keyValue=$(echo $keyValue |sed s/[[:space:]]//g)
    return`sed -i "/^\[$blockName\]/,/^\[/ {/^\[$blockName\]/b;/^\[/b;s ^$keyName*=.* $keyName=$keyValue g;}" $filePath`
}

#########################
##                                                 ##
##             非框架通用实现          ##
##                                                  ##
#########################
ftBashHistory()
{
    local ftEffect=处理bash历史记录
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    # 环境校验
    if [[ -z "$isUseXbashHistory" ]] && [[ "$1" != "-p" ]]; then
        return $resultFail
    fi
    #参数解析
    local bashHistorySize filePathBashHistory=${dirPathHome}/.bash_history
    local filePathBashHistoryArchive=${filePathBashHistory}_archive
    local filePathBashHistoryArchiveTemp=${filePathBashHistoryArchive}_temp
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   #显示bash命令历史存储路径
#    ftBashHistory -p
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p )
            [ -f $filePathBashHistory ] && cat ${filePathBashHistory}
            [ -f $filePathBashHistoryArchive ] && cat ${filePathBashHistoryArchive}
            return
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    [ ! -d $dirPathHome ]  && errorContent="${errorContent}\\n[迷路中，请稍等]dirPathHome=$，dirPathHome"
    [ ! -f $filePathBashHistory ] && errorContent="${errorContent}\\n[历史记录为空]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftIniDeleteItem -h && return $resultFail

    #实现主体
    #备份历史记录
    [ -f $filePathBashHistory ] && cat $filePathBashHistory >> $filePathBashHistoryArchive
    sort -k2n $filePathBashHistoryArchive | awk '{if ($0!=line) print;line=$0}' >${filePathBashHistoryArchiveTemp}
    mv $filePathBashHistoryArchiveTemp $filePathBashHistoryArchive
    echo "$(echo "$userPassword" | sudo -S -p '' echo " " > /dev/null)" >/dev/null
    sudo chmod 777 $filePathBashHistoryArchive
    local fileSizeBashHistoryArchive=$(stat -c "%s" ${filePathBashHistoryArchive})
    (( $fileSizeBashHistoryArchive > 15728640 )) && ftEcho -s "xbash的命令历史过大建议整理 , 文件路径:${filePathBashHistoryArchive}"

    if [[ -f $rFilePathXbashDBUser ]]; then
        bashHistorySize=$(ftXbGetValue  xbash bashHistoryThresholdSize)
    else
        # user database 初始化
        [[ ! -d "${rDirPathXbashModuleUser}" ]] && mkdir $rDirPathXbashModuleUser > /dev/null
        [[ -f "$rFilePathXbashDBUserExcepmale" ]] && cp ${rFilePathXbashDBUserExcepmale} ${rFilePathXbashDBUser} \
        || echo -e "\033[1;31m用户独立配置初始化失败,模版不存在:\n${rFilePathXbashDBUserExcepmale}\033[0m"
    fi

    export HISTSIZE=$bashHistorySize
    export HISTFILESIZE=$bashHistorySize
    shopt -s histappend #多个终端情况下，共享history
}

ftDevAvailableSpace()
{
    local ftEffect=设备可用空间
    local isEnable=true

    local dirPathTraget=$1 isReturn=$2 isFormatGbyte
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftAutoLnCcacheByAosp --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install ccache
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftDevAvailableSpace [dirPathTraget] [[isReturn]]
#    ftDevAvailableSpace /media/test
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -g ) isFormatGbyte=true
                dirPathTraget=$2
                isReturn=$3
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTraget" ] && errorContent="${errorContent}\\n[设备路径不存在]dirPathTraget=$dirPathTraget"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDevAvailableSpace -h && return $resultFail

    #实现主体
     local devAvailableSIzeList=$(df -lh | awk '{print $4}')
     local devMountDirPathList=($(df -lh | awk '{print $6}'))
     local indexDevName=0 devMountDirPath
     for size in ${devAvailableSIzeList[*]} ; do
        devMountDirPath=${devMountDirPathList[indexDevName]}
        if [[ "$devMountDirPath" = "$dirPathTraget" ]]; then
            if [[ $size == *T ]];then
                size=${size//T/}
                size=${size%.*}
                ((size*=1024))
                ((size*=1024))
            elif [[ $size == *G ]];then
                size=${size//G/}
                size=${size%.*}
                [[ -z "$isFormatGbyte" ]] && ((size*=1024))
            else
                size=${size//M/}
            fi
            echo $size|awk ' {print int ($0)} '
            break
        fi
        ((indexDevName+=1))
    done
}

ftLanguageUtil()
{
    local ftEffect=语言缩写转换
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftLanguageUtil "ar_IL bn_BD my_MM zh_CN"
#    ftLanguageUtil "阿拉伯语 孟加拉语 缅甸语 简体中文"
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local ftLanguageContent="${1}" filePathDataBase=$rFilePathXbashDBBase
    local errorContent
    [ -z "$ftLanguageContent" ] && errorContent="${errorContent}\\n[语言信息为空]ftLanguageContent=$ftLanguageContent" ;
    [ ! -f "$filePathDataBase" ] && errorContent="${errorContent}\\n[语言转化配置文件不存在]filePathDataBase=$filePathDataBase"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftLanguageUtil -h && return $resultFail

    #实现主体
    local returnVal
    local allList=($(ftXbGetValue languageList allList))
    local shortList=($(ftXbGetValue languageList shortList))
    local ftLanguageContent2=${ftLanguageContent//_/}
    ftLanguageContent2=${ftLanguageContent2// /}
    local sourceList=(${shortList[@]})
    local tragetList=(${allList[@]})
    if [[ ! "$ftLanguageContent2" =~  ^[a-zA-Z]+$ ]]; then
        sourceList=(${allList[@]})
        tragetList=(${shortList[@]})
    fi

    local orderIndex=0
    for lc in ${ftLanguageContent[@]} ; do
        title="参数[${lc}] 转换失败"
        index=0
        for base in ${sourceList[@]} ; do
            if [ $lc = $base ];then
                returnVal="${returnVal} ${tragetList[index]}"
                ((orderIndex+=1))
                break;
            elif [[ $base =~ "/" ]] && [[ $base =~ $lc ]]; then
                returnVal="${returnVal} [${lc}]>${tragetList[index]}>[${base}]"
                title=${lc}可能存在多种结果
            elif((${#sourceList[@]}==$(($index + 1)) ));then
                echo -n "base=${base}"
                ftEcho -e $title
            fi
            ((index+=1))
        done
    done
    echo ${returnVal[@]}
}

ftInitDevicesList()
{
    local ftEffect=初始化存储设备的列表
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local devMinAvailableSpace=0  # 设备最小可用空间，小于则视为无效.单位M
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftInitDevicesList [可用空间/单位默认为MB]
#    ftInitDevicesList 4096M
#========================================================="; return ;;
        # 变量参数解析部分==============
        -s )   devMinAvailableSpace="${arg2:-'0'}"
                devMinAvailableSpace=${devMinAvailableSpace,,}
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    local devMinAvailableSpaceTemp=$devMinAvailableSpace
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//g/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//m/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//k/}
    devMinAvailableSpaceTemp=${devMinAvailableSpaceTemp//b/}
    [ -z "$rDirPathXbash" ] && errorContent="${errorContent}\\n[默认用户名]rUserName=$rUserName"
    [ -z "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[默认用户的home目录]rDirPathUserHome=$rDirPathUserHome"
    ( ! echo -n $devMinAvailableSpaceTemp | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[可用空间限制]devMinAvailableSpace=$devMinAvailableSpace"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftInitDevicesList -h && return $resultFail

    #实现主体
    local indexDevMount=0 indexDevName=0
    local dirPathHome=$rDirPathUserHome #(${rDirPathUserHome/$rUserName\//$rUserName})
    local sizeHome=$(ftDevAvailableSpace $dirPathHome)
    local devNameDirPathList=$(df -lh | awk '{print $1}')
    local devMountDirPathList=($(df -lh | awk '{print $6}'))

    devMinAvailableSpace=${devMinAvailableSpace//b/}
    if [[ $devMinAvailableSpace =~ "g" ]];then
        devMinAvailableSpace=${devMinAvailableSpace//g/}
        (( devMinAvailableSpace*=1024 ))
    elif [[ $devMinAvailableSpace =~ "m" ]];then
        devMinAvailableSpace=${devMinAvailableSpace//m/}
    elif [[ $devMinAvailableSpace =~ "k" ]];then
        devMinAvailableSpace=${devMinAvailableSpace//k/}
        ((devMinAvailableSpace/=1024))
    fi

    unset mXbashModuleDataDevicesList
    [ -n "$sizeHome" ] && (( $sizeHome>=$devMinAvailableSpace )) && mXbashModuleDataDevicesList=$dirPathHome && indexDevMount=1
    #开始记录设备文件
    for dir in ${devNameDirPathList[*]} ;do
        devMountDirPath=${devMountDirPathList[indexDevName]}
        if [[ $dir =~ "/dev/" ]] && [[ $devMountDirPath != "/" ]];then
            sizeTemp=$(ftDevAvailableSpace $devMountDirPath)
            [[ -z "sizeTemp" ]] && continue
            # 确定目录已挂载,设备可用空间大小符合限制
            if (( $devMinAvailableSpace==0 ))||(( $sizeTemp>$devMinAvailableSpace )); then
                if mountpoint -q $devMountDirPath;then
                    mXbashModuleDataDevicesList[$indexDevMount]=$devMountDirPath
                    ((indexDevMount+=1))
                fi
            fi
        fi
        ((indexDevName+=1))
    done
    export mXbashModuleDataDevicesList #=${mXbashModuleDataDevicesList[*]}
}

_adb()
{
    local ftEffect=adb修正工具对应的参数补全实现
    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    case "${COMP_WORDS[1]}" in
                    -k)       COMPREPLY=( $(compgen -W 'home back menu down up lift right down  power' -- $curr_arg ) )
                                  ;;
                    install)  COMPREPLY=( $(compgen -W "-l -r -s" -- $curr_arg ) )
                                # case "${COMP_WORDS[2]}" in
                                #                 -l|-r|-s)  if [[ -n "$(ls -l |grep ".apk")" ]]; then
                                #                                     COMPREPLY=( $(compgen -o filenames -W "`ls *.apk`" -- ${cur}) );
                                #                                 fi ;;
                                # esac
                                ;;
                    shell)   COMPREPLY=( $(compgen -W 'am pm input screencap screenrecord getprop dumpsys start text setprop start stop' -- $curr_arg ) );
                                case "${COMP_WORDS[2]}" in
                                                dumpsys)  COMPREPLY=( $(compgen -W 'notification cpuinfo meminfo activity' -- $curr_arg ) ); ;;
                                                input)  COMPREPLY=( $(compgen -W 'keyevent text' -- $curr_arg ) ); ;;
                                esac
                                ;;
                    logcat)  COMPREPLY=( $(compgen -W ' \"*:E\"  ' -- $curr_arg ) )
                                ;;
                    *)  COMPREPLY=( $(compgen -W 'push pull sync shell emu logcat forward jdwp install uninstall bugreport backup restore help version wait-for-device start-server kill-server get-state get-serialno get-devpath status-window remount root usb reboot disable-verity disconnect tcpip' -- $curr_arg ) ); ;;
      esac
}
complete -F _adb -A file adb
adb()
{
    local ftEffect=adb修正工具

    local dirPathCode=$ANDROID_BUILD_TOP
    local filePathAdbNow=$(which adb)
    local filePathAdbLocal=/usr/bin/adb
    local filePathDataBase=$rFilePathXbashDBBase

    #环境校验
    # if [ -z "$filePathAdbNow" ]||[ ! -d "$ANDROID_SDK" ];then
    [ ! -d "$ANDROID_SDK" ] && echo -e "#===============[ ${ftEffect} ]的使用环境说明=============\n#    Android SDK 环境异常，请查看配置\n#=========================================================" && return

    if [[ -f "$filePathAdbNow" ]]; then
        local dirPathLocal=$(pwd)
        local  filePathAdb=${dirPathCode}/out/host/linux-x86/bin/adb
        if [[ "$dirPathLocal" = "$dirPathCode" ]] && [[ -f "$filePathAdb" ]]; then
            if [[ "$filePathAdbNow" != "$filePathAdb" ]]; then
                local pid=$(lsof -i:5037  |grep adb |awk '{print $2}')
                [[ -f "$filePathAdbLocal" ]] && echo $userPassword | sudo -p '' -S mv $filePathAdbLocal ${filePathAdbLocal}2
                ftAdbConnect -r
            fi
        fi
    else
        if [[ ! -f "${filePathAdbLocal}" ]]; then
            if [[ -f "${filePathAdbLocal}2" ]]; then
                echo $userPassword | sudo -p '' -S mv ${filePathAdbLocal}2 $filePathAdbLocal
            else
                local filePath=${ANDROID_SDK}/platform-tools/adb
                [[ ! -f "$filePath" ]] && ftEcho -e "Android SDK 配置 失败，文件不存在：$filePath" && return $resultFail
                echo $userPassword | sudo  -p ''  -S ln -s  ${ANDROID_SDK}/platform-tools/adb $filePathAdbLocal
            fi
            ftAdbConnect -r
        fi
        filePathAdbNow=$filePathAdbLocal
    fi

    if [[ "$1" = "-k" ]]; then
        [ ! -f "$filePathDataBase" ] && ftEcho -e "数据库文件不存在]filePathDataBase=$filePathDataBase" && return $resultFail

        local TagName=androidKeyCode
        local keyCode=$(ftXbGetValue androidKeyCode $2)

        [[ -z "$keyCode" ]] && ftEcho -e "未知配置,请查看:$filePathDataBase" && return $resultFail
        $filePathAdbNow shell input keyevent $keyCode
        return
    fi

     $filePathAdbNow "$@"
}

ftCleanGarbage()
{
    local ftEffect=清空回收站
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    ftInitDevicesList
    local isAutoExit sleepTime isNoEcho
    local errorContent arg arg2 ;for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
     --exception) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    禁止在高权限下运行,转化普通用户后，再次尝试
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    自动退出
#    ftCleanGarbage -e
#    可简化 [ftCleanGarbage -e] 为 [xcg]
#
#    延时清理
#    ftCleanGarbage -t 时间
#========================================================="; return ;;
        # 变量参数解析部分==============
        -e ) isAutoExit=true
          ;;
        -n ) isNoEcho=true
          ;;
        -t ) sleepTime="${arg2}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #环境校验
    [[ "$(whoami)" != "$rUserName" ]]||[[ "$(whoami)" = "root" ]] && ftCleanGarbage --exception && return $resultFail
    [ -z "$mXbashModuleDataDevicesList" ] && errorContent="${errorContent}\\n[被清空回收站的设备的目录列表]mXbashModuleDataDevicesList=${mXbashModuleDataDevicesList[@]}"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCleanGarbage -h  && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd)
    local baseList=($(ftXbGetValue CleanGarbageInfo list))

    if [[ -n $sleepTime ]]; then
        tput sc
        for i in $(seq -w $sleepTime -1 1) ; do
            tput rc;tput ed
            echo -ne "\033[1;31m将在${i}秒后开始清理，ctrl+c 取消\033[0m"
            sleep 1
        done
    fi
    for dirDevPath in ${baseList[*]} ${mXbashModuleDataDevicesList[*]}  ${rDirPathUserHome}; do
        if [ -d ${dirDevPath}/.Trash-1000 ];then
            dirDevPath=${dirDevPath}/.Trash-1000
        elif [ -d ${dirDevPath}/.local/share/Trash ];then
            dirDevPath=${dirDevPath}/.local/share/Trash
        else
            continue
        fi

        cd $dirDevPath && trap '[ -d files ] && cd $dirPathLocal && exit' SIGINT

        [ ! -d empty ] && mkdir empty
        if [[ -n $isNoEcho ]]; then
            rsync --delete-before -d -a -H --progress --stats empty/ files/
        else
            rsync --delete-before -d -a -H -v --progress --stats empty/ files/
        fi
        rm -rf files/*
        trap SIGINT
    done
    cd $dirPathLocal
    trap SIGINT
    [[ -n "$isAutoExit" ]] && exit
}

ftKillApplicationByPackageName()
{
    local ftEffect=kill掉包名为packageName的应用
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftKillApplicationByPackageName
#
#    ftKillApplicationByPackageName [packageName]
#    ftKillApplicationByPackageName com.android.settings
#
#    可简化 [ftKillApplicationByPackageName] 为 [xk] ,其他参数不变
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local packageName=$1
    local valCount=1 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$packageName" ] && errorContent="${errorContent}\\n[应用包名]packageName=$packageName"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftKillApplicationByPackageName -h && return $resultFail

    #实现主体
    #adb连接状态检测
    ftAdbConnect -e ; [[ -z "${autoTestDeviceId}" ]] && return $resultFail
    local deviceId=${autoTestDeviceId}

    while true; do case "$packageName" in
        systemui)   packageName="com.android.systemui"  ;break;;
        launcher3|launcher) packageName="com.android.launcher3"  ;break;;
        monkey)     packageName="com.android.commands.monkey"  ;break;;
    * ) break;;esac;done
    
    # local pidArray=($(adb shell ps | grep "$packageName" | awk '{print $2}'))
    # local packageArray=($(adb shell ps | grep "$packageName" | awk '{print $9}'))

    # if [[ -n "$pidArray" ]]; then
    #     for index in "${!packageArray[@]}"; do
    #        if [[  ${packageArray[$index]} = "$packageName" ]]; then
    #             adb -s $deviceId shell am force-stop $packageName || ftEcho -e "am force-stop $packageName fail"
    #             adb -s $deviceId shell kill $pid&& ftEcho -s "kill pid ${pid}"
    #        fi
    #     done
    # elif [[ -z "$(adb -s $deviceId shell pm list packages|grep $packageName)" ]]; then
    #      ftEcho -e "包名[${packageName}]不存在，请确认"
    # fi
    
    if [[ -n "$(adb shell ps | grep $packageName | awk '{print $2}')" ]]; then
        adb -s $deviceId shell am force-stop $packageName || ftEcho -e "am force-stop $packageName fail"
        for pid in $(adb -s $deviceId shell ps | grep $packageName | awk '{print $2}'); do adb -s $deviceId shell kill $pid&& ftEcho -s "kill pid ${pid}"  ;done
    elif [[ -z "$(adb -s $deviceId shell pm list packages|grep $packageName)" ]]; then
         ftEcho -e "包名[${packageName}]不存在，请确认"
    fi
}

ftLogcatApplicationByTag()
{
    local ftEffect=打印指定包名输出或包含TAG的log
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local flagError packageName isUserPackageName isDisTime isMoreTag isUserPackageNameAndTag isKeep isWait
    local tagContent=$1 vContent=$2
    local arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#     打印所有log
#    ftLogcatApplicationByTag
#
#    保持连接，异常断开后自动连接
#    ftLogcatApplicationByTag -k
#
#     打印包名为 com.android.settings的应用输出的log
#    ftLogcatApplicationByTag -p com.android.settings
#    可简化 [ftLogcatApplicationByTag -p ] 为 [xlp],其他参数不变
#
#     打印包名为 com.android.settings的应用输出的log
#    ftLogcatApplicationByTag -p com.android.settings
#    可简化 [ftLogcatApplicationByTag -pw ] 为 [xlpw],其他参数不变
#
#     打印包含123456的log
#    ftLogcatApplicationByTag 123456
#    可简化 [ftLogcatApplicationByTag] 为 [xl],其他参数不变
#
#     打印包含123456 不包含777  的log
#    ftLogcatApplicationByTag 123456 7777
#    可简化 [ftLogcatApplicationByTag] 为 [xl],其他参数不变
#
#     打印包含123456 不包含777  的log
#    ftLogcatApplicationByTag -t 123456 7777
#    可简化 [ftLogcatApplicationByTag] 为 [xlt],其他参数不变
#
#     打印包含123456不包含777的错误log
#    ftLogcatApplicationByTag -e 123456 7777
#    可简化 [ftLogcatApplicationByTag -e] 为 [xle] ,其他参数不变
#
#     打印同时包含123456或777的log
#    ftLogcatApplicationByTag -o \"123456 7777\"
#    可简化 [ftLogcatApplicationByTag -o] 为 [xlo],其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -p ) packageName="${arg2}"
               vContent="${arg3}"
               isUserPackageName=true
          ;;
        -pw ) packageName="${arg2}"
               vContent="${arg3}"
               isUserPackageName=true
               isWait=true
          ;;
        -tp ) packageName="${arg2}"
               vContent="${arg3}"
               isUserPackageName=true
               isUserPackageNameAndTag=true
          ;;
        -e ) flagError="*:E"
            if [[ -z "$packageName" ]]; then
                tagContent="${arg2}"
                vContent="${arg3}"
            fi
          ;;
        -t )   isDisTime=true
                tagContent="${arg2}"
                vContent="${arg3}"
          ;;
        -o )   isMoreTag=true
                tagContent="${arg2}"
                tagContent=${tagContent// /|}
                vContent=
          ;;
        -k ) isKeep=true
                tagContent="${arg2}"
                vContent="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #实现主体
    ftAdbConnect
    [[ -z "${autoTestDeviceId}" ]] && return $resultFail
    local deviceId=${autoTestDeviceId}

    [ -z "${flagError}" ] && [ -z "${isUserPackageName}" ] && adb -s $deviceId logcat -c
    while true; do
        if [[ "$isUserPackageName" = "true" ]]; then

            local pid=$(adb -s $deviceId shell ps | grep $packageName | awk '{print $2}')
            if [[ -z "$pid" ]]; then
                if [[ -z "$isWait" ]]; then
                    ftEcho -e "未找到应用 : ${packageName}" && return
                fi
                ftEcho -s "等待应用 : ${packageName}启动中..."
                local timeOut=60
                local time=0;
                while true; do
                    pid=$(adb -s $deviceId shell ps | grep $packageName | awk '{print $2}')
                    ((time+=1))

                    if [[ -z "$pid" ]]; then
                        (( $time>$timeOut )) && ftEcho -e "等待启动超时,自动退出" && return
                        sleep 1 && continue
                    else
                        break
                    fi
                done
            fi
            [[ -n "$isUserPackageNameAndTag" ]] && adb -s $deviceId logcat "${flagError}" -v thread --pid=${pid} && return
            adb -s $deviceId logcat "${flagError}" --pid=${pid}

        elif [ -z "$tagContent" ];then
            adb -s $deviceId logcat "${flagError}"
        else
            [[ -n "$isMoreTag" ]] && adb -s $deviceId logcat "${flagError}"|grep -E "${tagContent}" && return
            [[ -n "$isDisTime" ]] && adb -s $deviceId logcat -v tag|grep -i -a "${tagContent}" && return
            [[ -z "$vContent" ]] && adb -s $deviceId logcat "${flagError}" |grep -i -a "${tagContent}" && return
            adb -s $deviceId logcat "${flagError}" |grep -i "${tagContent}" |grep -v "${vContent}"
        fi

        [[ ! -n "$isKeep" ]] && break
    done
}

ftMtkFlashTool()
{
    local ftEffect=mtk下载工具
    local isEnable=true

        #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local isEnableWindowMode flashToolPath="$(ftXbGetValue MtkSpFlashToolVersion toolsPath)"
    local isOldMode flashToolPathOld="$(ftXbGetValue MtkSpFlashToolVersion toolsPathOld)"

    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    #使用终端模式
#    ftMtkFlashTool 无参
#    可简化 [ftMtkFlashTool ] 为 [xd]
#
#    #使用窗口模式
#    ftMtkFlashTool -w
#    可简化 [ftMtkFlashTool -w] 为 [xdw]
#
#    #使用兼容模式，兼容旧设备
#    ftMtkFlashTool --old
#    可简化 [ftMtkFlashTool -w] 为 [xdw]
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -w ) isEnableWindowMode=true
            ;;
        --old ) isOldMode=true
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -f "$flashToolPath" ] && errorContent="${errorContent}\\n[mtk下载工具不存在]flashToolPath=$flashToolPath"
    [ -n "$isOldMode" ] && [ ! -f "$flashToolPathOld" ] && errorContent="${errorContent}\\n[mtk下载工具不存在]flashToolPathOld=$flashToolPathOld"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的出现错误:${errorContent}\\n" && return $resultFail

    #实现主体
    echo "$(echo "$userPassword" | sudo -S -p '' echo " " > /dev/null)" >/dev/null
    local projectOldList=($(ftXbGetValue xbashAOSPConfigMTKSoftwareDownloadToool projectOld))
    if [[ -n "$projectOldList" ]] && [[ -n "$AutoEnv_projrctName" ]] && [[ ${projectOldList[@]} == *${AutoEnv_projrctName}* ]]; then
        flashToolPath=$flashToolPathOld
    fi
    [ -n "$isOldMode" ] && [ -f "$flashToolPathOld" ]&& flashToolPath=$flashToolPathOld
    if [[ -z $isEnableWindowMode ]] && [[ -n $ANDROID_BUILD_TOP ]]; then
        local dirPathLocal=$(pwd)
        cd $ANDROID_BUILD_TOP
        local filePathAndroidScatter="${ANDROID_PRODUCT_OUT}/"$(ls $ANDROID_PRODUCT_OUT |grep "Android_scatter.txt")
        [[ ! -f $filePathAndroidScatter ]] && ftEcho -e "下载配置文件不存在" && cd "${dirPathLocal}" && return $resultFail
         $flashToolPath -s "${filePathAndroidScatter}" -c download
        cd "${dirPathLocal}"
        return;
    fi
    local isRmoveDirLog
    [ ! -d "Log" ] && isRmoveDirLog=true
    sudo $flashToolPath
    [ -d "Log" ] && [ -n "${isRmoveDirLog}" ] && sudo rm -rf Log
}

complete -W "create new -h --help" ftBootAnimation
ftBootAnimation()
{
    local ftEffect=生成开关机动画
    local isEnable=true

    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    请进入动画资源目录后执行xc bootanim xxx
#    ftBootAnimation [edittype] [path]
#
#    直接生成动画包，不做其他操作，不确认资源文件是否有效
#    ftBootAnimation create /home/xxxx/test/bootanimation2
#
#    初始化生成bootanimation2.zip所需要的东东，然后生成动画包
#    ftBootAnimation new /home/xxxx/test/bootanimation2
#========================================================="; return ;;
    * ) break;; esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local editType=$1 dirPathAnimation=$2 dirPathBase=$(pwd)
    local valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$dirPathAnimation" ] && errorContent="${errorContent}\\n[动画资源目录]dirPathAnimation=$dirPathAnimation"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftBootAnimation -h && return $resultFail

    #实现主体
    while true; do
    case "$editType" in
    create)
        #默认运行前提环境
        #所在文件夹为动画包解压生成的，也就是该参数默认只能重新打包
        local dirNamePackageName=${dirPathAnimation##*/}.zip
        local fileConfig=$(ls $dirPathAnimation|grep '.txt')

        ftEcho -r  "请输入动画包的包名(回车默认animation):"
        read customPackageName
        [ ${#customPackageName} != 0 ] && dirNamePackageName=${customPackageName}.zip

        if [ -z "$dirNamePackageName" ]||[ -z "$fileConfig" ];then
            ftEcho -e "命令[${ftEffect}]运行出现错误，请查看函数"
            echo dirNamePackageName=$dirNamePackageName
            echo fileConfig=$fileConfig
        fi

        cd $dirPathAnimation
        zip -r -0 ${dirNamePackageName} */* ${fileConfig} >/dev/null
        cd $dirPathBase

        while true; do
        ftEcho -y 已生成${dirNamePackageName}，是否清尾
        read -n 1 sel
        case "$sel" in
            y | Y )
                local filePath=/${rDirPathUserHome}/${dirNamePackageName}
                if [ -f $filePath ];then
                    while true; do
                    echo
                    ftEcho -y 有旧的${dirNamePackageName}，是否覆盖
                    read -n 1 sel
                    case "$sel" in
                        y | Y )   break;;
                        n | N)    mv $filePath /${rDirPathUserHome}/${dirNamePackageName/.zip/_old.zip};break;;
                        q | Q)    exit;;
                        * ) ftEcho -e 错误的选择：$sel
                            echo "输入q，离开" ;;
                    esac
                    done
                fi
                mv ${dirPathAnimation}/${dirNamePackageName} $filePath&&
                rm -rf $dirPathAnimation
                break;;
            n | N| q |Q)  exit;;
            * )    ftEcho -e 错误的选择：$sel
                echo "输入n，q，离开";;
        esac
        done
        break;;
    new)
        local dirNamePart0=part0 dirNamePart1=part1 fileNameDesc=desc.txt fileNameLast dirNameAnimation=animation

        dirPathAnimationSourceRes=$dirPathAnimation
        cd $dirPathAnimationSourceRes

        if [[ -z $(ls $dirPathAnimationSourceRes) ]];then
            ftEcho -ex 空的动画资源，请确认[${dirPathAnimationSourceRes}]是否存在动画文件
        else
            filelist=$(ls $dirPathAnimationSourceRes)
            local dirPathLocal=$PWD
            cd $dirPathAnimationSourceRes && trap '[ -d "$dirPathLocal" ] && cd $dirPathLocal && dirPathLocal= && exit' SIGINT
            for file in ${filelist[@]} ; do [ ! -f "$file" ] && ftEcho -ex "动画资源包含错误类型的文件[${file}]，请确认" && break ;done
            cd $dirPathLocal
            trap SIGINT
        fi

        dirPathAnimationTraget=/${rDirPathUserHome}/${dirNameAnimation}

        if [ -d $dirPathAnimationTraget ]||[[ -n $(ls $dirPathAnimationTraget) ]] ;then
            while true; do
            ftEcho -y ${ftEffect}的目标文件[${dirPathAnimationTraget}]夹非空，是否删除重建
            read -n 1 sel
            case "$sel" in
                y|Y) rm -rf $dirPathAnimationTraget
                        break;;
                n|N|q|Q)  exit;;
                *) ftEcho -e 错误的选择：$sel
                    echo "输入n，q，离开";;
            esac
            done
        fi
        mkdir  -p ${dirPathAnimationTraget}/${dirNamePart0}
        mkdir      ${dirPathAnimationTraget}/${dirNamePart1}
        touch  ${dirPathAnimationTraget}/${fileNameDesc}

        #文件名去空格
        for loop in $(ls -1 | tr ' '  '#') ; do mv  "$(echo $loop | sed 's/#/ /g' )"  "$(echo $loop |sed 's/#//g')"  2> /dev/null ;done

        local file1=${filelist[0]} file1=${file1##*.}
        [ $file1 != "jpg" ] && [ $file1 != "png" ] && ftEcho -e 特殊格式[${file1}]动画资源文件，生成包大小可能异常

        #文件重命名
        index=0
        for file in $filelist ; do
            a=$((1000+$index))
            # 重命名图片，复制到part0
            fileNameLast=${a:1}.${file##*.}
            cp  $file  ${dirPathAnimationTraget}/${dirNamePart0}/${fileNameLast}
            ((index+=1))
        done
        # 复制最后一张图片到part1
        cp  ${dirPathAnimationTraget}/${dirNamePart0}/${fileNameLast} ${dirPathAnimationTraget}/${dirNamePart1}/${fileNameLast}

        # 图片的宽    图片的高   每秒显示的帧数
        # 标识符    循环的次数  阶段切换间隔时间 对应图片的目录
        # 标识符    循环的次数  阶段切换间隔时间 对应图片的目录
        # 480           250       15
        # p               1           0            part0
        # p               0           10          part1

        local resolutionWidth resolutionHeight frameRate
        local cycleCount0=1 cycleCount1=0
        while [ -z "$resolutionWidth" ] \
            ||[ -z "$resolutionHeight" ] \
            ||[ -z "$frameRate" ] \
            ||[ -z "$cycleCount0" ] \
            ||[ -z "$cycleCount1" ]; do
                if [ -z "$resolutionWidth" ];then
                    ftEcho -r  请输入动画的宽:
                    read resolutionWidth
                elif [ -z "$resolutionHeight" ]; then
                    ftEcho -r  请输入动画的高:
                    read resolutionHeight
                elif [ -z "$frameRate" ]; then
                    ftEcho -r  请输入动画的帧率:
                    read frameRate
                elif [ -z "$cycleCount0" ]; then
                    ftEcho -r  请输入part0的循环次数[0为无限次数][默认为1]:
                    read cycleCount0
                elif [ -z "$cycleCount1" ]; then
                    ftEcho -r  请输入part1的循环次数[0为无限次数][默认为0]:
                    read cycleCount1
                fi
        done

        #生成desc.txt
        local enterLine="\n"
        local content="$resolutionWidth $resolutionHeight $frameRate"
        content=${content}${enterLine}"p $cycleCount0 0 part0"
        content=${content}${enterLine}"p $cycleCount1 0 part1"
        echo -e "${content}" >${dirPathAnimationTraget}/${fileNameDesc}

        # 生成动画包
        ftBootAnimation create $dirPathAnimationTraget
        break;;
     * )
        ftEcho -e "命令[${ftEffect}]参数错误，请查看函数使用示例"
        ftBootAnimation -h
        break;;
    esac
    done
}

ftGlobalization()
{
    local ftEffect=生成国际化所需的xml文件
    local isEnable=false

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftGlobalization 无参数
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local valCount=0 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -z "$rDirPathUserHome" ] && errorContent="${errorContent}\\n[默认用户的home目录]rDirPathUserHome=$rDirPathUserHome"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGlobalization -h && return $resultFail

    #实现主体
    local filePath=${rDirPathUserHome}/tools/xls2values/androidi18nBuilder.jar
    [ ! -f $filePath ] && ftEcho -e "[${ftEffect}]找不到[$filePath]" && return $resultFail
    $filePath
}

ftPowerManagement()
{
    local ftEffect=延时免密码的做到关机重启注销
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   下面操作不指定时间默认都为10秒
#
#    延时免密码关机，
#    ftPowerManagement shutdown 时长[秒]
#    可简化 [ftPowerManagement shutdown] 为 [xs] ,其他参数不变
#
#    延时免密码重启
#    ftPowerManagement reboot 时长[秒]
#    可简化 [ftPowerManagement reboot] 为 [xss] ,其他参数不变
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local edittype=$1 timeLong=$2 filePathFlag=/tmp/xbashPowerManagementFlag
    timeLong=${timeLong:-$2}
    timeLong=${timeLong:-'10'}
    local errorContent
    [ -z "$userPassword" ] && errorContent="${errorContent}\\n[用户密码为空]userPassword=$userPassword"
    [ -z "$edittype" ] && errorContent="${errorContent}\\n[操作参数为空]edittype=$edittype"
    ( ! echo -n $timeLong | grep -q -e "^[0-9][0-9]*$" ) && errorContent="${errorContent}\\n[倒计时时长无效]timeLong=$timeLong"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPowerManagement -h && return $resultFail

    #实现主体
    while true; do
    case "$edittype" in
        shutdown )
            touch $filePathFlag
            tput sc
            for i in $(seq -w $timeLong -1 1) ; do
                tput rc;tput ed
                echo -ne "\033[1;31m将在${i}秒后关机，ctrl+c 取消\033[0m"
                sleep 1
            done
            echo $userPassword | sudo   -p '' -S shutdown -h now
            break;;
        reboot)
            touch $filePathFlag
            tput sc
            for i in $(seq -w $timeLong -1 1) ; do
                tput rc;tput ed
                echo -ne "\033[1;31m将在${i}秒后重启，ctrl+c 取消\033[0m";
                sleep 1
            done
            echo $userPassword | sudo   -p '' -S reboot
            break;;
        logout)
            tput sc
            for i in $(seq -w $timeLong -1 1) ; do
                tput rc;tput ed
                echo -ne "\033[1;31m将在${i}秒后注销，ctrl+c 取消\033[0m";
                sleep 1
            done
            /usr/bin/gnome-session-quit --logout --force
            break;;
        * ) ftEcho -e 错误的选择：$sel
            echo "输入q，离开"
            break;;
    esac
    done
}

complete -W " -h --help" -A file ftReduceFileList
ftReduceFileList()
{
    local ftEffect=精简动画帧文件
    local isEnable=true

    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftReduceFileList 保留的百分比 目录
#    ftReduceFileList 60 /home/xxxx/temp  #由于水平有限，实现对60%和50%之类的比例不敏感
#========================================================="; return ;;
    * ) break;;esac;done

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local index=0
    if (( $#==2 ));then
        local percentage=$1 dirPathFileList=$2
    elif (( $#==1 ));then
        local dirPathFileList=$1 percentage=100
        ftEcho -r  "请输入保留的百分比:"
        read percentage
    fi
    local editType=del valCount=2 errorContent
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    if [ -z "$percentage" ]\
        ||( ! echo -n $percentage | grep -q -e "^[0-9][0-9]*$")\
        ||(( $percentage<0 ))\
        ||(( $percentage>100 ));then errorContent="${errorContent}\\n[百分比取值错误]percentage=$percentage" ;fi
    [ ! -d "$dirPathFileList" ] && errorContent="${errorContent}\\n[目标目录]dirPathFileList=$dirPathFileList"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftReduceFileList -h && return $resultFail

    #实现主体
    [[ -z $(ls $dirPathFileList) ]] && ftEcho -ex 空的资源目录，请确认[${dirPathFileList}]是否存在资源文件

    percentage=$((100 - $percentage))
    local filelist=$(ls $dirPathFileList)
    local fileCount=$(ls -l $dirPathFileList| grep "^-" | wc -l)
    local continueThreshold=$(( $percentage * $fileCount ))
    local fileCountDel=$(( $continueThreshold / 100 ))
    local indexFlag=$(( $fileCount*100 / $continueThreshold ))

    ftEcho -s "总数:${fileCount}\n待删除数:${fileCountDel}\n每${indexFlag}个文件中去掉一个"
    ftEcho -y "是否删除文件(回车默认删除)" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y
    [[ "${sel}" != "y" ]] && ftEcho -s "取消操作" && return

    local dirNameFileListBase=${dirPathFileList##*/}
    local dirNameFileListBackup=${dirNameFileListBase}_bakup
    local dirPathFileListBackup=${dirPathFileList%/*}/${dirNameFileListBackup}
    [ ! -d $dirPathFileListBackup ] && mkdir $dirPathFileListBackup && cp -rf ${dirPathFileList}/*  $dirPathFileListBackup

    echo "${filelist[@]}" | while read fileName;do
        ((index+=1))
        (( $index != $indexFlag )) && continue
        rm -f -v "${dirPathFileList}/${fileName}"
        index=0
    done
}

complete -W " -h --help -d -l -ap -as -r -rs" -A file ftReNameFile
ftReNameFile()
{
    local ftEffect=批量重命名文件
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isAutoName isAddName dirPathFileList  fileNameAddPrefix fileNameAddSuffix fileTagBase fileTagNew fileSuffixTagBase fileSuffixTagNew startNumber
    local fileNameLength=4
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   使用固定长度的文件名，后缀名不变
#       ftReNameFile -d 目录 -l 修改后的文件长度
#
#   使用固定长度的文件名，后缀名不变,从xx开始计数
#       ftReNameFile -d 目录 -l 修改后的文件长度 -s xx
#
#   文件名加前缀
#        ftReNameFile -d 目录 -ap 前缀
#
#   文件名加后缀
#        ftReNameFile -d 目录 -as 后缀
#
#   替换文件名中指定字串，后缀名不变
#       ftReNameFile -d 目录 -r 原字串 新字串
#
#   替换后缀名中指定字串，文件名不变
#        ftReNameFile -d 目录 -rs 原字串 新字串
#========================================================="; return ;;
        # 变量参数解析部分==============
        -d ) dirPathFileList="${arg2}"
          ;;
        -l ) isAutoName=true
            fileNameLength="${arg2}"
          ;;
        -s ) startNumber="${arg2}"
          ;;
        -ap ) isAddName=true
                fileNameAddPrefix="${arg2}"
          ;;
        -as ) isAddName=true
                fileNameAddSuffix="${arg2}"
          ;;
        -r ) fileTagBase="${arg2}"
              fileTagNew="${arg3}"
          ;;
        -rs ) fileSuffixTagBase="${arg2}"
                fileSuffixTagNew="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    [ ! -d "$dirPathFileList" ]||[[ -z "$(ls $dirPathFileList)" ]] && errorContent="${errorContent}\\n[目标目录无效]$dirPathFileList"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftReNameFile -h && return $resultFail

    #实现主体
    [[ -z $(ls $dirPathFileList) ]] && ftEcho -ex 空的资源目录，请确认[${dirPathFileList}]是否存在资源文件

    local index=0 fileName fileSuffixName itemNew
    local dirNameFileListRename=RenameFiles
    local dirPathFileListRename=${dirPathFileList}/${dirNameFileListRename}
    local dirPathLocal=$(pwd)

    [ -d $dirPathFileListRename ] && rm -rf $dirPathFileListRename
    mkdir $dirPathFileListRename
    cd "${dirPathFileList}"

    [[ -n "${startNumber}" ]] && index=$startNumber
    while read file ;do
        [ "$file" == "$dirNameFileListRename" ] && continue
        itemNew=$(echo ${file} |sed s/[[:space:]]/_/g)
        [[ "${file}" != "${itemNew}" ]] && mv "${dirPathFileList}/${file}" "${dirPathFileList}/${itemNew}" && file="${itemNew}"

        fileName=${file%.*}
        fileSuffixName=${file##*.}

        if [[ -n "${isAutoName}" ]]; then
            fileName="$(printf "%0${fileNameLength}d" "$index")"
            cp -rf "${dirPathFileList}/${file}" ${dirPathFileListRename}/${fileName}.${fileSuffixName}
            ((index+=1))
            continue
        fi

        [[ -n "${isAddName}" ]] && fileName=${fileNameAddPrefix}${fileName}${fileNameAddSuffix}
        [[ -n "${fileTagBase}" ]] && fileName="$(echo $fileName |sed s/$fileTagBase/$fileTagNew/g)"
        [[ -n "${fileSuffixTagBase}" ]] && fileSuffixName="$(echo $fileSuffixName |sed s/$fileSuffixTagBase/$fileSuffixTagNew/g)"
        cp -rf "${dirPathFileList}/${file}" ${dirPathFileListRename}/${fileName}.${fileSuffixName}
        ((index+=1))
    done < <(echo "$(ls $dirPathFileList)")
    cd "${dirPathLocal}"
}

complete -W "-b -r -s -h --help" ftMaintainSystem
ftMaintainSystem()
{
    local ftEffect=ubuntu系统维护
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local editType
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#    当前用户权限过低，请转换为root 用户后重新运行
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    整理磁盘:
#    ftMaintainSystem -s
#    ftMaintainSystem --sd_finish
#
#    备份系统:
#    ftMaintainSystem -b
#    ftMaintainSystem --backup
#
#    还原备份:
#    ftMaintainSystem -r
#    ftMaintainSystem --restore
#
#    可简化 [ftMaintainSystem] 为 [xb] ,其他参数不变
#========================================================="; return ;;
    -c)
    local dirPathLocal=$2 dirPathStore=$3
    [ -d "$dirPathLocal" ] && cd $dirPathLocal
    [ -d "$dirPathStore" ] && rm -rf $dirPathStore
    ftIniDeleteTag -p $filePathVersionInfo -t $infoVersionName
    trap SIGINT
    return ;;
        # 变量参数解析部分==============
        -s )   editType=sdFinish    ;;
        -b )   editType=backup     ;;
        -r )   editType=restore      ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #环境校验
    [ "$(whoami)" != "root" ] && ftMaintainSystem --env && return $resultFail
    [[ -z $(which pigz) ]] && ftMaintainSystem --rely "pigz" && return $resultFail
    #变量校验
    local filePathMaintain=${rDirPathXbashModuleMaintain}/${rFileNameXbashModuleMaintain}
    [ -z "$editType" ] && errorContent="${errorContent}\\n[你想做啥哩]editType=$editType"
    [ ! -f "$filePathMaintain" ] && errorContent="${errorContent}\\n[维护脚本不存在]filePathMaintain=$filePathMaintain"
    [ -n "$errorContent" ] && ftEcho -ea "[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMaintainSystem -h && return $resultFail

    #实现主体
    source $filePathMaintain
    local  filePathVersionInfoVersion=${rDirPathXbashConfigUser}/systemVersionPacketInfo.database
    local  filePathVersionInfoMaintain=${rDirPathXbashModuleMaintain}/maintain.database

    case "$editType" in
        backup )
                    local dirPathLocal=${PWD}
                    local filePathVersionInfo=$filePathVersionInfoVersion
                    local infoVersionName=backup_${rUserName}_$(date -d "today" +"%Y%m%d")
                    local fileNameVersion=${infoVersionName}.$(ftIniGetValue $filePathVersionInfoMaintain ubuntuMaintainConfigInfo backupPackageSuffixName)
                    # 进入根目录
                        cd /
                    #新建数据库或清理无效版本记录
                        if [[ ! -f "$filePathVersionInfo" ]]; then
                            cp $rFilePathXbashModuleMaintainSystemVersionPacketInfoExample $filePathVersionInfo
                        else
                            ftCleanUpInvalidRecords -p $filePathVersionInfoVersion || return $resultFail
                        fi
                    #预写入版本信息
                        ftIniCreateFileOrTag -a -p $filePathVersionInfo -t $infoVersionName -l "\
                            fileName=$fileNameVersion \
                            backupType=null \
                            dirPathStore=null \
                            backupPackageNote=null \
                            MD5= \
                            hwCpu=null \
                            hwMainboard=null \
                            swSystemVersion=null \
                            swSystemType=null"  || return $resultFail
                        trap 'ftMaintainSystem -c $dirPathLocal $dirPathStore && exit' SIGINT
                    #选择存放备份包的设备
                        ftSetBackupDevDir -b -p $filePathVersionInfo -v $infoVersionName || return $resultFail
                    #选择备份类型
                        ftSetBackupType -p $filePathVersionInfo -v $infoVersionName -pm $filePathVersionInfoMaintain || return $resultFail
                    #记录备份包相关系统信息
                        ftSystemEnv -a -p $filePathVersionInfo -v $infoVersionName || return $resultFail
                    #写入版本说明
                        ftMaintainInfoNote -a -p $filePathVersionInfo -v $infoVersionName || return $resultFail
                    #显示当前配置信息
                        local dirPathStore=$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName  dirPathStore)
                        ftEcho -bh "备份关键信息"
                        ftEcho -s "生成的备份包：$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName fileName)"
                        ftEcho -s  "备份包的说明：$(ftIniGetValue  $filePathVersionInfoVersion $infoVersionName  backupPackageNote)"
                        ftEcho -s  "备份包保存路径：$dirPathStore"
                    #扫描设备,确认是否相同备份
                        # ftBackUpDevScanning -p $filePathVersionInfo -f $fileNameVersion -d "${mXbashModuleDataDevicesList[*]}"
                    #生成备份包
                        ftBackupOs -p $filePathVersionInfo -v $infoVersionName -pm $filePathVersionInfoMaintain || return $resultFail
                    #记录备份包校验信息
                        local filePathStore=$dirPathStore/${fileNameVersion}
                        [ -f "$filePathStore" ] && ftMD5  -p $filePathVersionInfo -s $filePathStore && ftEcho -s "备份完成"
                    #版本信息备份
                        ftIniCreateFileOrTag -r -p ${dirPathStore}/version.info -t $infoVersionName -l "\
                                fileName=$fileNameVersion \
                                backupType=$(ftIniGetValue  $filePathVersionInfo $infoVersionName backupType) \
                                dirPathStore=$(ftIniGetValue  $filePathVersionInfo $infoVersionName dirPathStore) \
                                backupPackageNote=$(ftIniGetValue  $filePathVersionInfo $infoVersionName backupPackageNote) \
                                MD5=$(ftIniGetValue  $filePathVersionInfo $infoVersionName MD5) \
                                hwCpu=$(ftIniGetValue  $filePathVersionInfo $infoVersionName hwCpu) \
                                hwMainboard=$(ftIniGetValue  $filePathVersionInfo $infoVersionName hwMainboard) \
                                swSystemVersion=$(ftIniGetValue  $filePathVersionInfo $infoVersionName swSystemVersion) \
                                swSystemType=$(ftIniGetValue  $filePathVersionInfo $infoVersionName swSystemType)" && \
                        chmod 777 ${dirPathStore}/version.info $filePathVersionInfo
                    #把备份同步到不同设备上
                        # ftSynchronous -d "${mXbashModuleDataDevicesList[*]}" -s ".*\.tgz"
                    #清尾
                        cd $dirPathLocal
                        trap SIGINT
                    ;;
        restore )
                    local tagNaeMaintain=restoreConfigInfo
                    #清理无效版本记录
                        ftCleanUpInvalidRecords -p $filePathVersionInfoVersion
                    #预写入待还原版本信息
                        ftIniCreateFileOrTag -a -p $filePathVersionInfoMaintain -t $tagNaeMaintain -l "\
                                fileName=null \
                                dirPathStore=null \
                                dirPathRestoreExclude=null"
                        trap 'ftIniDeleteTag -p $filePathVersionInfoMaintain -t $tagNaeMaintain && exit' SIGINT
                    #选择存放备份包的设备
                        ftSetBackupDevDir -r -p $filePathVersionInfoMaintain -v $tagNaeMaintain
                    #选择备份包
                        ftRestoreChoiceSource -p $filePathVersionInfoVersion -pm $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #检查备份包和当前系统兼容程度
                        local fileName=$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain fileName)
                        ftSystemEnv -c -p $filePathVersionInfoVersion -v ${fileName%.*}
                    #检查备份包是否损坏
                        local dirPathStore=$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain dirPathStore)
                        ftMD5 -p $filePathVersionInfoVersion -c "${dirPathStore}/${fileName}"
                    #选择备份包覆盖的忽略路径
                        ftSetRestoreOverryList -pm $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #当前配置信息显示
                        local versionName=${fileName%.*}
                        ftEcho -bh "还原关键信息"
                        ftEcho -s  "使用的备份包：$fileName"
                        ftEcho -s  "备份包的说明：$(ftIniGetValue $filePathVersionInfoVersion $versionName backupPackageNote)"
                        ftEcho -s  "还原时将忽略目录：$(ftIniGetValue $filePathVersionInfoMaintain $tagNaeMaintain  dirPathRestoreExclude)"
                    #执行还原操作
                        ftRestoreOperate -pm $filePathVersionInfoMaintain -t  $tagNaeMaintain -d "/"
                    #删除还原版本信息
                        ftIniDeleteTag -p $filePathVersionInfoMaintain -t $tagNaeMaintain
                    #还原成功后重启生效
                        while true; do
                        ftEcho -y "是否重启 [回车重启]"
                        read -n 1 sel
                        [ -z "${sel}" ] && sel=y
                        case "$sel" in
                            y | Y )   ftPowerManagement reboot 5 ; break;;
                            n | q )  exit;;
                            * ) ftEcho -e 错误的选择：$sel
                                echo "输入n，q，离开";;
                        esac;done
                    #清尾
                        trap SIGINT
                    ;;
        sdFinish )
                    [[ -z $(which e4defrag) ]] && ftMaintainSystem --rely "e4defrag" && return $resultFail

                    devNameDirPathList=$(df -lh | awk '{print $1}')
                    devMountDirPathList=($(df -lh | awk '{print $6}'))
                    indexDevName=0
                    indexDev=0
                    devPathList=
                    for dir in ${devNameDirPathList[*]} ; do
                            devMountDirPath=${devMountDirPathList[indexDevName]}
                            if [[ $dir =~ "/dev/" ]] && [[ $devMountDirPath != "/" ]];then
                                   printf " \e[33m %-2s \e[0m %-15s \n" [$indexDev] $dir
                                   devPathList[$indexDev]=$dir
                                   ((indexDev+=1))
                            fi
                            ((indexDevName+=1))
                    done

                    itemCount=${#devPathList[@]}
                    local num=$itemCount length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
                    ftEcho -r  "请输入对应的序号(回车默认0):"
                    read -n $length tIndex &&echo
                    #设定默认值
                    [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
                    (( $itemCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
                    e4defrag -v -c ${devPathList[$tIndex]}
                    return ;;
        * ) ftMaintainSystem -h ; return ;; esac
}

complete -W "-f -h --help -s " -A file ftFind
ftFind()
{
    local ftEffect=find的简单封装
    local isEnable=true
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

    #参数解析
    local isSuffix nameAll pathTarget="${1}" nameList="${2}" contentKey="${3}"
    local arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#   使用后缀搜索
#   ftFind -s 路径 后缀列表  文件名内容[可选]
#   ftFind -s xx/xx \"java xml\" \"yyy\"
#
#   使用文件名搜索，只支持单文件名
#   ftFind 路径 文件名 文件名内容[可选]
#   ftFind xx/xx \"*.java\" \"yyy\"
#
#    可简化 [ftFind -s] 为 [xfind] ,其他参数不变
#========================================================="; return ;;
        # 变量参数解析部分==============
        -s ) isSuffix=true
              [[ "-s" = "${arg2}" ]] && shift
              pathTarget="${2}"
              nameList="${3}"
              contentKey="${4}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    [[ -z "$nameList" ]] && ftEcho -e "参数缺失，请确认" && ftFind -h && return $resultFail

    if [[ -n "${isSuffix}" ]]; then
        (( $#<=3 )) && find "${pathTarget}" -name "${nameList}" && return $resultFail
        nameAll=$(echo "${nameList}" | sed -e "s: :|:g")
        if [[ -n "${contentKey}" ]];then
            find "${pathTarget}" -regextype posix-extended -regex ".*\.(${nameAll})" | xargs grep -e "${contentKey}"
            return
        fi
        find "${pathTarget}" -regextype "posix-extended" -regex ".*\.(${nameAll})"
        return
    fi

    nameAll=$(echo "${nameList[@]}" | sed -e "s: ::g")
    if [[ -n "${contentKey}" ]];then
        find "${pathTarget}" ! -type d -name ${nameAll}| xargs grep -e "${contentKey}"
        return
    fi
    find "${pathTarget}" ! -type d -name ${nameAll}
}

complete -W "-p -d -h --help" -A file ftPdfPasswordClear
ftPdfPasswordClear()
{
    local ftEffect=pdf密码批量清除
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local dirPathTarget passwordNum
    local valCount=4 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    ftPdfPasswordClear -d 目录或路径 -p 密码
#========================================================="; return ;;
        # 变量参数解析部分==============
        -d ) dirPathTarget="${arg2}"    ;;
        -p ) passwordNum="${arg2}"  ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #依赖校验
    [[ -z $(which qpdf) ]] && ftPdfPasswordClear --rely "qpdf" && return $resultFail
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTarget" ] && [ ! -f "$dirPathTarget" ] && errorContent="${errorContent}\\n[啥玩意]dirPathTarget=$dirPathTarget"
    [ -z "$passwordNum" ] && errorContent="${errorContent}\\n[密码不见了，帮忙找找]"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPdfPasswordClear -h && return $resultFail

    #实现主体
    local  itemNew
    while read item ;do
        itemNew=$(echo ${item} |sed s/[[:space:]]/_/g)
        [[ "${item}" != "${itemNew}" ]] && mv "${dirPathTarget}/${item}" "${dirPathTarget}/${itemNew}" && item="${itemNew}"
        local dirPathTemp="${dirPathTarget}/${item}"

        if [[ -d "$dirPathTemp" ]]; then
            ftPdfPasswordClear -d "${dirPathTemp}" -p "${passwordNum}"

        elif [[ -n $(echo $item |grep -i ".pdf") ]]; then
            local filePath="${dirPathTemp}"
            local filePathTemp="/tmp/temp_${item}"

            cp "${filePath}" "${filePathTemp}"
            [ ! -f "$filePath" ] && ftEcho -s "${filePath}  不存在" && continue
            qpdf --password="${passwordNum}" --decrypt "${filePathTemp}" "${filePath}" && ftEcho -s "[密码已清除] ${item}" || ftEcho -e "[密码清除失败] ${item}"
            rm "${filePathTemp}" > /dev/null

        fi
    done < <(echo "$(ls $dirPathTarget)")
}


complete -W "-h --help" -A file ftDu
ftDu()
{
    local ftEffect=查找大文件
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
        #解参验耦
    local dirPathTarget fileCount dirPathLocal=$(pwd)
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftDu -n 文件数量
#    ftDu -d 目录 -n 文件数量
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -d ) dirPathTarget="${arg2}"
            ;;
        -n ) fileCount="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

   #参数校验
    dirPathTarget=${dirPathTarget:-"${dirPathLocal}"}
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [[ ! -d "$dirPathTarget" ]] && errorContent="${errorContent}\\n目录[${dirPathLocal}]不存在"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDu -h && return $resultFail

    #实现主体
    cd $dirPathTarget
    fileCount=${fileCount:-'10'}
    echo $userPassword | sudo  -p '' -S  du -hsx * | sort -rh | head -${fileCount}
    cd $dirPathLocal
}

complete -W "-h --help" ftUpdateSublimeSnippet
ftUpdateSublimeSnippet()
{
    local ftEffect=更新SublimetSnippet
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    # 说明参数解析部分
    while true; do case "$1" in
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    无参
#    ftUpdateSublimeSnippet xxxx
#========================================================="; return ;;
    * ) break;;esac;done

    #解参验耦
    [[ -z "$SUDO_USER" ]] && userName=$USER || userName=$SUDO_USER
    local dirPathSublimeSnippet=/home/${userName}/.config/sublime-text-3/Packages/User \
    dirPathConfigSource=/home/${userName}/xconfig/sublime_text/sublime-snippet

    [ ! -d "$dirPathConfigSource" ] && errorContent="${errorContent}\\n[配置文件不存在]dirPathConfigSource=$dirPathConfigSource"
    [ ! -d "$dirPathSublimeSnippet" ] && errorContent="${errorContent}\\n[配置文件存放位置不存在]dirPathSublimeSnippet=$dirPathSublimeSnippet"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftUpdateSublimeSnippet -h && return $resultFail

    #实现主体
    local userName dirPathLocal=$(pwd)
    cd $dirPathSublimeSnippet
    while read item ;do
       ln -sf ${dirPathConfigSource}/${item}
    done < <(echo "$(ls $dirPathConfigSource)")
    cd $dirPathLocal
}

complete -W "-h --help --rely_install -p " -A file ftOpenNemoTab
ftOpenNemoTab()
{
    local ftEffect=在nemo中打开新标签
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local dirPathTarget
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#     请尝试使用下面方法补全依赖
#     ftOpenNemoTab --rely_install
#========================================================="; return ;;
    --rely_install)
        ftEcho -s "开始补全依赖"
        sudo add-apt-repository ppa:webupd8team/nemo
        sudo apt-get update
        sudo apt-get install -y xclip wmctrl xdotool nemo nemo-fileroller
        sudo apt-get install -y nemo-compare nemo-media-columns nemo-pastebin nemo-seahorse nemo-share
        return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    自动补齐依赖
#    ftOpenNemoTab --rely_install
#
#    打开新标签
#    ftOpenNemoTab -p 路径
#========================================================="; return ;;
    # 变量参数解析部分==============
    -p ) dirPathTarget="${arg2}"
      ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    if [[ -z $(which xclip) ]] || [[ -z $(which wmctrl) ]] || [[ -z $(which xdotool) ]] || [[ -z $(which nemo) ]] ;then
        ftOpenNemoTab --rely ;return $resultFail
    fi
    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -d "$dirPathTarget" ] && errorContent="${errorContent}\\n[示例1]dirPathTarget=$dirPathTarget"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftOpenNemoTab -h && return $resultFail

    #实现主体
    local windowId=$(wmctrl -xl | grep "nemo.Nemo"| awk '{print $1}')
    if [ -z "${windowId}" ]; then
        nemo "$dirPathTarget"
    else
        echo -n "$dirPathTarget" | xclip -i -sel clip
        if wmctrl -xF -R nemo.Nemo ;then
            xdotool windowfocus $windowId key ctrl+t
            sleep 0.7
            xdotool windowfocus $windowId key ctrl+l
            sleep 0.2
            xdotool windowfocus $windowId key ctrl+v
            sleep 0.1
            xdotool key enter Return
        fi
        echo -n "" | xclip -i -sel clip
    fi
}

_cdAospDirectory()
{
    local ftEffect=快速进入Aosp功能目录参数补全实现
    local isEnable=def

    local curr_arg=${COMP_WORDS[COMP_CWORD]}
    COMPREPLY=( $(compgen -W 'app out frameworks' ) )
    case "${COMP_WORDS[1]}" in
                    app)         COMPREPLY=( $(compgen -W 'settings launcher dialer factorytest' -- $curr_arg ) )
                                  ;;
                    out)  COMPREPLY=( $(compgen -W "product productObj system commonObj " -- $curr_arg ) )
                                ;;
                    frameworks)  COMPREPLY=( $(compgen -W 'base opt ' ) );
                                case "${COMP_WORDS[2]}" in
                                                base)  COMPREPLY=( $(compgen -W 'cmd core data packages services' ) );
                                                            case "${COMP_WORDS[3]}" in
                                                                            packages)  COMPREPLY=( $(compgen -W 'systemui settingsprovider' -- $curr_arg ) ); ;;
                                                                            core)  COMPREPLY=( $(compgen -W 'java res' -- $curr_arg ) ); ;;
                                                            esac
                                                            ;;
                                esac
                                ;;
                    *)  COMPREPLY=( $(compgen -W 'app out frameworks settings launcher dialer factorytest product productObj system commonObj base opt cmd core data packages services systemui settingsprovider java res' -- $curr_arg ) ); ;;
      esac
}
complete -F _cdAospDirectory -A file ftCdAospDirectory
ftCdAospDirectory()
{
    local ftEffect=快速进入Aosp功能目录
    local isEnable=true

    #可用性校验
    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    [[ -n "${ANDROID_BUILD_TOP}" ]] && cd $ANDROID_BUILD_TOP || \
    if [[ ! -d "alps" ]] && [ ! -d "idh" ]; then
        if [[ ! -d "build" ]] && [[ ! -d "frameworks" ]] && [[ ! -d "ndk" ]] && [[ ! -d "dalvik" ]] && [[ ! -d "vendor" ]];then
            ftCdAospDirectory --env&& return $resultFail
        fi
    fi

    local isUserFileManager dirPathTarget
    local valCount=1 errorContent arg arg2 arg3  arg4 argVal ; for ((i=1;i<=$#;i++)) ; do
    eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; eval arg4=\${$((i+3))} ; case "${arg}" in
    # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    切换终端路径
#    ftCdAospDirectory xxx xxx xxxx
#
#    在文件管理器中打开
#    ftCdAospDirectory -fm xxx xxx xxxx
#
#    可简化 [ftCdAospDirectory] 为 [xca] ,其他参数不变
#
#    xxx 说明
#    树位置代表参数自动适配顺序，函数行为以最后一个参数为准
#    在最后一个参数不存在重复时，可以直接使用最后一个参数
        ├──app
        │   └── settings / launcher / dialer / factorytest
        ├──frameworks
        │   ├── base
        │   │    ├── cmd / data / services
        │   │    ├── packages
        │   │    │     └── systemui / settingsprovider
        │   │    └── core
        │   │          └── res/ java
        │   └── opt
        └── out
             └──  commonObj / product / productObj / system
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#==========================================================
# 当前非有效AOSP目录，请确认
# 可以尝试使用 ftAutoCdAospProject 快速进入项目
#========================================================="; return ;;
        # 变量参数解析部分==============
        -fm ) isUserFileManager=true ;;
        settings | launcher |dialer | factorytest | base | opt |cmd | core | java | res |data|\
        packages | systemui | settingsprovider | services | commonObj ) argVal="${arg}" ;;
        product |system |productObj )
                        local dirPathProduct="out/target/product"
                        while read item ;do
                           [[ -f "${dirPathProduct}/${item}/system.img" ]] && dirPathProduct=${dirPathProduct}/${item} && break
                        done < <(echo "$(ls $dirPathProduct)")

                        [[ "${arg}" = "system" ]] && dirPathTarget="${dirPathProduct}/system"
                        [[ "${arg}" = "productObj" ]] && dirPathTarget="${dirPathProduct}/obj"
                        [[ -z "$dirPathTarget" ]]  && dirPathTarget="${dirPathProduct}"
        ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #实现主体
    [[ -z "$dirPathTarget" ]] && dirPathTarget=$(ftXbGetValue ftCdAospDirectoryInfo ${argVal})
    if [[ ! -d "$dirPathTarget" ]];then
        if [[ -d "alps/${dirPathTarget}" ]];then
            dirPathTarget=alps/${dirPathTarget}
        elif [[ -d "idh/${dirPathTarget}" ]];then
            dirPathTarget=idh/${dirPathTarget}
        else
            ftEcho -e "找不到${dirPathTarget}" && return $resultFail
    fi ;fi
    if [[ -z "$isUserFileManager" ]];then
        local dirPathLocal=$(pwd)
        cd $dirPathTarget && [[ -z "${ANDROID_BUILD_TOP}" ]] && export ANDROID_BUILD_TOP=$dirPathLocal
        return
    fi
    ftOpenNemoTab -p $(pwd)/${dirPathTarget}
}

complete -W "-h --help --rely_install" ftCheckCcache
ftCheckCcache()
{
    local ftEffect=ccache空间溢出校验
    local isEnable=$isUseBuildCcache

    #可用性校验
    [[ "$isEnable" != "true" ]] && return #&& ftEcho -s "${ftEffect} 已停用，请确认" && return
    # 说明参数解析部分
    local isChecked
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install ccache
            return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    补全依赖
#    ftCheckCcache --rely_install
#
#    获取当前已使用 ccache 大小
#    ftCheckCcache -c
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -c ) isChecked=true
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    [[ -z $(which ccache) ]] && ftCheckCcache --rely "ccache" && return $resultFail
    [[ ! -d ${CCACHE_DEV_DIR} ]] && return $resultFail
    #解参验耦
    (( $# > $valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCheckCcache -h && return $resultFail

    #实现主体
    local keyCacheSizeNow="cache size"
    local keyCacheSizeMax="max cache size"
    local UnitMb="Mbytes" UnitGb="Gbytes"
    local cacheSizeNow=$(ccache -s |grep -v "${keyCacheSizeMax}" |grep "$keyCacheSizeNow")
    local cacheSizeNowUint=$(echo $cacheSizeNow| awk '{print $4}' )
            cacheSizeNow=$(echo $cacheSizeNow| awk '{print $3}')
            cacheSizeNow=${cacheSizeNow%.*}
    local cacheSizeNowUnit=$(ccache -s |grep -v "${keyCacheSizeMax}" |grep "${keyCacheSizeNow}"| awk '{print $4}')
    local cacheSizeMax=$(ccache -s |grep "$keyCacheSizeMax" | tr -d "a-zA-Z"|sed s/[[:space:]]//g)
            cacheSizeMax=${cacheSizeMax%.*}
    local cacheSizeMaxUnit=$(ccache -s |grep "$keyCacheSizeMax"| awk '{print $5}')
    local ccacheStorageDeviceAvailableSpaceSize=$(ftDevAvailableSpace -g ${CCACHE_DEV_DIR})
            ccacheStorageDeviceAvailableSpaceSize=${ccacheStorageDeviceAvailableSpaceSize%.*}

    if [[ ${cacheSizeNowUint} = ${UnitMb} ]]; then
        #cacheSizeNow=$(printf "%.2f" `echo "scale=2;$cacheSizeNow/1024"|bc`)
        cacheSizeNow=1
    fi

    if [[ -n "$isChecked" ]]; then
        export ccacheEnv_SizeNow="${cacheSizeNow}"
        export ccacheEnv_SizeNowUni="${cacheSizeNowUnit}"
        export ccacheEnv_SizeMax="${cacheSizeMax}"
        export ccacheEnv_SizeMaxUnit="${cacheSizeMaxUnit}"
        return
    fi

    if [[ -n $(echo $cacheSizeMaxUnit |grep $UnitMb) ]] || (( $(echo "$cacheSizeMax < 20"|bc) == 1 ));then
        ftEcho -e "ccache 空间有限,请及时使用ccache -M xxG处理"
        return
    fi

    [[ -z "${cacheSizeNow}" ]] \
    || [[ -z "${cacheSizeMax}" ]] \
    || (( $cacheSizeNow <= 0 )) \
    || (( $cacheSizeMax == 1 )) && return $resultFail
    local proportionSize="0$(echo "scale=5; $cacheSizeNow / $cacheSizeMax" | bc)"
    local remainingSize="$(echo "scale=5; $cacheSizeMax - $cacheSizeNow" | bc)"
    #local proportionThresholdSize=0.855 remainingThresholdSize=10.0 #10GB/基本满足单次新工程的缓存空间要求
    local proportionThresholdSize=0.9 remainingThresholdSize=4.0

    if (( $(echo "$proportionThresholdSize < ${proportionSize}"|bc) == 1 )) \
        &&(( $(echo "$remainingSize < ${remainingThresholdSize}"|bc) == 1 )) ;then
        ftEcho -e "ccache 剩余空间有限,即将溢出,请及时处理"
    fi

    (( $cacheSizeMax-$cacheSizeNow > $(ftDevAvailableSpace -g ${CCACHE_DEV_DIR}))) && ftEcho -e "ccache的存储剩余空间不足,请及时处理"
}

complete -W "--help --stop --clearn -h -s -sp -c -p" -A file ftMtkLog
ftMtkLog()
{
    local ftEffect=MTK的log相关操作封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isPull isCheck isSeparation isClearn isStop isPullMini deviceIdLocal filePathLog pathLog dirPathLogStorge fileSizeBaseMillionByte
    local valCount=3 errorContent arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ;case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    指定设备ID
#    ftMtkLog -s 设备ID
#
#    导出log文件
#    ftMtkLog -p  log存放路径
#
#    导出精简版log文件
#    ftMtkLog -pm  log存放路径
#    可简化 [ftMtkLog -p  log存放路径] 为 [xpml] ,其他参数不变
#
#    分析log
#    ftMtkLog -c log文件路径或log目录
#
#    分割log文件
#    ftMtkLog -sp  log文件路径
#    ftMtkLog -sp  log文件路径 分割的大小[MB],默认为2
#    ftMtkLog -sp  /xx/xx.log 3M
#
#    停止mtk的log抓取
#    ftMtkLog --stop
#
#    清理设备log文件
#    ftMtkLog --clearn
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
# 环境未初始化
# 使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;
        # 变量参数解析部分==============
        --clearn) isClearn=true ; ;;
        --stop) isStop=true ; ;;
        -s ) deviceIdLocal="${arg2}"
             ;;
        -p ) isPull=true
             [ -d "${arg2}" ] && dirPathLogStorge="${arg2}"
             ;;
        -pm ) isPull=true
             isPullMini=true
             [ -d "${arg2}" ] && dirPathLogStorge="${arg2}"
             ;;
        -c ) isCheck=true
              pathLog="${arg2}"
             ;;
        -sp ) isSeparation=true
             [ -f "${arg2}" ] && filePathLog="${arg2}"
             fileSizeBaseMillionByte="${arg3}"
             fileSizeBaseMillionByte=${fileSizeBaseMillionByte:-'2M'}
             ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which adb) ]] && ftEcho -e "依赖Android的SDK中的adb,请确认是否可用" && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ "$isPull" = "true" ] && [ -z "${dirPathLogStorge}" ] && errorContent="${errorContent}\\n无法导出log,不知道放哪里"
    [ "$isCheck" = "true" ] && [ ! -d "${pathLog}" ] && [ ! -f "${pathLog}" ] && errorContent="${errorContent}\\n无法分析,没有目标log"
    [ "$isSeparation" = "true" ] && [ -z "${filePathLog}" ] && errorContent="${errorContent}\\n无法分割,没有目标log"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMtkLog -h && return $resultFail

    #实现主体
    if [ "$isPull" = "true" ] \
        || [ "$isClearn" = "true" ] \
        || [ "$isStop" = "true" ];then
        #adb连接状态检测
        if [[ -z "${deviceIdLocal}" ]];then
            ftAdbConnect ; [[ -z "${autoTestDeviceId}" ]] && return $resultFail
            local deviceId=${autoTestDeviceId}
        fi
    fi

    if [ "$isPull" = "true" ];then
        local dirNameMtkLog=mtklog
        local dirPathLogDevice=/sdcard/mtklog
        local dirPathBuildpropDevice=/system/build.prop
        local editFlag=$(date -d "today" +"%y%m%d%H%M%S")
        local dirPathLogStorgeAll=$(ftPath $dirPathLogStorge)/${dirNameMtkLog}/${editFlag}_${deviceId}

        if [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDevice ]&&echo exit") ]]; then

            ftEcho -y "是否存在测试设备编号,没有请按除y之外的任意键跳过"
            read -n 1 sel
            [ -z "${sel}" ] && sel=n
            while true; do case "$sel" in
                    y | Y )
                        read -n deviceTestId
                        dirPathLogStorgeAll=$(ftPath $dirPathLogStorge)/${dirNameMtkLog}/${editFlag}_${deviceTestId}
                        break ; ;;
                    * ) break ; ;;
            esac;done
            [[ ! -d "${dirPathLogStorgeAll}" ]] && mkdir -p ${dirPathLogStorgeAll}

            # 全部mtklog
            if [[ -z "${isPullMini}" ]]; then

                ftEcho -s "正在导出mtklog 到 ${dirPathLogStorge}"

                adb -s $deviceId shell ls ${dirPathLogDevice} | while read dirNameLog;do
                    dirNameLog=$(echo $dirNameLog |sed s/[[:space:]]//g)
                    dirPathLog=${dirPathLogStorgeAll}/${dirNameLog}
                    [[ ! -d "${dirPathLog}" ]] && mkdir -p ${dirPathLog}
                    adb -s $deviceId pull ${dirPathLogDevice}/${dirNameLog} ${dirPathLog}
                done

                ftEcho -y "是否对设备的mtklog添加已导出标示(回车默认y)"
                read -n 1 sel
                [ -z "${sel}" ] && sel=y
                while true; do case "$sel" in
                        y | Y )
                            local pullFlag=pull_${editFlag}
                            adb -s $deviceId shell mv ${dirPathLogDevice} ${dirPathLogDevice}_${pullFlag}
                            break ; ;;
                        * ) break ; ;;
                esac;done

            # 部分 mtklog
            else
                local dirPathLog
                ftEcho -s "正在导出部分mtklog 到 ${dirPathLogStorge}"
                adb -s $deviceId pull ${dirPathLogDevice}/aee_exp ${dirPathLogStorgeAll}/aee_exp
                adb -s $deviceId shell ls ${dirPathLogDevice}/mobilelog | while read dirNameLog;do
                    dirPathLog=${dirPathLogStorgeAll}/mobilelog/$(echo $dirNameLog |sed s/[[:space:]]//g)
                    [[ ! -d "${dirPathLog}" ]] && mkdir -p $dirPathLog
                    adb -s $deviceId pull ${dirPathLogDevice}/mobilelog/${dirNameLog}/crash_log ${dirPathLog}
                done
                adb -s $deviceId pull ${dirPathBuildpropDevice} ${dirPathLogStorgeAll}
            fi
        else
            ftEcho -e "设备不存在${dirNameMtkLog},请确认设备的${dirNameMtkLog}是否存在[${dirPathLogDevice}]"
        fi

        local dirNameOtherLog=other_log
        dirPathLogStorge=${dirPathLogStorgeAll}/${dirNameOtherLog}
        [[ ! -d ${dirPathLogStorge} ]] && mkdir -p ${dirPathLogStorge}

        local dirPathLogDeviceAEE=/data/aee_exp
        [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDeviceAEE ]&&echo exit") ]] && \
        ftEcho -s "正在导出 aee_exp log 到 ${dirPathLogStorge}" && \
        adb -s $deviceId pull ${dirPathLogDeviceAEE} ${dirPathLogStorge}

        local dirPathLogDeviceANR=/data/anr
        [[ -n $(adb -s $deviceId shell "[ -d $dirPathLogDeviceANR ]&&echo exit") ]] && \
        ftEcho -s "正在导出 anr log 到 ${dirPathLogStorge}" && \
        adb -s $deviceId pull ${dirPathLogDeviceANR} ${dirPathLogStorge}

    fi

    # 停止mtklog
    [ "$isStop" = "true" ] && ftEcho -s "正在停止抓取mtklog" && ftKillApplicationByPackageName "com.mediatek.mtklogger" > /dev/null

    # 清理mtklog
    [ "$isClearn" = "true" ] && [[ -n $(adb -s $deviceId shell ls ${dirPathDevicesTarget}/mtklog) ]] && \
    ftEcho -s "正在清理mtklog" && adb -s $deviceId shell rm -rf /sdcard/mtklog

    #分割log
    if [ "$isSeparation" = "true" ];then
        [[ ! -f "${filePathLog}" ]] && ftEcho -e "找不到分割的文件: ${filePathLog}" && return $resultFail

        local fileName=$(basename $filePathLog)
        local dirPathLog=$(dirname $filePathLog)
        local fileNameBase=${fileName%.*}
        local fileNameEnd=${fileName##*.}
        local fileSizeBaseByte=2097152
        local filePathLogSize=$(stat -c "%s" $filePathLog) #B
        local dirPathLocal=$(pwd)

        cd $dirPathLog
        [[ "${fileNameBase}" = "${fileNameEnd}" ]] || [[ -z "${fileNameEnd}" ]] && fileNameEnd="log"
        (( $filePathLogSize <= $fileSizeBaseByte )) && ftEcho -s "${fileName} 文件无需分割" && return
        [[ -n "${fileNameEnd}" ]] && split --verbose -b $fileSizeBaseMillionByte "$filePathLog" -d -a 4 --additional-suffix=.${fileNameEnd} $fileNameBase
        ftEcho -s "${fileName} 分割完成"
        cd $dirPathLocal
    fi

    #分析log
    if [ "$isCheck" = "true" ];then
        local pathLogTemp=/tmp/log.tmp \
                 index=0 checkIndex=10 \
                 replaceVal="" \
                 fileNameCheck="ck"
        local lengthReplace
        local filePathListCheck=($(find $pathLog -name "*.${fileNameCheck}" -type f))

        if [[ -n "${filePathListCheck[@]}" ]];then
            ftEcho -y "存在旧的分析文件,是否开始重新分析(回车默认y)"
            read -n 1 sel && echo
            [ -z "${sel}" ] && sel=y
            [[ "$sel" != "y" ]] && return
            for index in "${!filePathListCheck[@]}"; do
               rm -v ${filePathListCheck[$index]}
            done && echo
        fi

        ftEcho -s "开始分析: ${pathLog},请稍等"
        local dirNameCheckLog="LogSummary"
        local dirPathCheckLog=${pathLog}/${dirNameCheckLog}
        [[ ! -d $dirPathCheckLog ]] && mkdir -p $dirPathCheckLog
        local key="AndroidRuntime" \
                Key2="AEE/DEBUG"
        grep -Ersl "${key}|${Key2}" $pathLog | while read filePath;do
            [[ ${filePath##*.} = ${fileNameCheck} ]] && break
            # [[ $(basename $filePath) = "crash_log" ]] && continue
            echo filePath=${filePath}

            echo "" > $pathLogTemp
            grep -rs "${key}" $filePath | grep -v "PID:" | while read line;do
                (( $checkIndex <= $index ))||[[ -z "${lengthReplace}" ]] && lengthReplace=$(expr index "${line}" ${key}) && (( lengthReplace-=5 )) && index=0
                 echo ${line:$lengthReplace} >> $pathLogTemp
                ((index+=1))
            done

            # lengthReplace=0
            grep -rs "${Key2}" $filePath | grep -v "PID:" | while read line;do
                # (( $checkIndex <= $index ))||[[ -z "${lengthReplace}" ]] && lengthReplace=$(expr index "${line}" ${Key2}) && (( lengthReplace-=5 )) && index=0
                 echo ${line} >> $pathLogTemp
                # ((index+=1))
            done

            local filePathCheck=${filePath}.${fileNameCheck}
            local fileNameCheckAll=$(basename ${filePathCheck})
            cat $pathLogTemp \
            | sort -rn \
            | uniq -c \
            | sort -u \
            > ${filePathCheck} && \
            mv $filePathCheck ${dirPathCheckLog}/${fileNameCheckAll} && \
            ftEcho -s "生成分析文件:${fileNameCheckAll} 到${dirPathCheckLog}"
        done
    fi
}

complete -W "-h --help -w --wifi -u -s" ftAdbConnect
ftAdbConnect()
{
    local ftEffect=adb连接处理
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #解参验耦
    local isUseWifi isUpdateDeviceId isElevation isScreenShare isReConnectWifi
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分 ==============
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    ftAdbConnect 无参
#
#    重启adb服务
#    ftAdbConnect -r
#
#    使用wifi调试
#    ftAdbConnect -w / --wifi
#
#    更新adb的设备ID
#    ftAdbConnect -u
#
#    更新adb的设备ID , 提高adb的设备的权限许可
#    ftAdbConnect -e
#
#    共享设备屏幕
#    ftAdbConnect -s
#    可简化 [ftAdbConnect -s] 为 [xass]
#========================================================="; return ;;
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    请尝试使用下面命令补全依赖
#    sudo apt install snapd
#    sudo snap install scrcpy
#========================================================="; return ;;
    --env) ftEcho -rc "${ftEffect}" " 的使用环境说明" "\
#=========================================================
#
# 依赖Android的SDK中的adb,请确认是否可用
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -r)
            adb kill-server >/dev/null
            ftEcho -s "server kill ......"
            sleep 2
            adb start-server >/dev/null
            ftEcho -s "server start ......"
            adb devices
            return
          ;;
        -s ) isScreenShare=true
            ftEcho -s "共享屏幕已停用，请确认" && return
          ;;
        -w | --wifi ) isUseWifi=true
          ;;
        -rw | --reWifi ) isUseWifi=true
                                isReConnectWifi=true
          ;;
        -u ) isUpdateDeviceId=true
          ;;
        -e ) isElevation=true
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    if [[ -n "${isScreenShare}" ]]; then
         [[ -z $(which snap) ]]  && ftAdbConnect --rely && return $resultFail
         [[ -n $(snap info scrcpy|grep "no snap found") ]]  && ftAdbConnect --rely && return $resultFail
    fi
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAdbConnect -h && return $resultFail
    [[ -z $(which adb) ]] && ftAdbConnect --env && return $resultFail
    [[ ! -d ${ANDROID_SDK} ]] && ftAdbConnect --env && return $resultFail
    #环境校验
    [[ -n "$ANDROID_BUILD_TOP" ]] && ftEcho -s "当前终端已初始化Android编译环境,此功能不可用" \
    && export autoTestDeviceId= && return $resultFail

    #实现主体
    local deviceIdDefault=0123456789ABCDEF
    local deviceLogcatBufferCacheMax=100M
    local deviceId=${deviceIdDefault}
    local deviceIdTarget=$(date -d "today" +"%y%m%d%H%M%S")
    local deviceIdList=($(adb devices |grep -v "List of devices attached" |awk '{print $1}'))
    local deviceIdListUniq=($(echo "${deviceIdList[@]}"  | sed 's/ /\n/g' |sort |uniq))
    local deviceCount=${#deviceIdList[@]}
    local deviceCountUniq=${#deviceIdListUniq[@]}
    local deviceIdold=$autoTestDeviceId

    (( $deviceCount != 0 )) && (( $deviceCountUniq != 0 ))  && (( $deviceCount != $deviceCountUniq )) && \
        ftEcho -s "存在多个同ID设备,请手动移除设备"&& adb devices && return $resultFail
    export autoTestDeviceCounts=$deviceCount

    if (( $deviceCount <=1 ));then
        ftEcho -sn "等待设备连接>"
        adb wait-for-device
        deviceId=$(adb get-serialno)
    # elif [[ -n "${deviceIdold}" ]]&&[[ -n $(echo ${deviceIdList[@]} |grep $deviceIdold ) ]]; then
    #     ftEcho -sn "等待设备连接>"
    #     deviceId=$deviceIdold
    else
        if [[ -n "${deviceIdold}" ]]; then
            ftEcho -y "存在旧的设备ID,是否更新(回车默认y)"
            read -n 1 sel && [ -z "${sel}" ] && sel=y
            while true; do case "$sel" in
                    y | Y ) export autoTestDeviceId=;echo; break; ;;
                    n | q ) echo;return ; ;;
                    * ) ftEcho -e "错误的选择：$sel"
                        echo "输入n，q，离开";;
            esac;done ;
        fi
        if [[ -n ${isUseWifi} ]]; then
            ftEcho -y "需要断开其他wifi调试连接是否继续" ; read -n 1 sel ; [ -z "${sel}" ] && sel=y
            [[ "${sel}" != "y" ]] && return $resultFail
            adb disconnect
        fi

        if (( $deviceCount >1 )) ;then
            ftEcho -s "存在多个设备,请选择"
            local index=0
            for deviceId in ${deviceIdList[@]} ; do
                printf "%-4s %-4s\n" [$index] $deviceId
                ((index+=1))
            done

            local num=$deviceCount ; local length=0 ; while (( $num>0 )); do ((num=num/10 )) ; ((length+=1)) ; done
            ftEcho -r  "请输入对应的序号(回车默认0):"
            read -n $length tIndex &&echo
            #设定默认值
            [ ${#tIndex} == 0 ] && tIndex=0 #设定默认值
            (( $deviceCount<=$tIndex ))||(( $tIndex<0 ))||( ! echo -n $tIndex | grep -q -e "^[0-9][0-9]*$") && ftEcho -e "\n无效的序号:${tIndex}" && return $resultFail
            deviceId=${deviceIdList[$tIndex]}
            ftEcho -sn "等待设备连接>"
        fi

        if [[ -n "$isUpdateDeviceId" ]] \
                && [[ -n $(echo ${deviceIdList[@]} |grep $deviceIdDefault ) ]]\
                && [[ "${deviceId}" != "${deviceIdTarget}" ]];then # 对默认deviceID进行修改
            ftEcho -sn "等待设备连接>" && adb -s $deviceId wait-for-device
            if adb -s $deviceId shell "echo $deviceIdTarget > /sys/class/android_usb/android0/iSerial"; then
                ftEcho -sn "请重新插拔usb设备>"
                deviceId=$deviceIdTarget
            else
                ftEcho -en "更新deviceId失败,缺少必要权限,将使用默认ID" ; ftEcho -sn ">"
            fi

        fi
    fi

    adb -s $deviceId wait-for-device
    local adbStatus=$(adb -s $deviceId get-state)
    [ "$adbStatus" != "device" ] && ftEcho -e "adb连接状态[$adbStatus]异常,请重新尝试" && return $resultFail
    ftEcho -s "连接设备成功"
    adb -s $deviceId logcat -G $deviceLogcatBufferCacheMax

    export autoTestDeviceId=$deviceId
    [[ -n "${deviceIdold}" ]]&&[[ "${deviceId}" != "${autoTestDeviceId}" ]] && echo -en "设备ID更新:" && ftEcho -s "${autoTestDeviceId} > ${deviceId}"

    if [[ -n ${isUseWifi} ]]; then
        if [[ -n ${isReConnectWifi} ]] && [[ -n ${ENV_ADB_DEV_IP} ]]; then
            adb -s $ENV_ADB_DEV_ID connect ${ENV_ADB_DEV_IP}:${ENV_ADB_DEV_PORT}
            return
        fi
        adb -s $deviceId shell svc wifi enable
        ftEcho -y "请确认设备是否连接wifi(回车确认)" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y ; [[ $sel != "y" ]] && return $resultFail
        local ipAddressList portNum \
                 ipAddressInfoList=($(adb shell ifconfig wlan0 |grep inet)) \
                 key="addr:"
        if [[ -n "${ipAddressInfoList}" ]]; then
            for ip in ${ipAddressInfoList[@]}; do
                [[ "${ip}" != ${key}* ]] && continue
                ip=${ip//$key/}
                [[ -z "${ip}" ]] && continue
                ipAddressList=(${ipAddressList[@]} ${ip})
            done
        else
             ipAddressList=($(adb shell ifconfig wlan0 |grep -v "wlan0: No such device"| awk '{print $3}'))
        fi
        [[ -z ${ipAddressList[@]} ]]||(( ${#ipAddressList[@]}==0 )) && ftEcho -e "无法获取设备wifi相关IP地址" && return $resultFail

        ftEcho -s "设备IP:${ipAddressList[@]}"

        ftEcho -sn "请设定wifi调试端口号(5555-5585)(回车默认5555):"
        read -n 4 portNum && echo ;[ -z "${portNum}" ] && portNum=5555
        adb -s ${deviceId} tcpip ${portNum}
        for ipAddress in ${ipAddressList[*]}; do
            adb -s $deviceId connect ${ipAddress}:${portNum}
            export ENV_ADB_DEV_ID=${deviceId}
            export ENV_ADB_DEV_IP=${ipAddress}
            export ENV_ADB_DEV_PORT=${portNum}
        done
    fi

    # 自动提权
    if [[ -n "${isElevation}" ]]; then
        local keyAdbVersion="Android Debug Bridge version "
        local adbVersionCode=$(adb version |grep "${keyAdbVersion}" | sed -e "s:$keyAdbVersion::g")
        local result=$(ftVersionComparison $adbVersionCode "1.0.32") resultFlag=">"

        [[ ${result} == *$resultFlag* ]] && adb -s $deviceId disable-verity
        result=$(adb -s $deviceId root) ; resultFlag="cannot"
        [[ ${result} == *$resultFlag* ]] && ftEcho -en "提权失败:" && echo ${result} && return $resultFail
        result=$(adb -s $deviceId remount) ; resultFlag="failed"
        [[ ${result} == *$resultFlag* ]] && ftEcho -en "提权失败:" && echo ${result} && return $resultFail
        adb -s $deviceId disable-verity
        ftEcho -s "ADB提权成功"
    fi

    # 连接屏幕共享
    if [[ -n "${isScreenShare}" ]] && [ -n "${deviceId}" ]; then
        ftEcho -s "开始共享设备:${deviceId}的屏幕 ... "
        # export ADB="${ANDROID_SDK_ROOT}/platform-tools/adb"
        # snap run scrcpy
        # guiscrcpy
    fi
}

complete -W "-h --help -r" ftScrcpy
ftScrcpy()
{
    local ftEffect=scrcpy简单扩展
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local isReset
    local valCount=2 errorContent arg arg2
    for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftScrcpy 无参
#
#    重置scrcpy
#    ftScrcpy -r
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -r ) isReset=true
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftScrcpy -h && return $resultFail

    #实现主体
    if [[ -n "$isReset" ]]; then
        echo $userPassword | sudo -p '' -S  snap remove core
        echo $userPassword | sudo -p '' -S  snap remove scrcpy
        echo $userPassword | sudo -p '' -S  snap install core
        echo $userPassword | sudo -p '' -S  snap install scrcpy
        snap connections scrcpy
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:adb-support :adb-support
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:x11 :x11
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:desktop :desktop
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:desktop-legacy :desktop-legacy
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:network :network
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:network-bind :network-bind
        echo $userPassword | sudo -p '' -S  snap connect scrcpy:wayland :wayland
        ftEcho -s "scrcpy重置结束"
        return
    fi

    local filePathToolScrcpy=/snap/bin/scrcpy
    ADB=${ANDROID_SDK}/platform-tools/adb $filePathToolScrcpy -m 1024
}

complete -W "-h --help --rely_install -c" -A file ftPigz
ftPigz()
{
    local ftEffect=pigz压缩的相关封装
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local isUnzip=false
    local dirPathTargetStorg contentTarget filrNameTarget threadCount dirPathLocal=$(pwd)
    local valCount=5 errorContent arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; case "${arg}" in
    # 说明参数解析部分==============
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
    -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    压缩
#    ftPigz -tc 待压缩目录/文件 压缩文件名称
#    ftPigz -d 压缩文件存放目录
#
#    解压
#    ftPigz -tu 压缩文件路径 解压目录
#
#    ftPigz -j 并发线程数
#========================================================="; return ;;
    # 变量参数解析部分==============
    -tc ) contentTarget="${arg2}" filrNameTarget="${arg3}"
      ;;
    -tu ) contentTarget="${arg2}" contentTarget2="${arg3}"
            isUnzip=true
      ;;
    -d ) dirPathTargetStorg="${arg2}"
      ;;
    -j ) threadCount="${arg2}"
      ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    #依赖校验
    [[ -z $(which pigz) ]] && ftPigz --rely "pigz" && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [[ ! -d "${contentTarget}" ]]&&[[ ! -f "${contentTarget}" ]] && errorContent="${errorContent}\\n[文件或目录不存在]:${contentTarget}"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftPigz -h && return $resultFail

    #实现主体
    if [[ $isUnzip = "true" ]]; then
        local dirPathTargetUnzip=$contentTarget2
        [[ -z $dirPathTargetUnzip ]]|| [[ ! -d $dirPathTargetUnzip ]] && dirPathTargetUnzip=$(dirname $contentTarget)
        tar --use-compress-program=pigz -xvpf $contentTarget -C $dirPathTargetUnzip
        return
    fi
    [ -z "$filrNameTarget" ] && filrNameTarget=${contentTarget}
    local threadCountMax=$(grep 'processor' /proc/cpuinfo | sort -u | wc -l)
    [ -z "$threadCount" ] || (( $threadCount>$threadCountMax )) && threadCount=${threadCountMax}
    filrNameTarget=${filrNameTarget}.tgz
    local dirPathTarget=$(dirname $contentTarget)
    local dirNameTarget=$(basename $contentTarget)
    [ -z "$dirPathTargetStorg" ]&&dirPathTargetStorg=$dirPathTarget

    cd $dirPathTarget
    tar cvPf - ${dirNameTarget} | pigz -p $threadCount > ${dirPathTargetStorg}/${filrNameTarget}
    cd $dirPathLocal
}

complete -W "-h --help --rely -o -f" -A file ftDex2Jar
ftDex2Jar()
{
    local ftEffect=dex转jar
    local isEnable=true

    #可用性校验
    [ "$isEnable" != "true" ] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    #参数解析
    local filePathDex filePathJar dirPathToolResign=${DIR_PATH_ANDROID_DECOMPILE}/dex2jar-2.0
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    指定dex路径
#    ftDex2Jar -f dex路径
#    指定生成路径
#    ftDex2Jar -o 生成目录/文件名.jar
#========================================================="; return ;;
        # 变量参数解析部分==============
        -o ) filePathJar="${arg2}" ; ;;
        -f ) filePathDex="${arg2}" ; ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done
    #耦合校验
    [[ ! -f "$filePathDex" ]] && errorContent="${errorContent}\\n找不到dex文件:${filePathDex}"
    [[ ! -d "$dirPathToolResign" ]] && errorContent="${errorContent}\\n找不到dex2jar工具:${dirPathToolResign}"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDex2Jar -h && return $resultFail

    #实现主体
    if [[ -z "${filePathJar}" ]];then
        local fileNameDex=$(basename $filePathDex)
        filePathJar=$(dirname $filePathDex)/${fileNameDex%.*}.jar
    fi

    for libPath in ${dirPathToolResign}/lib/*.jar ;do _classpath="${_classpath}:${libPath}" ;done

    java -Xms512m -Xmx1024m -classpath "${_classpath}" \
                                                      com.googlecode.dex2jar.tools.Dex2jarCmd ${filePathDex} \
                                                      -o ${filePathJar} \
    && ftEcho -s "生成${filePathJar}"
}

complete -W " -h --help -c -a -p" -A file ftMD5
ftMD5()
{
    local ftEffect=记录和校验文件的MD5

    #参数解析
    local editType filePathVersion filePathInfo
    local errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#   获取文件的MD5，直接打印MD5
#    ftMD5 -c 文件路径
#
#   获取文件的MD5，获取后保存在环境变量不打印
#    ftMD5 -a 文件路径
#
#   获取文件的MD5,校验文件是否一致
#    ftMD5 -p MD5信息保存路径 -c 文件路径
#
#   保存文件的MD5信息
#    ftMD5 -p MD5信息保存路径 -s 文件路径
#========================================================="; return ;;
        # 变量参数解析部分==============
        -c )   filePathVersion="${arg2}"
                if [[ -f "${arg2}" ]]; then
                    echo $(md5sum $filePathVersion | awk '{print $1}')
                    return
                fi
           ;;
        -a )   filePathVersion="${arg2}"
                editType=onlyCreate
           ;;
        -s )   filePathVersion="${arg2}"
                editType=setMd5
           ;;
        -p )   filePathInfo="${arg2}"
           ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done
    #参耦校验
    [ -z "$editType" ] && errorContent="${errorContent}\\n[不知道要干啥]editType=$editType"
    [ "${editType}" != "onlyCreate" ] && [ ! -f "$filePathInfo" ] && errorContent="${errorContent}\\n[没有相关版本信息文件]filePathInfo=$filePathInfo"
    [ ! -f "$filePathVersion" ] && errorContent="${errorContent}\\n[目标文件不存在]filePathVersion=$filePathVersion"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftMD5 -h && return $resultFail

    #实现主体
    local fileNameVersion=$(basename $filePathVersion)
    local versionName=${fileNameVersion%.*}

    while true; do case "${editType}" in
        onlyCreate )
                    export ftMD5Info=
                    ftEcho -s "生成文件:[$(basename ${filePathVersion})]的MD5"
                    export ftMD5Info=$(md5sum $filePathVersion | awk '{print $1}')
                    return;;
        setMd5 )
                    ftEcho -s "文件 : ${fileNameVersion} MD5信息正在生成，请稍等"
                    local md5Code=$(md5sum $filePathVersion | awk '{print $1}')
                    ftIniSetValue $filePathInfo $versionName MD5 $md5Code
                    ftEcho -s "文件 : ${fileNameVersion} MD5信息已生成"
                    return;;
        checkMd5 )
                    ftEcho -bh "文件 : ${versionName} MD5检验开始"
                    local Md5Code=$(ftIniGetValue $filePathInfo $versionName MD5)
                    [[ -z "$Md5Code" ]] && ftEcho -e "文件 : ${versionName}  原始MD5未找到" && exit
                    local Md5CodeNow=$(md5sum $filePathVersion | awk '{print $1}')
                    [ "$Md5CodeNow"x != "$Md5Code"x ] && ftEcho -e "文件 : ${versionName} MD5检验失败" && exit

                    ftEcho -s "文件 : ${versionName} MD5检验成功"
                    return;;
    * ) break;;esac;done
}

complete -W "-h --help -f -n -i " ftCreateMoudleDesktop
ftCreateMoudleDesktop()
{
    local ftEffect=创建快捷方式
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local exeModuleName filePathExeModule filePathIcon
    local valCount=6 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftCreateMoudleDesktop -n 快捷方式名 -f 执行文件路径 -i 图标路径
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -n ) exeModuleName="${arg2}"
            ;;
        -f ) filePathExeModule="${arg2}"
            ;;
        -i ) filePathIcon="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -z "${exeModuleName}" ] && errorContent="${errorContent}\\n请指定快捷方式名"
    [ ! -f "${filePathExeModule}" ] && errorContent="${errorContent}\\n请指定执行文件路径"
    [ ! -f "${filePathIcon}" ] && errorContent="${errorContent}\\n请指定图标路径"
    [ -n "$errorContent" ] && ftEcho -ea "命令[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftCreateMoudleDesktop -h && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd)
    cd /usr/bin
    echo $userPassword | sudo -p '' -S chmod a+x $filePathExeModule
    echo $userPassword | sudo -p '' -S ln -sf $filePathExeModule $exeModuleName
    cd $dirPathLocal

    local filePathReadMeTemplate="${exeModuleName}.desktop"
    local enterLine="\n"
    local content="[Desktop Entry]"
    content=${content}${enterLine}"Encoding=UTF-8"
    content=${content}${enterLine}"Name=${exeModuleName}"
    content=${content}${enterLine}"Comment=抓鸡小能手"
    content=${content}${enterLine}"Exec=${exeModuleName}"
    content=${content}${enterLine}"Icon=${filePathIcon}"
    content=${content}${enterLine}"Terminal=false"
    content=${content}${enterLine}"StartupNotify=true"
    content=${content}${enterLine}"Type=Application"
    content=${content}${enterLine}"Categories=Application;"
    content=${content}${enterLine}

    echo -e ${content} >$filePathReadMeTemplate
    echo $userPassword | sudo -p '' -S chmod a+x $filePathReadMeTemplate
}

complete -W "-h --help -t -i" ftXbGetValue
ftXbGetValue()
{
    local ftEffect=获取xbash数据库中指定TAG中的item[基于ftIniGetValue封装]
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local tagName=$1 itemName=$2
    local valCount=4 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#   获取配置时用户数据库会覆盖默认数据库相同项
#    ftXbGetValue 目标块TAG 键名
#========================================================="; return ;;

    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $# > $valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ ! -f "${rFilePathXbashDBBase}" ] && errorContent="${errorContent}\\n[默认数据库不存在]rFilePathXbashDBBase=$rFilePathXbashDBBase"
    [ ! -f "${rFilePathXbashDBUser}" ] && errorContent="${errorContent}\\n[用户数据库哪去了，你帮忙瞅瞅]rFilePathXbashDBUser=$rFilePathXbashDBUser"
    [ -z "${tagName}" ] && errorContent="${errorContent}\\n[目标块TAG为空]"
    [ -z "${itemName}" ] && errorContent="${errorContent}\\n[键名]为空"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftXbGetValue -h && return $resultFail

    #实现主体
    local itemValue=($(ftIniGetValue $rFilePathXbashDBUser $tagName $itemName))
    [[ -n "$itemValue" ]] && echo ${itemValue[@]} && return $resultFail

    itemValue=($(ftIniGetValue $rFilePathXbashDBBase $tagName $itemName))
    echo ${itemValue[@]}
}

complete -W "-h --help" ftGetPublicIp
ftGetPublicIp()
{
    local ftEffect=获取公网IP
    local isEnable=sub

    #可用性校验
    [ "$isEnable" != "true" ] && [ "$isEnable" != "sub" ] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
    --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 sudo apt-get install $2 补全依赖
#========================================================="; return ;;
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#
#    ftGetPublicIp -h 
#========================================================="; return ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #环境校验
    [[ -z $(which wget) ]] && ftGetPublicIp --rely "wget" && return $resultFail
    #参数校验
    (( $# > $valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftGetPublicIp -h && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd) dirPathTemp=/temp fileNameGetIp=getip
    cd ${dirPathTemp}
    if ! wget http://members.3322.org/dyndns/getip; then
        cd "${dirPathLocal}"
        return
    fi
    cat $fileNameGetIp
    cd "${dirPathLocal}"
}

complete -W "-h --help" ftFastbootUnlock
ftFastbootUnlock()
{
    local ftEffect=fastboot解锁
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftFastbootUnlock -h
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
#    找不到AndroidSDK
#========================================================="; return ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #环境校验
    [[ -z $(which adb) ]] && ftFastbootUnlock --env && return $resultFail
    [[ -z $(which fastboot) ]] && ftFastbootUnlock --env && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftFastbootUnlock -h && return $resultFail

    #实现主体
    ftEcho -y "请确认是否开启开发者选项中的OEM解锁(回车确认)" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y
    [[ "${sel}" != "y" ]] && ftEcho -s "取消操作" && return
    ftAdbConnect
    adb reboot bootloader
    tput sc
    while [[ -z $(fastboot devices) ]]; do
        tput rc;tput ed
        ftEcho -snw "正在等待设备进入fastboot模式"
        sleep 1
    done && echo

    ftEcho -s "设备已进入fastboot模式，请按下音量键解锁"
    fastboot flashing unlock
     while true; do
    ftEcho -y "按下后请查看设备屏幕，在提示解锁成功后，请按下回车[回车后设备自动重启]"
    read -n 1 sel
    [ -z "${sel}" ] && sel=y
    case "$sel" in
        y | Y )
                ftEcho -s "设备将退出fastboot模式"
                fastboot reboot
                ftEcho -s "尝试禁用verity,请稍等"
                adb wait-for-device && adb root && sleep 35 && adb disable-verity && adb reboot
                ftEcho -s "尝试adb root,请稍等"
                adb wait-for-device && adb root && sleep 35 && adb remount
                ftEcho -s "操作完成"
                break;;
        n | q )
                echo
                ftEcho -s "请按下音量键解锁"
                fastboot flashing unlock
                ;;
        * ) ftEcho -e 错误的选择：$sel
            echo "输入n，q，离开";;
    esac;done
}

complete -W "-h -d --help" -A file ftAutoCreateProguardRulesPro
ftAutoCreateProguardRulesPro()
{
    local ftEffect=快速生成模块混淆策略配置文件proguard-rules.pro的模板
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPathModule dirPathModuleJavaSourceCode
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分 ==============
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    查看函数说明
#    ftAutoCreateProguardRulesPro -h
#
#   根据模块路径下的java文件，自动生成proguard-rules.pro在模块路径下
#    ftAutoCreateProguardRulesPro -d 模块路径
#========================================================="; return ;;
        # 变量参数解析部分 ==============
        -d ) dirPathModule="${arg2}"
                dirPathModuleJavaSourceCode=${dirPathModule}/src/main/java
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #参数校验
    (( $#!=$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "${dirPathModule}" ] && errorContent="${errorContent}\\n[模块路径未找到]dirPathModule=$dirPathModule"
    [ ! -d "${dirPathModuleJavaSourceCode}" ] && errorContent="${errorContent}\\n[模块java代码路径未找到]dirPathModuleJavaSourceCode=$dirPathModuleJavaSourceCode"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftAutoCreateProguardRulesPro -h && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd) fileNameConfig=proguard-rules.pro
    local filePathConfigExamle=${rDirPathXbashModuleExample}/proguard-rules.pro.example
    local filePathConfig=${dirPathModuleJavaSourceCode}/${fileNameConfig}

    if [[ -f ${filePathConfig} ]]; then
        ftEcho -y "存在旧proguard-rules.pro，是否删除(回车默认y)"
        read -n 1 sel
        [ -z "${sel}" ] && sel=y
        while true; do case "$sel" in
                y | Y )  echo ; break ;;
                n | q )  echo ; return ;;
                * ) ftEcho -e "错误的选择：$sel"
                    echo "输入n，q，离开";;
        esac;done
    fi
    cp -rf ${filePathConfigExamle} ${filePathConfig}

    local packageList=($(find ${dirPathModuleJavaSourceCode} -name *.java | xargs cat |grep package))
    local packageList=($(awk -v RS=' ' '!a[$1]++' <<< ${packageList[@]})) #去重复
    for packageName in ${packageList[@]}; do
        if [[ ${packageName} = "package" ]]; then
            continue
        fi
        packageName=$(echo $packageName | sed -e "s:;::g")
        echo "-keep class ${packageName}.**  {*;}" >> ${filePathConfig}
    done

    ftEcho -s "创建成功"
}

complete -W "-h --help -c -d" ftVpnControl
ftVpnControl()
{
    local ftEffect=anyconnect的简单封装,提供快速连接和断开VPN
    local isEnable=true

    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local filePathAnyconnect=/opt/cisco/anyconnect/bin/vpn
    local isConnect isDisConnect isRestPassword isReInstall
    local valCount=1 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))} ; case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    工具依赖 anyconnect
#    请确认anyconnect是否安装或已损坏
#========================================================="; return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    连接VPN
#    ftVpnControl -c
#
#    重新输入密码,连接VPN
#    ftVpnControl -cp
#
#    断开VPN
#    ftVpnControl -d
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -c ) isConnect=true
            ;;
        -cp ) isConnect=true
                isRestPassword=true
            ;;
        -d ) isDisConnect=true
            ;;
        -ri ) isReInstall=true
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
   [ -z "$isReInstall" ]&& if [[ ! -d "/opt/cisco/anyconnect" ]] || [[ ! -f "$filePathAnyconnect" ]];then ftVpnControl --rely && return $resultFail ; fi
    #参数校验
    (( $#==0 )) && errorContent="${errorContent}\\n缺少参数" 
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -f "${rFilePathXbashDBUser}" ] && errorContent="${errorContent}\\n[未找到VPN配置]${rFilePathXbashDBUser}"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftVpnControl -h && return $resultFail

    #实现主体
    local tag="vpnConfig_anyconnect" keyHostName="hostName"
    local hostName=$(ftIniGetValue $rFilePathXbashDBUser $tag $keyHostName)

    if [[ "$isConnect" = "true" ]]; then
        local keyUserName="userName" keyUserPassword="userPassword"
        local userName=$(ftIniGetValue $rFilePathXbashDBUser $tag $keyUserName)
        local userPassword=$(ftIniGetValue $rFilePathXbashDBUser $tag $keyUserPassword)

        if [[ "$isRestPassword" = "true" ]]; then
            $filePathAnyconnect  -s connect ${hostName}<< EOF
${userName}
${userPassword}
y
EOF
            $filePathAnyconnect -s disconnect ${hostName}
        fi
        $filePathAnyconnect  -s connect ${hostName}<< EOF
${userName}
y
EOF
        return $resultSuccess
    fi

     if [[ "$isDisConnect" = "true" ]]; then
        $filePathAnyconnect -s disconnect ${hostName}
        return $resultSuccess
     fi

     if [[ "$isReInstall" = "true" ]]; then
        local dirPathLocal=$(pwd)
        local dirPathAnyconnect="$(ftXbGetValue vpnConfig_anyconnect toolsDirPath)/vpn"
        local installToolFileName=vpn_install.sh
        local uninstallToolFileName=vpn_uninstall.sh

        cd ${dirPathAnyconnect}

        echo $userPassword | sudo -p '' -S chmod a+x $installToolFileName $uninstallToolFileName
        sudo ./${uninstallToolFileName}
        sudo ./${installToolFileName}

       cd ${dirPathLocal}
        return $resultSuccess
     fi
}

complete -W "-h --help --rely_install -f" ftDelRepeatFile
ftDelRepeatFile()
{
    local ftEffect=删除重复文件
    local isEnable=true
    #可用性校验
    [[ "$isEnable" != "true" ]] && ftEcho -s "${ftEffect} 已被禁用，请确认" && return
    #解参验耦
    local dirPathTarget
    local valCount=2 errorContent arg arg2 ; for ((i=1;i<=$#;i++)) ; do eval arg=\${${i}} ; eval arg2=\${$((i+1))}
    case "${arg}" in
        # 说明参数解析部分 ==============
        --rely) ftEcho -rc "${ftEffect}" "的依赖说明" "\
#=========================================================
#    ${ftEffect}依赖包 $2
#    请尝试使用 ftDelRepeatFile --rely_install 补全依赖
#========================================================="; return ;;
        --rely_install)
            ftEcho -s "开始补全依赖"
            sudo apt-get install xxxx
            return ;;
        -h | --help) ftEcho -rc "${ftEffect}" "的使用示例" "\
#=========================================================
#    以下[参数对]无先后顺序可任意组合
#
#    ftDelRepeatFile xxxx
#========================================================="; return ;;
        --env) ftEcho -rc "${ftEffect}" "的使用环境说明" "\
#=========================================================
#    环境未初始化
#    使用前,请先初始化[xxxxxxxxx]
#========================================================="; return ;;

        # 变量参数解析部分 ==============
        -f ) dirPathTarget="${arg2}"
            ;;
    * ) [[ -z "${arg}" ]] && break ;; esac;done

    #依赖校验
    [[ -z $(which fdupes) ]] && ftDelRepeatFile --rely "fdupes" && return $resultFail
    #参数校验
    (( $#>$valCount )) && errorContent="${errorContent}\\n参数默认有${valCount}个,当前为$#个" 
    [ ! -d "${dirPathTarget}" ] && errorContent="${errorContent}\\n[目录不存在]dirPathTarget=$dirPathTarget"
    [ -n "$errorContent" ] && ftEcho -ea "函数[${ftEffect}]的参数错误${errorContent}\\n请查看下面说明:" && ftDelRepeatFile -h && return $resultFail

    #实现主体
    local dirPathLocal=$(pwd)
    local fileNameFileListScanResult=RepeatFileScanResult.list

    fdupes -Sr "${dirPathTarget}" > $fileNameFileListScanResult
    sed '/bytes each/d' ${fileNameFileListScanResult} > ${fileNameFileListScanResult}2
    mv ${fileNameFileListScanResult}2 $fileNameFileListScanResult
    local repeatFileScanResultList=($(cat ${fileNameFileListScanResult})) && rm $fileNameFileListScanResult
    local fileIndex=${#repeatFileScanResultList[@]} fileIndexNext 
    local filePathNow filePathReldey fileNameNow fileNameReldey
    while (( $fileIndex>0 )) ;do (( fileIndex-=1 ))
        [[ ! -f "${repeatFileScanResultList[$fileIndex]}" ]] && echo "${repeatFileScanResultList[$fileIndex]},不存在" && continue
        echo
        (( fileIndexNext=fileIndex-1 ))
        filePathNow="${repeatFileScanResultList[$fileIndex]}"
        filePathReldey="${repeatFileScanResultList[$fileIndexNext]}"

        fileNameNow=$(basename $filePathNow)
        fileNameReldey=$(basename $filePathReldey)

        if [[ "${filePathNow}" == *备份* ]] || [[ "${filePathReldey}" == *备份* ]]; then
            [[ "${filePathNow}" == *备份* ]] && rm "${filePathNow}" && echo "自动删除: ${filePathNow}"
            [[ "${filePathReldey}" == *备份* ]] && rm "${filePathReldey}" && echo "自动删除: ${filePathReldey}"
            continue
        fi

        [[ "${fileNameNow}" != "${fileNameReldey}" ]] && echo -e " ========跳过 =========\n${filePathNow}\n${filePathReldey}\n==============" &&echo && continue

        echo ${filePathReldey}
        ftEcho -y "是否删除文件:${filePathNow}" && read -n 1 sel && echo ; [ -z "${sel}" ] && sel=y
        [[ "${sel}" = "y" ]] && rm "${filePathNow}"
        [[ "${sel}" = "n" ]] && rm "${filePathReldey}"
    done
}

ftSync()
{
    local ftEffect=两个目录间同步
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return
    
    local dirPathChangeTarget dirPathStandard isEnableTest
    local arg arg2 arg3 ; for ((i=1;i<=$#;i++)) ; do  eval arg=\${${i}} ; eval arg2=\${$((i+1))} ;eval arg3=\${$((i+2))} ; case "${arg}" in
        # 说明参数解析部分==============
        -h | --help) ftEcho -rc "${ftEffect}" " 的使用示例" "\
#=========================================================
#
#    同步目录间差异，将修改目标目录
#    ftSync -s 基准目录 目标目录
#
#    查看目录间差异，显示目标目录与基准的不同
#    ftSync -t 基准目录 目标目录
#
#========================================================="; return ;;
        # 变量参数解析部分==============
        -l ) dirPathStandard="${arg2}"
             dirPathChangeTarget="${arg3}"
          ;;
        -t ) isEnableTest=true
              dirPathStandard="${arg2}"
              dirPathChangeTarget="${arg3}"
          ;;
    * ) [[ -z "${arg}" ]] && break  ;; esac;done

    # local dirPathStandardReal=$(readlink -f  "${dirPathStandard}")
    # local dirNameStandard=$(basename "${dirPathStandardReal}")

    if [[ $isEnableTest = "true" ]]; then
        rsync -n -avum -p --append -e ssh --link-dest ${dirPathStandard} --delete ${dirPathChangeTarget} ${dirPathStandard}
    else
        # rsync -ac --delete -v ${dirNameStandard}/ ${dirPathChangeTarget}
        rsync -avum -p --append -e ssh --link-dest ${dirPathStandard} --delete ${dirPathChangeTarget} ${dirPathStandard}
    fi
}

ftLoadGitCompletion()
{
    local ftEffect=加载GitModule[非自定义]
    local isEnable=def

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

    local gitVersion=$(git --version)
    gitVersion=$(echo $gitVersion | sed -e "s:git version::g" |sed s/[[:space:]]//g)

    local checkResult=$(ftVersionComparison "2.4" "${gitVersion}" )
    if [[ $checkResult == "<" ]]; then
        return
    fi
    if [[ -f $rFilePathGitBash ]];then source  $rFilePathGitBash && echo 123
    else echo -e "\033[1;31m非Xbash自定义的git扩展块加载失败\n${rFilePathGitBash}\033[0m" ;fi
}

ftDf()
{
    local ftEffect=Df高亮显示封装
    local isEnable=true

    [[ "$isEnable" = "false" ]] && ftEcho -s "${ftEffect} 已停用，请确认" && return

    df -lh |grep -E "Filesystem"| awk '{print "\033[1;33m" $0 "\033[0m"; }'
    df -lh |grep -E "文件系统|/dev/" |grep -v "/snap" |grep -v "/boot/efi" \
    | awk '{ if ($5 >= 75) print "\033[0;31m" $0 "\033[0m"; else print $0 }'
}
